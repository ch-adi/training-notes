General Ideas

Do pet projects. Push them to github with an elegant readme. Follow all the best practices. Do not write messy code just because it's your pet project. Create a detailed portfolio out of these projects and put them out in your personal website. Not only do these provide proof of your skills, and your interest in coding beyond work, but they also are quite possibly a better way to learn and grow than your normal work.

Contribute to open source projects. Even little things like improving a sentence in documentation or reporting a new bug are very important.

Network!!!! Go to tech meet ups, events, conferences. Actively participate in online tech communities such as SOF. Keep in touch with former workmates who now work elsewhere. Most jobs come from contacts, not job ads.

If doing an at home code test apply professional skills, like providing a change-log with the completed code that contains quality commit messages. However, while you should treat the test like real work, don't over engineer it. Most problems are little one line bugs that need to be fixed.

Update your linkedin profile and allow contacct from recruiters. Recruiters are far more liklely to contact you once you have at least a couple of years of experience.

One skill a lot of employers look for is people skills/soft skills, even for software engineers.

I seek to work with people who can problem solve, who are willing to learn continually, who get along with the team, and who care enough to produce quality code and systems.


Career Mistakes

Staying in one job / company too long. Probably the most common pitfall. You’re at the same place long enough, become the go-to “expert”, the job starts to look easy, you become complacent and suddenly the job and you are both gone. Or, you’re at a place long enough and suddenly people only see you a certain way and can’t see you doing anything else. A good rule of thumb is to switch jobs every 2–3 years. Please note, I said job not companies. If you’re growing and doing well at your existing company, then stay on, but keep moving and learning. Another rough rule of thumb is not to stay at any one company beyond 12 years. Any longer and you’ll likely be seen as a one-company person. A decent average these days seems to be about 6 years.
Not taking enough chances. Note, I said chances and not risks. While they may seem the same, they’re not. Risks imply downside. Chances come with upside as well as downside. Risks turn people off, but almost everyone is willing to take chances. And, they should. So go work overseas, or join that new department, perhaps switch functions, because each of these will come with upside and downside. Keep taking such chances and you will grow and develop yourself admirably and completely avoid Pitfall #1.
Misreading opportunities. If you’re highly regarded in your company, you may get asked to take on seemingly hellish assignments. Instead of being rewarded for your performance, you seem to be getting punished! In reality, you are being tested. The company is counting on you to go to the country no one wants to, and rescue the business that is doomed. If you succeed, you’re an unquestioned hero. Even if you give a great effort then HQ will also notice and enter another check-mark against your name. In some cases, the opportunity may even be a favor to your bosses, and in turn you will get something better later on. Before you take on the new role, get some assurances on the role after this one (understanding that there are no hard promises in the corporate world) and then go and give it your best.
Disappearing into your work. The days of keeping your head down, doing your work and being recognized for it are long gone. I’m not sure such days were ever really there. Even as you do good work make sure that everyone realizes its your doing. You don’t have to be brashly arrogant about it (better not to be), but make sure your name stays together with your successes. Also, make sure you recognize the people that help you succeed, such as your team. Its simply good practice and also enhances your reputation as a great team player without losing your individual contributions to overall success. Also, be visible externally. Speak publicly at events and be known in your community as an expert on something. This enhances your reputation and overall employ-ability.
Not having a network. Too often people do the job and go home. Some may engage in after-work team bonding. Slightly more enlightened types will catch up with the boss. But, the truly smart ones will do all this and also build connections across the organization. This activity is a virtuous cycle. The more people you know and relationships you have, the more effective you will be in your current role. And, all the people that you know you will notice your good work and you’ll climb in their estimation. When the next great role opens up, one that you’re not even aware is available, guess who’s name will be at the top of the candidate list? The only caution is that networking is too often mistaken for brown-nosing. When you network you connect with people you like, regardless of what they do for you. When you brown nose you tolerate people and only pretend to like them for what they can do for you. Everyone eventually spots a fake. Don’t be one.
Pursuing prestige over substance. A lot of my colleagues chased titles. Important sounding ones. Global Head, Regional Business Head, Head of ….. you name it. If it looked impressive on a business card, everyone wanted it. Unfortunately, titles have to be earned, the hard way. Being a Regional or Global Head (while sounding senior) is meaningless if you don’t have the knowledge and influence to do it properly. That means you need hands-on experience at various country-level roles, building up expertise, learning to manage teams, growing the business. Everyone respects hands-on experience. If you have it, people will listen to you regardless of title. If you don’t have it, then people will politely tolerate you because of your title, but you will otherwise be ignored. While titles are wonderful and desirable, make sure that the role has real substance and that you will learn and grow doing it. Otherwise, you will end up becoming an empty suit, while those who took lower-ranked but meaningful roles will zoom by you on the corporate ladder,
Being overly reliant on the boss. Your boss is very important to your future success, but he/she isn’t all-important. Just like you, they may be making some or all of the mistakes outlined above. And, if your boss is going nowhere then you surely are as well. A good boss can really help pave your career, but where that career heads is entirely in your hands. Its unreasonable and unfair to expect your boss to be your career counselor. Instead use your visibility and your networks to stay aware of developments in your firm and where the opportunity areas are that interest you. Your responsibility is to keep progressing. A good boss can help you along, provide useful feedback, even help make the right connections. But, on the off-chance they can’t or won’t, isn’t it then better to manage it yourself?
Assuming your skills are nonexchangeable. In fact, the same core skills can apply across a broad range of jobs and even industries. People get fixated on the “I only know Excel” mindset. Being good with numbers, managing people, leading projects, building teams, speaking in public, creating presentations, etc are a broad set of skills that are handy everywhere. Instead of believing your skills are too specific, think of them more broadly. This will help you with corporate mobility and prevent you from always taking on similar roles, which is also problematic, because then you may get characterized as being one-dimensional.


Self taught engineers:

Instead of trying to figure out what a self-taught programmer should study, the key is to be curious and deep dive into unfamiliar concepts whenever you face them. Eventually you will realize that self-taught and formally-educated programmers will always have something new to learn.


What common career mistakes do programmers typically make?

Concentrating on learning only technologies and neglecting knowledge in software engineering principles and concepts.
Not asking for a raise when they truly deserve it.
Not making their work visible and expecting management to pay attention to their individual contributions.
Not talking enough to end-users or product owners, and as a result, building the wrong things all the time.
Staying late for work and neglecting time with family, friends and yourself. Learn to say no.
Not investing time in improving your soft skills, they are really important in this profession.
Not reading enough, that’s easy-to-get knowledge with the potential of skyrocketing your skill level.
Not writing tests, tests help save your reputation.
Being an unsavory character, there is a list of people I’d never recommend for an interview, it was a pain to work with them.
Going to meetings that could have been emails. Respect your time and remember you are not paid to attend unnecessary meetings.
Losing the perspective that your job is not to write code, your job is to provide value, whatever that means in your context.



Signs of Intelligence

Having said that, in no particular order, the signs that one is interacting with a person that has a very high level of intelligence include perceiving in that person:

An appetite for information and knowledge, which includes not only curiosity, but also a veritable “need” for intellectual stimulation;
The ability to quickly understand your arguments without the need for much explanation, perhaps even anticipating the final conclusion before you get to it;
Identifying interesting implications and consequences of your arguments that you yourself had not considered;
Displays of rapid perception, strong learning capacity, and substantial problem-solving abilities;
A broad scope and/or depth of knowledge;
The ability to perceive and appreciate the relevant talents and accomplishments of others.



What are the biggest myths software engineers believe?

My favourite - I know what I'm doing.
This code I'm inheriting is crap. I'll have to write it from scratch.
This is just a temporary hack - I'll come back and fix it later.
I will commit all my changes at once, once I am done.
The developer who can code the best is the one that would who should be promoted.
There is lot of management, that I am wasting time on meetings instead of writing code
Younger devs are better than older ones
To be a good developer, you also have to behave nerdy and awkward
Smarter developers are all that's needed to produce better code
The business team have no idea what they want.
My language/framework/operating system is better, faster, most robust than Yours.
I don't need to learn other languages other than what I master. Using this language I can program any solution.
Objects are good- Everything should be an object.
Design patterns are good. If a ‘pattern’ is indeed re-usable, it should be a made into a reusable class or framework (like Model-View-Controller.)
Development time is predictable and every risk can be managed.
My way of structuring code is clear and concise. Everyone else can understand.
I don't like this style of code, it should be refactored to how I do things.
I'm an awesome programmer.
Code reviews are a waste of time.
Meetings are a waste of time.
Junior programmers aren't experienced enough to have input into the design, structure, etc.
If I just copy paste code once I wont do it again.
Writing long methods, classes, etc. make code more readable, since it keeps related code close.
My code is too complicated for unit testing.
I've learned everything I need to know to do my job. I should only learn new things purely on a need-to basis.
I should only fix issues once a client complains. It's ok to ignore/overlook bugs I come across otherwise. It's a waste of time to fix those unless absolutely necessary; I have better things to do.
Last but not the least -Using Mac OSX makes a better programmer


Charasmatic People
1. Confident
2. Humble
3. Smile
4. Passion
5. Ask questions about others


Salary

Four things helped me make significant increases

Choosing the right stack. When I switched from Funding Circle to Elsevier a big reason apart from money was that I wanted to learn AWS, Java and React. That was a fantastic decision. Those three are extremely popular. When recruiters get in touch they still mention my great experience at Elsevier. I always agree and thank them sincerely… even though I forgot most of what I did at that particular job!
Getting better and becoming more senior. For me it took only three years until someone was ready to give me the title senior engineer. Sure, there were some people ten years older giving me snide looks, but I got it nonetheless. To get there you will have to continue studying perpetually. If you have no degree look up MIT, Cambridge or other top uni syllabuses. They’re usually quite open about the content of their courses. You will be able to find free lectures and great book recommendations. This is how I back filled my missing CS knowledge. This takes years because it’s hard. If you’re lucky to have chosen a technical degree and already have it then I suggest invest more in softer skills. Uncle Bob has a few good books and there are plenty others that will help you improve. A lot of the things you will learn are quite theoretical but you’ll be surprised how important it is to be able to sound smart on the job.
Not being attached for the wrong reasons. Some people become too attached to their employer and are afraid to look elsewhere. They believe that the amount of time they spend somewhere matters. That’s stupid, don’t be like that. When push comes to shove, your employer will not hesitate to cut you loose. Don’t hesitate to cut them loose either when it’s right for you.

Many companies have a cap (something like a few percent) on how much of a raise they can give you. In a market where software engineers are in demand, I noticed that in many cases someone else will always be prepared to beat that cap and offer you more. Use this to your advantage.
Negotiating well. This is extremely important. I had colleagues who were ten to fifteen years more experienced than me and at the same time they earned less. They were all very competent people but the recruiter got the better of them at the negotiating table, simple as that. Until I got to Dow Jones, I always accepted the first offer on the table. I didn’t even consider playing competing offers against each other because I was so happy to get a job. Big mistake. If you’re afraid to even ask for more than all that’s happened is that you got out-negotiated at the first step. That’s all.

For example, Dow Jones initially offered me £44k. I decided to put them on hold. Another offer came in at £47k. I called Dow Jones and asked them to increase their offer. They went up to £50k. The competing company matched that offer. Dow Jones then went up to £53k at which point I accepted. Still a mistake, but not as big as it would have been at £44k.
Always remember: your income is not a simple measure of how much you work - it depends much more on what you can negotiate. This is the reason there are people right now making millions per day doing way less than you and I.

Points one to three, becoming more experienced, competent as well as more confident, are really just ways to improve on your negotiating position. You can also move to a new location, you can become more popular, you can become needed, you can become influential, you can become better looking through sports, you can work on your charm or you can have your current or prospective employer worried about missing out on you.

For some time I thought it’s all about skill and the company will pay me accordingly, and I regret that. Whoever is hiring you will do better the cheaper they get you. Do learn to exercise pressure in the right amounts, because you will never get more unless you ask for it.

If you do keep improving and play your cards well your salary will go up and it will go up quickly.



Why is Germany so Successful

Whenever Germans are in the room, they will ask the most challenging, well-thought-through questions and will make the most interesting contributions to any debate.

It never fails.

Having worked in Germany and worked with countless Germans as well, I put their success down to an ability to consider all options, even the most unlikely ones, and then MAKE A DECISION.

Germany produces—and exports—deciders.

Germany sees indecision as an enemy to be fought and beaten, but always after a fair, thorough battle. This thoroughness is its strength.




What are the characteristics of a bad software engineer?

They are what I call the trigger happy programmers/engineers.

Give them a problem, they start coding immediately. They continue down the very first chain of thought and slog their way to a “working” solution. No deliberation to think clearly about the problem, evaluate multiple solutions, think about design etc.

Ask them how will you test your solution, their answer: run the program and eyeball the result. That's it.

Ask them how you troubleshoot, their answer: with print statements.

Give them a problem and ask for an estimate, within 30 seconds they will say X days. No methodology involved. Just an “intelligent” guess.

Ask them about reusability, their solution is to copy-paste similar looking code across projects.

These guys are not just bad, they are indifferent and irresponsible. They unfortunately shine in the eyes of non-technical members of your organization because they often code and churn out solution at faster rate. They do not say NO to any feature. They do not ask for time to research. They do not care about learning new technologies. They leave tremendous technical debt.




Junior devs:

"Every day my mission is to find ways to help everyone else on my team do better work. I look for learning opportunities in every task and interaction, no matter how big or small."

First and foremost, I'd expect a junior developer's top priority to be improving their skill and knowledge as a developer. This means they can't have an ounce of entitlement. Humility, curiosity, and hard work are your watch words.

The second I hear something that even smells like "that's not worth my time" is the second they get their first reprimand. 

Wrong level of abstraction / code not abstracted. Functions / components that are too specific but should be a bit less specific and others that are too general where they should be a bit more specific.

Unaware of pre existing solutions. Often there might be a existing component / function hidden in utils.js that handles a part of the problem the juniors code is solving. Often juniors are not aware of these and implement their own solution instead.




Soft skills are just as important as technical skills:

The sad fact is that we can train a monkey to do technical work, but you can’t train one to pay attention to details, listen to your clients, put their needs first, sense of responsibility, and many other soft skills that are significantly more important for any organization to succeed.

Here are a couple of examples of questions that you may expect from someone like me:

“we have recently rolled out an in-house accounting software that accounting team heavily complaints about. How would you go about fixing it?”
Your answer better start with “I’ll go to the client and investigate what is not working for them, then review, categorize, prioritize those needs…”

“You are implementing an upgrade of your system, combined with new hardware, new IP addresses, DB upgrade and operating system upgrade. After bringing everything online, the users are not able to access the system. Where do you start your analysis?”
Unless the answer is “why would you do all of that at the same time?” you will probably fail to convince me that you know much about complex systems…


Testing:


What should beginner programmers know about software testing?
Brian Fey
Brian Fey, Founder / Director at Bosque Village (2004-present)
Updated Jul 3, 2015
Without good testing, software companies fail. 

I started working with software development in 1985. (First program written in 1979, but I was in 6th grade, so not ready to be in the industry.)

Over and over, there were waves of software booms but many companies failed because flaws in the software created a need for costly technical support or bugged the user into turning to another product. 

As a beginning developer, have your friends look over your work and code with a critical eye. You will both improve your skills. 

There is no successful development without testing. 
When I was a Test Manager, sitting next to the Development Manager for my group, Bill Gates told us, "Microsoft is not a software development company. Microsoft is a software testing company." I was pleased with Bill's words since my Dev manager had come from a military background and had arrived to Microsoft believing that testing should happen only after the coding has been finished. He did not think testers should have access to the source code and was used to very solid specs. That caused some initial conflict but he soon adjusted to the development cycle at Microsoft. Unlike the military, we were often working with changing specs, and always working to serve very diverse customers. After some struggles we settled into managing our dev and test teams into a very productive relationship and made great products. 

Do you need testers?
Testers are kind of like editors for writers. 
I think it would be wrong to say "you can't edit your own work" or that "You can't test your own code".  You can and you should. 
But having an editor or a tester protects you from your own lack of vision. Your eyes cannot see your creation as the user will. 
A qualified, motivated editor or tester can make you look very good, and in the case of software, save your company. 

Testers have a strange eye. 
Software testing requires a strange skill. I interviewed, hired and fired many people over my years in the industry. 
You can learn some skills for testing, but I don't know that the intuition and analytical viciousness can be taught. Some people seem to just have that critical eye that most people don't 
I have done interviews and shown applicants a program to evaluate. Some find a small problem or two. The ones I hired could rip apart many aspects of the design. They can see options which don't exist and wonder why one is better than another. And they are able to see through the eyes of an innocent or ignorant user and wonder what failures of user experience could occur. Testing is a strange discipline requiring intuition.  Testers protect users from the bad influence of marketing, and the programmer geek who can't see from the novice user's perspective.

Testing should be involved from the beginning. 
Testing is cheap in the long run. Using the critical eyes of testing to find problem at the spec level make for easy fixes.  
If you have to find a problem in Usability Testing, then it will lot more to fix and indicates you may have a problem in your development process. 
In the rush to market, it is worth it to have advocates protecting the user, making sure the product is accessible to people of different abilities, will operate on various platforms, and be able to be internationalized later. 

Be nice to your testers. Be nice to your developers. 
In a sense, testing and development can have an apparent adversarial relationship. Try to keep it pleasant knowing you are on the same team. Creation and destruction go together like Yin and Yang.
Testers should write very clear bug reports to help it be easy for the developer to see and reproduce the problem. Developers should not see bugs as criticism, but as help. 
Testing is a mostly thankless job. As a tester you get to take credit for the bugs that are not there. 

Web testing?
I suspect testing has gotten easier for some types of software development. 
Rather than risk millions of dollar manufacturing CDs with the risks of a bug you can't fix , web developers have the option of fixing errors and delivering them instantly. 
But with web development, testing still matters. Errors piss users off, and sometimes there is no way to say you are sorry. Even a brief bad user experience can drive your user away forever and damage your brand. 


Testers do slow things down. It is worth it. 
All products ship with bugs. 
Sometimes, no matter which way you do something, it is still a bug. 




Developing into a developer:

Mathematics : Calculus, Trigonometry, Algebra and Linear Algebra are the most important basis. Then Graph Theory and Category Theory are very important fields. You can find courses on KhanAcademy for free. MIT courses are good too.
Algorithms : the Introduction to Algorithms book is pretty classic. https://mitpress.mit.edu/books/introduction-algorithms-third-edition 
Computer Architecture and Operating Systems : OSTEP and Write Great Code are very good starting resources. http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html https://nostarch.com/greatcode.htm 
Networks : Computer Networking - A Top Down approach is just the best book for it. https://www.amazon.com/Computer-Networking-Top-Down-Approach-6th/dp/0132856204
Programming : just learn a few programming languages (C is mandatory*) and solves stuff at TopCoder, ProjectEuler, HackerRank etc





I can only truly speak to myself as a 10x developer, and here’s what I believe to be different about me and the other 10x (or even 100x) developers vs my 1–2x peers:

Understanding how things work.
I hate “magic” software frameworks and I will spend countless hours making sure I understand what’s going on behind the scenes before I’ll write production software in that system.
There’s no shame in not understanding how something works and spending time learning it. Even if it takes you longer than your friend.
Understanding how software and related hardware things fit together.
Similarly to the above - I hate “magic” systems - I won’t trust myself to work with a system I’m talking to until I understand how it works (at a medium level).
For example, I learned how to use TCP/IP very early and I really dove in - I wrote clients and servers, hand-wrote HTTP clients and such, because I wanted to prove to myself that I understood how it worked.
Understanding the business/problem domain well before we design and write software for the domain.
For example - if I’m working for a company that sells products in stores, I try to understand as much as I can about the business - what types of products, what types of customers, what types of business rules, etc. Especially the first few times you do this, you will be amazed at how much software you can avoid writing to solve problems that won’t exist.
Note that this is one of the keys to being 10x : don’t write software that you don’t need.
Identifying and anticipating the most common changes that are likely to be made by our customers, and building our software to support those types of changes, BUT NO OTHERS
Many developers think that they’re being smart by abstracting everything, but really, they’re just mimicking more skilled developers without understanding why.
Anticipating the few most likely changes is smart. 70% of the time, the changes will be in those areas. Trying to design your software to support any possible change is a huge waste of time for everyone.
This requires experience, which takes time, be patient.
Not writing software to show off our sophistication, intellect or skill.
I focus on solving the problem in a clear and understandable way.
The most likely future reader of my software is me, and after a few weeks, I’ll be completely lost if i didn’t write it clearly the first time.
If I come back to my software and I find it confusing and complicated, I immediately rewrite it if I can, so it is no longer confusing and complicated.
Writing our software with the assumption that we won’t remember how it works the next time we look at it.
I love Test-First Development, because it forces me to think about the software as a client, rather than the developer.
It also makes my software more modular, because I have to think about the different pieces as individually testable elements.
I write lots of unit tests where I can.
Partially because it makes my software better
Mostly because I work on so many different software projects over time that whenever there’s a bug 3 months down the road, I can use the unit tests to help re-orient me to the software I’m debugging.
I also have a few personal habits that I’ve developed over time:

When I was younger, I wrote lots of libraries because I didn’t like the libraries that were out there, they weren’t intuitive enough for me.
This taught me how the libraries worked, which was really helpful
But over time, I grew to accept that it was much more efficient to spend my time understanding the philosophy of the person who wrote the library, rather than writing my own version of it.
After you do this a few times, you start to recognize the common philosophical approaches, and it cuts down on your learning time for new libraries, which makes you more effective.
There are douchebags everywhere who will criticize every line of software produced that doesn’t conform to their exact preferred strategy. They will try to make you feel inferior and stupid for not “doing it their way”
Almost without exception, they are far better at shaming than they are at software development.
In other words, to the extent possible, don’t let them take up your time or energy. Just smile, nod and do it your way anyways
This is classic “correlation, not causation”, but I spent a lot of time building with legos when I was younger.



Promotions:

Promotions are about the future, not the past: Some people think, “I’ve done all this great work, so I should get promoted!” But managers don’t give out promotions as a reward for great work—instead, they promote you only if you can benefit the company more at the higher level. A promotion is about the future: if you can add more value to the company as a principal engineer than as a senior engineer, then you will be promoted.
The higher levels are about increases in scope: You won’t necessarily rise in level by just getting better at what you do—you need to expand the scope of what you do. For example, if you’re an engineer who owns a feature in a product, you need to starting thinking about the entire product. If you’re a senior engineer with a good grasp on the whole product, you need to start thinking about the engineering process of the team and its relationship with other groups in the company.
Influence without authority is critical: As an entry level engineer or even a senior engineer, you can basically just do what you’re told and succeed. At the higher levels, you will need to participate in collective decision making with other members of the team and with other teams in the company. Can you convince your team-mates to follow a certain architectural path? Can you convince another team to take a dependency on yours? Can you convince your VP to give you more resources or more time (or alter the requirements)? The better you are at this, the more valuable you’ll be to the company.
Your value increases as your relationships deepen: I worked for my VP for many years, and in that time we both learned each others strengths and weaknesses. I could have a high-bandwidth conversation with him because I knew how he thought. Conversely, he knew what projects to assign me because he knew what I was good at. And of course, that meant that I had a higher chance to succeed and thus a higher chance to tackle larger and larger scopes.
Help people to be successful and you will be successful: If you help your boss to succeed, then they will be more likely to promote you because you’ll be able to help even more if you have a larger scope. If you help your peers to succeed, then you will help your team succeed, which helps your boss succeed. If you help other teams succeed then their managers will support your boss when it comes time for a promotion. Success begets success, but only if you share it.



What kind of people will not succeed in life?
-------------------------------------------------

For a long time, I was not very successful in life. I am intelligent. I have skills. I worked incredibly hard. Yet I got nowhere, until a cousin said to me, one day, “You don’t get what you need because you don’t ask for anything. The worst thing that can happen if you ask for help or opportunities is that you’ll be refused, and then you are no worse off than if you didn’t ask. But imagine if you asked for something and the answer was ‘yes’! Maybe you could try asking for a better job, a promotion, a loan to invest in something, a good reference…? Try it!”

I did, and suddenly my world changed. I realised, years later, that I had struggled because I had been put down so often that I didn’t believe I deserved success, so I didn’t ask for help to attain it. I had been conditioned to distrust those who offered a helping hand or to open a door - to think they had evil motives - so I didn’t accept their offers.

There are lots of ingredients contributing to success in life. Of course, the effort you put in is a major determinant, but the hardest workers often don’t succeed. It takes far more than just effort.

People born into successful families often succeed because they are shown how to succeed from an early age. They are guided to invest effort in the right areas. They are taught how to relate to people of influence. They are introduced to people who can open doors for them. They are taught to believe in themselves and the opportunities the world offers them. They learn to ASK for what they need.

People with influential friends or mentors may enjoy the same advantages as those born into successful families.

Perhaps the most significant factor driving success in life is self-belief. If you believe you lack ability, or opportunties presented are never genuine… if you lack the ability to trust yourself, other people and the system, then no amount of hard work is likely to result in success.

Trust is vital because to succeed, you have to ask for things. You have to not be afraid of rejection. You have to believe in the opportunities the world offers. You have to be willing to take risks, and that requires belief in yourself and the support systems available to help you recover if you sometimes fail.

Environment is a major factor contributing to success, for two reasons. First, some environments offer more opportunities. People who move in environments filled with people of influence have more opportunities. People who move among people who are confident and willing to teach and guide and encourage others have more opportunities. People who move in environments where capital is easy to access have more opportunities. People born into affluent environments have more opportunities. It’s much harder to succeed when you are struggling to keep a roof over your head and food on your table. When your energies are consumed with providing basics and there is neither energy nor money to invest in progress, working hard achieves little other than to leave you exhausted and feeling things are hopeless.

The second reason environment is a major factor is that environment contributes substantially to building self-belief and trust. It has been evidenced through research that people who grow up very poor, abused or unloved tend to be less successful because they are less likely to develop self-belief and the ability to trust. They may be very skilled and intelligent. They may work incredibly hard. They may be honest and ethical and get along well with others, but if they cannot believe in themselves and trust the opportunities presented, success will elude them.

Please don’t insult these battlers by pretending success is attained simply by working hard. Hard workers often don’t succeed despite their efforts, and they need respect, understanding, and recognition of their endeavours to lift them up in the world.
