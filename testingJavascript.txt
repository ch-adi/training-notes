

Fundamentals of Testing In Javascript
----------------------------------------------

Say We have a bug in our sum function. To make sure it enver happens again we write a test. Essentially, . A test is code that throws an error when the actual result of something does not match the expected output. 

    const sum = (a, b) => a - b;

    const result = sum(3, 7);
    const expected = 10;
    if (result !== expected){
        throw new Error(`${result} is not equal to ${expected}`)
    }

The  job of a Javascript testing framework is to make that error message as useful as possible so we can quickly identify what the problem is and fix it.

To make this code less imperative, and more declarative, we can create an assertion library.

    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`${actual} is not equal to ${expected}`)
          }
        }
      }
    }

    const result = sum(3, 7);
    const expected = 10;
    expect(result).toBe(expected);

We can add other assertions to the library object. Eg:

    toEqual(expected) {}
    toBeGreaterThan(expected) {}
    
One problem with this approach is that as soon as one test fails, and throws an error, no other tests will be run. When finding the cause of a test failure, knowing the state of other tests can be useful. In fact even some clear logging around which test actually failed is important.    
    
    function test(title, callback) {
      try {
        callback()
        console.log(`✓ ${title}`)
      } catch (error) {
        console.error(`✕ ${title}`)
        console.error(error)
      }
    }
    
    test('sum adds numbers', () => {
      const result = sum(3, 7)
      const expected = 10
      expect(result).toBe(expected)
    })
    
A test library should quickly identify what is broken so that we can make a quick fix.

The next step is to handle async code. Even if we make our callback async the test function will complete and then later an unhandled promise rejection error will occur along with the failed test info.

    test('sumAsync adds numbers asynchronously', async () => {
      const result = await sumAsync(3, 7)
      const expected = 10
      expect(result).toBe(expected)
    })

    > (node:11815) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1) ... Error: -4 is not equal to 10 ...
    
The answer is to add an await to our test function. We need to wait for the callback to finish:

    async function test(title, callback) {
      try {
        await callback()
        console.log(`✓ ${title}`)
      } catch (error) {
        console.error(`✕ ${title}`)
        console.error(error)
      }
    }
    
 Many test libraries are set up as global variables. We can do that my moving our library into another file, setup-global.js. We add some exports at the bottom of this file and then we can run our tests:
 
    // bottom of setup-global.js
    global.test = test
    global.expect = expect
    
    > node --require ./setup-globals.js lessons/globals.js
 
 
 
Static Analysis Testing
--------------------------------------------

Static analysis involves no dynamic execution of the software under test and can detect possible defects in an early stage, before running the program. Static analysis can be done by a machine to automatically “walk through” the source code and detect noncomplying rules. Static analysis can also be performed by a person who would review the code to ensure proper coding standards and conventions are used to construct the program. This is often called Code Review.

Quality attributes that can be the focus of static analysis:
 - Reliability
 - Maintainability  (also inlcludes comments)
 - Testability  (are there tests?)
 - Re-usability
 - Portability
 - Efficiency
 
Once tool is eslint. You can set up rules in .eslintrc

    {
      "parserOptions": {
        "ecmaVersion": "2018"
      },
       "extends": [
        "eslint:recommended"    // automatically use the reccomended set of rules
      ],
      "rules": {
        "valid-typeof": "error" // will break the build. Can use "warn" instead. Or, can use "off" to disable the rule.
      }
    }

So you don't have to run $ npm eslint src all the time you can add eslint to your package.json:

    "scripts": {
        "lint": "eslint src"
    },
    
You can also just add an eslint extension to your code editor. Since you don't have to run anything you get a faster feedback loop.


Code formatting tools, like perttier are also available.Such tools limit arguments with others and tidy the code.

    $ npx prettier src/example.js  // just see the result
    $ npx prettier --write src/example.js  // write the result to the file, or:
    
    "scripts": {
        "lint": "eslint src",
        "format": "prettier --write \"**/*.+(js|jsx|json|yml|yaml|css|less|scss|ts|tsx|md|mdx|graphql|vue)\""
    },
    
There may also be some code editor support for prettier. If so you should enable format on save in the editor's settings. You can also change prettier's setting with a .prettierrc file. Go to https://prettier.io/playground/ to try out and generate some config options. A .prettierignore can be used to ignore some other file types like node modules.

If there are conflicts between prettier and eslint then try this module: npm install --save-dev eslint-config-prettier, cnad update extends in .eslintrc:

  "extends": [
    "eslint:recommended", "eslint-config-prettier"
  ],
  
 




    
 
 
    
  
