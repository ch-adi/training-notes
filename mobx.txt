The basic question MobX tries to answer is how we can keep the state consistent/synchonized with the UI. 

Two functions from Mobx demonstrate the solution. Let's say we have a counter with `count` as the state, which is displayer in the UI:

   export class Counter extends React.Component {
   
      count = 0;
      // ...
      <button>{this.count}</button> 
   
 Using the observable function tell MobX to track a value. Any component that uses that value is decorate with the observer function. Use @abserver tells MobX that this components rendering can be derived from the relevant observables. This separates the state and the component that reacts to that state.
 
Now we don't even need to have the state in the react component:
 
  
 const appState: IAppState = observable({
    count: 0
});


@observer
export class Counter extends React.Component {

   // @observable count = 0;  // if we did not want to pull out the state, as we have above

    render() {
        return (
            <div>
                <div data-testid="count">{appState.count}</div>
            </div>
        )
    }
}
 
 
MobX is built around four key concepts:
 - actions
 - observable state
 - computed values
 - reactions
 
And one very important principle is that we should use the smalled amount of state and derive all else from that state.
 
We decorate derivations with @computed. This tells MobX that such properties can be completely derived from observables. 
 
Computed values are not allowed to create side-effects, such as changing state (or even logging statements). They should be pure functions of observables or other computed values. This is because MobX must be left to determine the best time update htem, which then allows missions of computed values to live in memory and still only track a few of them. Computed values are suspended if not needed.
 
Here we see an example of our important principle. Because we only have one temperature type in state, and compute the rest, then we need less actions to update the state:
 
    @observable cTemp = 25;

    @computed get kTemp() {
        return this.cTemp + 273.15;
    }

    @computed get fTemp() {
        return this.cTemp * (9/5) + 32;
    }
 
The computations are only triggered when we inspect a computed value. By default MobX does not try and keep computed values up to date. It instead tries to defer calculations under they are need by IO or side effects. To make computed values react to the state we have to consume them in a Mobx reaction.
 
Reacts do not produce a value. Instead they produce a side effect. The side effect of an observer-decorated component is re-rendering of the DOM. 

   
   
   
   
   
   
//////////////////////////////////////////////////////   

class Thing {
   @observable
   state: number;

   @computed
   get multiplied() {
      return this.state * this.otherState;
   }

   @action
   doThing() {
       this.state = 0;
        
       await blah();
       
       this.otherState = 1;
   }

}

Any instance of a Thing will have a member/property called 'state'. If state changes there may be a redraw.
If there is an observable inside a method decorated with @computed, as there is here with multiplied(), then if multiplied() is called within a render method a redraw will occur. 
doThing() also causes a redraw. Everything inside is normally batched up so that the system does not get to complicated. However be careful when using an await. If you do use like above , eveything up to inlcuding the await is batched up but then every thing else is actioned independantly. This is caused by an internal function, runInAction(), only including up to the await. It looks like this:

   @action
   doThing() {
      runInAction(() => {
         // modify observable
         this.state = 0;
         
         await blah();
      });

      this.otherState = 1;
   }

