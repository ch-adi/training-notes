**********************************************************************************

                   JavaScript Training
					
**********************************************************************************	


Introduction
-----------------------------

JavaScript is one of the 3 languages all web developers must learn:

   1. HTML to define the content of web pages

   2. CSS to specify the layout of web pages

   3. JavaScript to program the behavior of web pages

JavaScript can change HTML attributes and content, change CSS styles, and validate input data.


Where to place JavaScript
-----------------------------

JavaScript can be placed in the <body> and the <head> sections of an HTML page. It is inserted between <script> and </script> tags. A JavaScript function is a block of JavaScript code, that can be executed when "asked" for. For example, a function can be executed when an event occurs, like when the user clicks a button.

Scripts can also be placed in external files using the file extension .js. External scripts are practical when the same code is used in many different web pages. To use an external script, put the name of the script file in the src (source) attribute of the <script> tag:

    <!DOCTYPE html>
    <html>
        <body>
            <script src="myScript.js"></script>
        </body>
    </html>

Such files make code easier to maintain, separate JS and HTML, and increase speed.

In fact, for debugging a js file in a browser all you need in an html file is:

    <html>
        <script src="fileName.js"></script>
    </html>

And then paste the file location of this html file in your browser. eg file:///C:/Users/chamilton/Desktop/fileName.html 



Output
----------------------------

JavaScript does NOT have any built-in print or display functions. However it is possible to:

1. create a pop up window with: window.alert(). In this simple example an '11' is displayed in pop up window:

    <!DOCTYPE html>
    <html>
        <body>
            <script>
                window.alert(5 + 6);
            </script>
        </body>
    </html>


2. We can insert text into a webpage with document.write(): <script> document.write(5 + 6); </script>

Using document.write() after an HTML document is fully loaded, will delete all existing HTML and replace it with the desired text:

    <body>
        <h1>My First Web Page</h1>
        <p>My first paragraph.</p>
        <button type="button" onclick="document.write(5 + 6)">Try it</button>
    </body>

The document.write() method should be used only for testing.


3. To access an HTML element, JavaScript can use the document.getElementById(id) method:

    <body>
        <p id="demo"></p>
        <script>
            document.getElementById("demo").innerHTML = 5 + 6;
        </script>
    </body>

4. In your browser, you can use the console.log() method to display data. Activate the browser console with F12, and select "Console" in the menu: 
<script> console.log(5 + 6); </script>  //just put console.log(5 + 6); in the console rather than running it from within a script.

5. When representing an object in the console or in the page it must first be placed into a string. There are several ways to do this.
    - JSON.stringify(myObject, undefined, "  ")  (see the JSON section)
    - console.log("here is my object: ", myObject );

In this second case you get a nice drop down in the console.




Debugging
------------------------------

In the dev tools go to Sources and select the JS file of interest. Click on any line you would like to stop at. Once you run the code (refresh will do) you will then pause at the line break. Note that not all of the line may be executed at once. The executed section is darker. "Step over" will let the current function run and complete. "Step Into" will go inside the working of the function.

You can also select debugging points by using the keyword 'debugger' in your source code.

Changes in memory are also available by going to Profiles and taking snapshots of the heap. Note that you can't do this when the debugger is working.


Syntax and Operators
------------------------------

A computer program is a list of "instructions" to be "executed" by the computer. In a programming language, these program instructions are called statements.
In JavaScript these statements are separated by semicolons. For example:

    <p id="demo"></p>
    <script>
        var x = 5;
        var y = 6;
        var z = x + y;
        document.getElementById("demo").innerHTML = z;
    </script>

JavaScript statements are composed of Values, Operators, Expressions, Keywords, and Comments. Variable values are called variables. An expression is any valid set of literals, variables, operators, and expressions that evaluates to a single value. (see EJS for more on binding and values). That is, an expression is a unit of code that results in a value. It does not have to be assigned to a varible (and if it's not it's lost). Statements do work but expressions create a value.

1. Literals: In Javascript both complex and primitve value types can be literals. All syntax constructs whose use leads to a defined type can be called a literal. "Literal" is a technical term that denotes, that "literally" writing something in this or that way leads to a certainly typed variable exclusively (in contrast to constructs, that look like something else, like array() in PHP).Numbers written with or without decimals. Strings are text, written within double or single quotes. EG:

    document.getElementById("demo").innerHTML = 10.50;

    let obj = {}; 

2.  In a programming language, variables are used to store data values. JavaScript uses the var let and const keywords to declare variables. An equal sign operator is used to assign values to variables. EG: <var x; x = 6;> or all at once: <var y = 'fred';> When a variable is declared but not yet assigned a value (eg waiting for user input or for the result of a calculation) then its value is 'undefined'. You can do normal algebra with variables but note that if you add a number to a string, the number will be treated as string, and concatenated. However, order is important. JS works left to right. EG var x = 16 + 4 + "Volvo"; evalutates as 20Volvo while var x = "Volvo" + 16 + 4; evaluates as Volvo164 - see more on Operator Precence and Associativity in the next section.

3. Operators: JavaScript uses an assignment operator ( = ) to assign values to variables and arithmetic operators ( + - *  / ) to compute values. Other operators include: % for modulus, ++ for increment, and -- for decrement. Combinations can also be used for variable assignment such as x += y in place of x = x + y (which can also be used for concatenation)and x %= y in place of x = x % y. The normal logical operators also exist, such as == for equal value. Of note is === for "equal value and equal type" and !== for "not equal value or not equal type". Also <= is a comparator while <== is not. 

    Operators are actually built in functions inside the JS engine. The language parser knows to convert instructions like 4 + 3 to something like add(4, 3). For example if you run b = c (set up b and c with values) in the dev tools console then the value of c will be returned to the console; just the way all functions are treated in the console.

    A binary operator like '+' uses 'infix' notation. The operator is placed between operands. '++3' is an example of prefix notation, and '3++' is an example of postfix notation.

    Operator Precedence: when two or more operators are in the same expression the operator function with the highest precedence is called first. Eg 3 + 4 * 5 will be 23. See the table on MDN. * has a rating of 14 while + has a precendence rating of 13. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

    Operator Associativity: the order in which operators are called when they have the same precendence. Eg 'Left Associativity' is moving accross from left to right. This is operator dependant. See this on the MDN "Operator Precedence" page too.

    For example, the assignment operator has right associativity: 

        var a = 2; b = 3; c = 4
        a = b = c  // logging any of these variables will produce a 4. The right '=' is called first

    
    A little more detail on === and equality: 
    
    There are four equality operators: ==, ===, !=, and !==. The ! forms are of course the symmetric "not equal" versions of their counterparts; non-equality should not be confused with inequality.
    
    The difference between == and === is usually characterized that == checks for value equality and === checks for both value and type equality. However, this is inaccurate. The proper way to characterize them is that == checks for value equality with coercion allowed (see the section below on coercion), and === checks for value equality without allowing coercion; === is often called "strict equality" for this reason.
    
        var a = "42";
        var b = 42;
        
        a == b;         // true
        a === b;        // false
    
    In the a == b 'equality' comparison, JS notices that the types do not match, so it first goes through an ordered series of steps to coerce one or both values to a different type until the types match, where then a simple value equality can be checked. The a === b 'strict equality' produces false because coercion is not allowed. So the simple value comparison obviously fails. Use strict equality and inequality (!==) by default in your code.

    So using '==' can lead to hard to detect coercion related bugs:

        '3' == 3    // true
        null == 0   // false
        null < 1    // true
        "" == 0     // true
        "" == false // true

    There is a nice table at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness. It compares abstract or loose equality (==), strict or identity comparison (===) and Object.is (behaviour around zero).
    
    You should take special note of the == and === comparison rules if you're comparing two non-primitive values, like objects (including function and array). Because those values are actually held by reference, both == and === comparisons will simply check whether the references match, not anything about the underlying values.
    
    For example, arrays are by default coerced to strings by simply joining all the values with commas (,) in between. You might think that two arrays with the same contents would be == equal, but they're not:
    
        var a = [1,2,3];
        var b = [1,2,3];
        var c = "1,2,3";

        a == c;     // true
        b == c;     // true
        a == b;     // false
    
    
    Inequality Operators:
    
    The <, >, <=, and >= operators are used for inequality, referred to in the specification as "relational comparison." Typically they will be used with ordinally comparable values like numbers. It's easy to understand that 3 < 4.

    But JavaScript string values can also be compared for inequality, using typical alphabetic rules ("bar" < "foo").

    What about coercion? (there is full coercion section below) Similar rules as == comparison (though not exactly identical!) apply to the inequality operators. Notably, there are no "strict inequality" operators that would disallow coercion the same way === "strict equality" does.
        
        var a = 41;
        var b = "42";
        var c = "43";
        
        a < b;      // true
        b < c;      // true
        
    If both values in the < comparison are strings, as it is with b < c, the comparison is made lexicographically (aka alphabetically like a dictionary). But if one or both is not a string, as it is with a < b, then both values are coerced to be numbers, and a typical numeric comparison occurs.
    
    The biggest problem is when one value cannot be made into a valid number:
    
    var a = 42;
    var b = "foo";
    
    a < b;      // false
    a > b;      // false
    a == b;     // false
    
    Wait, how can all three of those comparisons be false? Because the b value is being coerced to the "invalid number value" NaN in the < and > comparisons, and the specification says that NaN is neither greater-than nor less-than any other value (see more on NaN below).
    
    Operator prescedence and assoicativity help to explain this unusual result:    

    cons0le.log(3 < 2 < 1)  // true

    First, the less than operator has left-right associativity. So 3 < 2 is first evaluated as false. so now we have "false < 1". Since both types are not strings, false is coerced into a number: 0. And 0 < 1 is true. 
       
    So while something like console.log(0 < 2 < 3) will produce a true, in reality it is not doing what we would normally expect either. It is really doing 1 < 3. 

     


    The modular operator (%) returns the division remainder.
    
    
    Other operators: 
    
    Operator 	Description		 	Example
    
    .			Member			 	person.name
    []			Member			 	person["name"]
    () 			Function call 	 	myFunction()
    ! 			Logical not 	 	!(x==y)  //change the value of a boolean variable
    ** 			Exponentiation 	 	10 ** 2
    ++ 			Postfix Increment 	i++
    ++ 			Prefix Increment 	++i
    && 			And 				x && y  //where x and y are boolean
    || 			Or 					x || y  //where x and y are boolean



4. An expression is a combination of values, variables, and operators, which computes to a value. The computation is called an evaluation. For example, 5 * 10 evaluates to 50: document.getElementById("demo").innerHTML = 5 * 10; [ie a statement that includes an expression]

5. Keywords are used to identify actions to be performed. An example is the new variable keyword 'var' as used above. Keywords are reserved and so cannot be used as names for variables. Examples include do...while, for, break, return and much more. 

5A. Since ECMA6 'var' is usually replaced with 'const' or 'let'. Variables declared with var are scoped to a function , not to a block. By comparison let variables are only scoped to their block (ie between {...}). Variables created without the keyword var, are always global, even if they are created inside a function. See the scope section.

Second, var declared variables can de re-declared. let will throw an exception when a variable is re-declared in the same scope. So let helps avoid naming collisions. 

const tells us that we do not plan to change the value while let does. let would be used in something like a for loop. It has a different scope in comparison to var. Here is an example about importing a function from Redux called createStore to help render a GUI as a const object:

        const { creatStore } = Redux;
        //similar to:
        //var createStore = Redux.createStore;
        //and:
        // import { createStore } from Redux;

const is not truely about immutablity. ES6 const does not indicate that a value is ‘constant’ or immutable. A const value can definitely change. The only thing that’s immutable here is the binding. const assigns a value ({}) to a variable name (foo), and guarantees that no rebinding will happen (use object.freeze() to obtain actual immutability): 
(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)

    const NAME = 'Bob Marley';
    
    // Attempting to re-assign a const raises an exception
    NAME = 'Rick Astley'; // throws TypeError: Assignment to constant variable.

    const FULL_NAME = {
      first: 'Bob',
      last: 'Marley'
    };
    
    // Re-assigning any value, including an object [reference] raises an exception
    FULL_NAME = {
      first: 'Rick',
      last: 'Astley'
    }; // throws TypeError: Assignment to constant variable. [a new object literal so trying to change the reference]
    
    // Modifiying properties on an object is just fine though [no reference change]
    FULL_NAME.first = 'Rick';
    FULL_NAME.first; // => 'Rick';


const with curly braces can be very concise when it comes to object destructuring:

//this example of destructuring ...
const { name, version, type } = app;


// this new feature compiles into this older JS:
const name = app.name;
const version = app.version;
const type = app.type;


(also note that array destructuring is possible:


    var foo = ["one", "two", "three"];

    // without destructuring
    var one   = foo[0];
    var two   = foo[1];
    var three = foo[2];

    // with destructuring
    var [one, two, three] = foo;

)


6. Comments are not executed. Code after double slashes // or between /* and */ is treated as a comment.

7. Identifiers, case sensitivity and variable names

Identifiers are names. In JavaScript, identifiers are used to name variables (and keywords, and functions, and labels). An identifier must start with a-z, A-Z, $, or _. It can then contain any of those characters plus the numerals 0-9.

All JavaScript identifiers are case sensitive. For example VAR or Var is not interpreted as the keyword var.

Historically, programmers have used three ways of joining multiple words into one variable name:

	Hyphens: first-name, last-name, master-card, inter-city.

	Underscore: first_name, last_name, master_card, inter_city.

	Camel Case: FirstName, LastName, MasterCard, InterCity.

Hyphens are not allowed in JavaScript. It is reserved for subtractions. In programming languages, especially in JavaScript, camel case often starts with a lowercase letter: firstName, lastName, masterCard, interCity.

JavaScript uses the Unicode character set.

To make long statements more readable use the backslash (and use /*jshint multistr:true */ at the top of the file):

var text = "Hey, how are you \
doing? My name is Emily.";





More Detail on Operators


JavaScript supports the following types of operators:

Arithmetic Operators ( +(addition works on strings or numbers) - * / %(modulus) ++(increment) --(decrement) )

Comparision Operators (==, !=, >, <, >=, <=, === (equal value and equal type), !== (not equal to value or not equal type))

    egs with strings:
    
    2 < "12"        //true
    2 < "John"      //false
    2 > "John"      //false
    "2" < "12"      //false
    "2" > "12"      //true!!!!!!!!!!!!!!  [see above on the coercion used to make this happen]
    

Logical (or Relational) Operators (&&, ||, !)

Bitwise Operators (&, |, ^(XOR), ~(not), <<(left shift), >>(Right Shift), >>>(right shift with zero) )

Assignment Operators (= (assign LHS operand to RHS operand), +=, -=, *=, /=, %=)

Unary operator, eg the typeof operator. See further below.

Conditional (or ternary) Operators: the conditional operator: another form of conditional in JavaScript is the "conditional operator," often called the "ternary operator." Generally, it looks like: ((Boolean)?X:Y (If Boolean is true then value X: Otherwise Y)  )

It's like a more concise form of a single if..else statement, such as:

    var a = 42;
    
    var b = (a > 41) ? "hello" : "world";
    
    // similar to:
    
    // if (a > 41) {
    //    b = "hello";
    // }
    // else {
    //    b = "world";
    // }



comma operator

The comma operator evaluates both expressions and returns the result of the second one. Examples:
    > "a", "b"
    'b'

    > var x = ("a", "b");
    > x
    'b'

    > console.log(("a", "b"));
    b



typeof Operator: 

The typeof operator is a unary operator that is placed before its single operand, which can be of any type. Its value is a string indicating the data type of the operand.

The typeof operator evaluates to "number", "string", or "boolean" if its operand is a number, string, or boolean value and returns true or false based on the evaluation.


    Type	    String Returned by typeof
    
    Number	    "number"
    String	    "string"
    Boolean	    "boolean"
    Object	    "object"
    Function	"function"
    Undefined	"undefined"
    Null	    "object"
    Array       "object"  [not useful. Array.isArray(myArray) introduced in es5]
    NaN         "number"

'typeof a' is not asking for the "type of a", but rather for the "type of the value currently in a." Only values have types in JavaScript; variables are just simple containers for those values. Remember that JavaScript has typed values, not typed variables.

typeof null is an interesting case, because it errantly returns "object", when you'd expect it to return "null". This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug and thus fixing it would cause a lot more bugs!

Another bug is typeof for an array returning an object. As noted above you can use Array.isArray(). Another workaround is:

    Object.prototype.toString.call([1, 2, 3]);  // [Object Array]

Also, note what is happening if var a = undefined. We're explicitly setting 'a' to the undefined value, but that is behaviorally no different from a variable that has no value set yet, like with the var a; . A variable can get to this "undefined" value state in several different ways, including functions that return no values and usage of the void operator.




Null and Undefined:

In JavaScript, undefined means a variable has been declared but has not yet been assigned a value, such as:

 var TestVar;
 alert(TestVar); //shows undefined
 alert(typeof TestVar); //shows undefined
 typeof testVar;  //"undefined"

 
Null is an assignment value, but represents an absense of value. That is, it can be assigned to a variable as a representation of no value.

So what is the difference between null and undefined? The general consensus seems to be that undefined means 'there is no such property' while null means 'the property does exist, but holds no value'. Also if null is used in arithmatic it is treated as zero while undefined is treated as NaN. However they both evaluate to false in boolean contexts. Also, both are primitive values - which means neither undefined nor null can be returned from a constructor function, as both will be converted to an empty object (one has to throw an error to proclaim failure in constructors).

One good use for undefined is as a signal for when another language might throw an exception, such as trying to access a non-existant property. You can explicitely set a variable to be undefined, but this is not advised. I recommend only setting variables to null and leave undefined the value for things you forgot to set.



Statements
------------------------------

The JSEngine uses a syntax parser to go through your code, one character at a time, and it attempts to understand what you want to do. The parser has certain expectations about how the code should be written. 

One warning relates to carriage returns at the end of a line. The syntax parser sees these invisible characters. The parser will inject a semi-colon for you (to indicate the end of a statement). This is why semi-colons appear optional when you are typing. In reality, they are not optional. So always put in your own semi-colons. Also, return statements cause a particular problem:

    function getPerson() {
        return
            {
            firstName: 'Tony'
            }
    }
    console.log(getPerson());  \\undefined

Here the parser has changed 'return' to 'return;', which means that the remainder of the function is ignored. Instead use something like:

        return {
            firstName: 'Tony'
        }

Or:

        return (
            {
            firstName: 'Tony'
            }
        )


If a JavaScript statement does not fit on one line (say more than 80 characters), the best place to break it, is after an operator:

    document.getElementById("demo").innerHTML =
    "Hello Dolly.";

Whitespace is invisible characters that create literal 'space' in your written code (carriage returns tabs, spaces). The JS engine allows you to act very liberally with whitespace. Whitespace is basically ignored. This can encourage you to write lots of comments, which is a great thing.

Statements end with a semi-colon, so you can also place multiple statements on one line. It is also possible to declare many variables in one statement use the var keyword only once: 

    var person = "John Doe", carName = "Volvo", price = 200; 

JavaScript statements can be grouped together in code blocks, inside curly brackets {...}. The purpose of a code block is to define statements to be executed together. One place you will find statements grouped together in blocks, are in JavaScript functions: 

function myFunction() {
    document.getElementById("demo").innerHTML = "Hello Dolly.";
    document.getElementById("myDIV").innerHTML = "How are you?";
}

Which in this case could be called from within a button:

    <p>
        <button type="button" onclick="myFunction()">Try it</button>
    </p>

This button would the simultaneously update the <div> and <p> elements.


Two important flow statements are break and continue. The break statement "jumps out" of a loop. The continue statement "jumps over" one iteration in the loop. Examples:

    for (i = 0; i < 10; i++) {
        if (i === 3) { break; }
        text += "The number is " + i + "<br>";
    }                                           //the for loop never prints out the i = 3 case or beyond.

    for (i = 0; i < 10; i++) {
        if (i === 3) { continue; }
        text += "The number is " + i + "<br>";
    }                                           //the loop misses the i=3 case and then continues normally.


To label JavaScript statements you precede the statements with a label name and a colon. Eg:

    label:
    statements
    

The break and the continue statements are the only JavaScript statements that can "jump out of" a code block (A code block is a block of code between { and }.). The syntax looks like:

break labelname; 

continue labelname;

The continue statement (with or without a label reference) can only be used to skip one loop iteration. The break statement, without a label reference, can only be used to jump out of a loop or a switch. 

With a label reference, the break statement can be used to jump out of any code block:


var cars = ["BMW", "Volvo", "Saab", "Ford"];
list: {
    text += cars[0] + "<br>"; 
    text += cars[1] + "<br>"; 
    text += cars[2] + "<br>"; 
    break list;
    text += cars[3] + "<br>"; 
    text += cars[4] + "<br>"; 
    text += cars[5] + "<br>"; 
}

//BMW
//Volvo
//Saab


If you omit break from a case, and that case matches or runs, execution will continue with the next case's statements regardless of that case matching. This so called "fall through" is sometimes useful/desired:

    switch (a) {
        case 2:
        case 10:
            // some cool stuff
            break;
        case 42:
            // other stuff
            break;
        default:
            // fallback
    }

Here, if a is either 2 or 10, it will execute the "some cool stuff" code statements, but not the "other stuff".

Nested for-loops can usefully apply labeled statements. Given an array of items and an array of tests, this example counts the number of items that passes all the tests.

    var itemsPassed = 0;
    var i, j;

    top:
    for (i = 0; i < items.length; i++) {
        for (j = 0; j < tests.length; j++) {
            if (!tests[j].pass(items[i])) {
            continue top;
            }
        }
        itemsPassed++;
    }





Inputs
------------------------------

propmt()    - prompt the user for information  

confirm()  - boolean confirmation dialog box eg var playerReady = confirm( "Are you ready to play!");

alert()  - information pop up




Data Types
------------------------------

JavaScript has typed values, not typed variables.

JavaScript variables can hold many data types such as numbers, strings, arrays(see below), objects (ie an object is a data structure - see below), Boolean, Symbol, Function (an object subtype), Array, Null, and Undefined.

There are 6 primitive (single value) types.
- undefined: a lack of existence (so that you know if have forgotten something don't set variables to this value). 
- null: also represents lack of existence - but do set variables to this if you need to
- boolean: true or false
- number: a floating number. There is only one number type. More below.
- string: a sequence of characters in single or double quotes. In other languages strings are non-primtive
- symbol.

JavaScript has 'dynamic typing'. This means that the same variable can be used for different types. That is, variables can hold different types of values because it is all figured out during execution. At various times while code is running one variable can change the type of value it contains:

//this is all part of the same procedural code; the same variable is being used for different types. 
    var x;               // Now x is undefined
    var x = 5;           // Now x is a Number
    var x = "John";      // Now x is a String 

This is both powerful and dangerous. In other languages 'static typing' is employed. You have to tell the compiler ahead of time what type of value a variable will hold: eg bool isNew = 'hello' will generate an error.

('let' will not let you redeclare. Also var 'declarations', wherever they occur, are processed before any code is executed. This is called hoisting. The scope of a variable declared with var is its current execution context, which is either the enclosing function or, for variables declared outside any function, global. If you re-declare with var, it will not lose its value. Declared variables are constrained in the execution context in which they are declared. Undeclared variables are always global.)

JavaScript has only one type of number.

Numbers can be written with, or without decimals. Extra large or extra small numbers can be written with scientific (exponential) notation:

var y = 123e5;      // 12300000
var z = 123e-5;     // 0.00123

[There are many interesting numbers such as NaN (see below), Infinity, Number.Epsilon, Number.MAX_SAFE_INTEGER, and Number.MIN_VALUE. The later are about not losing information or the significance of numbers. Eg if some number is less than Number.Epsilon then it could indistunguisable from floating point error.

Infinity works much like we could expect. Eg -Infinity < Infinity evaluates to true while -Infinity+Infinity evalutate to NaN.] 

Booleans can only have two values: true or false, and are often used with conditional testing (see later). Eg: var x = true;. A boolean results from a 'comparison' between any data types.

You can use the JavaScript typeof operator (see above in the operator section) to find the type of a JavaScript variable: typeof 3.14         // Returns number. Can also use brakets like a function call:  typeof(3.14); 


NaN, Null, and Undefined

In JavaScript, a variable without a value, has the value undefined. The typeof is also undefined. Any variable can be emptied, by setting the value to undefined. The type will also be undefined:

person = undefined;          // Value is undefined, type is undefined

An empty value has nothing to do with undefined. An empty string variable has both a value and a type:

var car = "";                // The value is "", the typeof is string

In JavaScript null is "nothing". It is supposed to be something that doesn't exist. Unfortunately, in JavaScript, the data type of null is an object. You can consider it a bug in JavaScript that typeof null is an object. It should be null. You can empty an object by setting it to null:

var person = null;           // Value is null, but type is still an object

You can also empty an object by setting it to undefined:

var person = undefined;     // Value is undefined, type is undefined

Differences between null and undefined:

typeof undefined             // undefined
typeof null                  // object
null === undefined           // false (not of equal value and equal type)
null == undefined            // true


Not a Number (NaN)

NaN is a "number" type:

> typeof NaN
< "number"


Be careful with comparison involving NaN. While a NaN is a number, it is not any particular number:

> var myNum = NaN
> myNum > 0
< false
> myNum < 0
< false
> myNum == 0
< false
> NaN * 0
> NaN                   //[crazy, no matter what it might have been we cant multiple it by zero and get rid of it]


This also means that we can't even test for NaN in the usual manner 


> NaN == NaN
< false


So, instead we use the function isNaN(): 

    myNum = NaN;
    
    if(isNaN(myNum)){
        console.log("MyNum is a NaN");
    }
    
    //MyNum is a NaN



However it is a little wider than perhaps expected. Eg.s:

isNaN('berry'); // => true
isNaN(NaN); // => true
isNaN('true'); // => true
isNaN('false'); // => true
isNaN(undefined); // => true
isNaN(42);  // => false

Be careful with strings that look like numbers. isNaN() will covert them to a number and return false. For example '42' will return false. When the argument to the isNaN function is not of type Number, the value is first coerced to a Number. The resulting value is then tested to determine whether it is NaN.

A better way to test for only NaNs is to use the idea that NaN is never equal to NaN, even the same NaN:

    if(x !== x) {                             //[no coercion allowed here]
        console.info('Is a NaN');
    }
    else {
        console.info('Not a NaN');
    }



Example of error checking where isNaN() works well (ie, we want to filter anything that is not an actual number, and not just NaNs):

    age = Number(age);
    if (isNaN(age)) {
        voteable = "Error in input";
    } else {
        voteable = (age < 18) ? "Too young" : "Old enough";
    }





Converting Between Types and Coercion 
--------------------------------------------


Coercion is converting a value from one type to another. This happens often in JS because it's a dynamically typed language.

For example, what if I pass an operator function two different types?

    var a = 1 + '2';
    console.log(typeof a, a);  // string 12

Here the JS Engine forced the number 1 to change into a string type value, i.e. the value was coerced. Other languages would have just produced an error. Since JS is dynamically typed the engine tries to guess what you wanted to do. 

Understanding that coercion is happening can help you track down bugs.

Type coercion can be explicit and implicit. When a developer expresses the intention to convert between types by writing the appropriate code, like Number(value), it’s called explicit type coercion (or type casting). The above, automatic example was implicit type coercion. One operator that does not trigger implicit coercion is '==='. See the equality section above, as well as further down in this section.

The first rule to know is there are only three types of conversion in JavaScript:
- to string
- to boolean
- to number

Secondly, conversion logic for primitives and objects works differently, but both primitives and objects can only be converted in those three ways.

To explicitly convert values to a string apply the String() function.  Implicit coercion is triggered by the binary + operator, when any operand is a string (Symbol conversion is a bit tricky, because it can only be converted explicitly, but not implicitly).

To explicitly convert a value to a boolean apply the Boolean() function. Implicit conversion happens in logical context, or is triggered by logical operators ( || && !). Note: Logical operators such as || and && do boolean conversions internally, but actually return the value of original operands, even if they are not boolean.

As soon as there are only 2 possible results of boolean conversion: true or false, it’s just easier to remember the list of falsy values.

    Boolean('')           // false
    Boolean(0)            // false     
    Boolean(-0)           // false
    Boolean(NaN)          // false
    Boolean(null)         // false
    Boolean(undefined)    // false
    Boolean(false)        // false

Empty objects are truthy:

    Boolean({})             // true
    Boolean([])             // true
    Boolean(Symbol())       // true
    !!Symbol()              // true
    Boolean(function() {})  // true


For an explicit conversion to number type just apply the Number() function (not recomended however). 

Implicit conversion is tricky, because it’s triggered in more cases:

- comparison operators (>, <, <=, >=)
- bitwise operators ( | & ^ ~)
- arithmetic operators (- + * / % ). Note, that binary+ does not trigger numeric conversion, when any operand is a string.
- unary + operator
- loose equality operator == (incl. !=). Note that == does not trigger numeric conversion when both operands are strings.

    Number('123')   // explicit
    +'123'          // implicit
    123 != '456'    // implicit
    4 > '5'         // implicit
    5/null          // implicit
    true | 0        // implicit


When converting a string to a number, the engine first trims leading and trailing whitespace, \n, \t characters, returning NaN if the trimmed string does not represent a valid number. If string is empty, it returns 0.

null and undefined are handled differently: null becomes 0, whereas undefined becomes NaN.

    Number(null)                   // 0
    Number(undefined)              // NaN
    Number(true)                   // 1
    Number(false)                  // 0
    Number(" 12 ")                 // 12
    Number("-12.34")               // -12.34
    Number("\n")                   // 0
    Number(" 12s ")                // NaN
    Number(123)                    // 123

Symbols cannot be converted to a number neither explicitly nor implicitly. Moreover, TypeError is thrown, instead of silently converting to NaN.

    Number(Symbol('my symbol'))    // TypeError is thrown
    +Symbol('123')                 // TypeError is thrown

Take special note of the == and === comparison rules if you're comparing two non-primitive values, like objects (including function and array). Because those values are actually held by reference, both == and === comparisons will simply check whether the references match, not anything about the underlying values. For example, Arrays are by default coerced to strings by simply joining all the values with commas (,) in between. You might think that two arrays with the same contents would be == equal, but they're not:

    var a = [1,2,3];
    var b = [1,2,3];
    var c = "1,2,3";

    a == c;     // true [a coerced into a string]
    b == c;     // true [b coerced into a string]
    a == b;     // false [a and b are different objects, so have different references]

When applying == to null or undefined, numeric conversion does not happen. null equals only to null or undefined, and does not equal to anything else.

    null == 0               // false, null is not converted to 0
    null == null            // true
    undefined == undefined  // true
    null == undefined       // true

NaN does not equal to anything even itself:

    if (value !== value) { console.log("we're dealing with NaN here") }

The inequality (comparison) operators <, >, <=, and >= also follow similar coercion rules as ==, although there is no disallow conversion case like there is for ===. 

Inequality coercion is particularly relevant in relation to strings, which are compared with typical alphabetic rules. See the inequality sub-section within Syntax and Operators.

With complex values the JS Engine needs to first convert the object to a primitive value (with the interal [[ToPrimitive]] method), which is then converted to its final type. And still there are only three types of conversion: numeric, string and boolean. toPrimitive first looks to convert to a string with toString. It then looks to a numeric value with valueOf().

The simplest case is boolean conversion: any non-primitive value is always coerced to true, no matter if an object or an array is empty or not.

You can override the default toString() and valueOf() methods to hook into object-to-primitive conversion logic:

    var obj = {
      prop: 101,
      toString(){
        return 'Prop: ' + this.prop;
      },
      valueOf() {
        return this.prop;
      }
    };

    console.log(String(obj));  // 'Prop: 101'
    console.log(obj + '')      // '101'
    console.log(+obj);         //  101
    console.log(obj > 100);    //  true


Arrays
-------------------------------

Arrays are objects (see below for objects) and are defined with square brackets. They store lists of data, separated by commas. In fact, they are 'a collection of anything'. Unlike other languages JS arrays can hold mixed types. Such arrays are called heterogeneous arrays.  

Arrays items are ordered with indicies. These indexes are zero-based, which means the first item is [0], second is [1], and so on: var cars = ["Saab", "Volvo", "BMW"]; Nested arrays (arrays within arrays) are also possible. The more nested levels then the higher the dimension. We can also have jagged arrays, where rows are of unequal length [in this way arrays are a good title for this data structure since we have a generalisation of matricies. A list is really just a 1-D matrix, or a vector.]. You can start with an empty array and then add as many elements as you like with a foor loop:

    var numArray = []; //another way to construct an array (recall it is an object) would be var numArray = new Array();
    
    var length = 100;
    
    for (i=0; i<length; i++) {
    	numArray[i] = Math.random(); //generates a list of random numbers, each number being between 0-1. The list is of length 100.
    }

A useful array method is .push(); which adds an item within the parentheses onto the end of the array. Also, like strings, arrays have the length method.

In JavaScript, an array is a special type of object. Therefore typeof [1,2,3,4] returns object.  




Functions
---------------------------------

Just like functions in many languages, a JavaScript function is a block of code designed to perform a particular task. It executes when "something" invokes it (calls it). They are the fundamental modular unit because they are used for code re-use, composition, information hiding, and specifying the behaviour of objects.

In JavaScript, however, functions are first-class objects (collections of name:value pairs having a hidden link to a prototype object). Anything you can do with othe types, including objects (String, Array, Number, etc.) you can do with a function. Functions can be assigned to variables, passed as arguments to other functions (this is the essence of using callback functions), executed within in other functions, created within functions, returned from other functions, and created on the fly (i.e. type it out in full as an argument). This gives JS something that other modern languages do not often have.

Another interesting feature is that, just like an object, you can attached properties and methods to a function. You can even attach other functions. Here we attach a property:

    function greet() {
        console.log('hi');
    }

    greet.language = 'english';  // attaching a property
    console.log(greet);     // log outs the function code
    console.log(greet.language);  // english
    console.log(greet.name)  // greet (see below - 'name' is special property)


What make functions such a special type of object is that also have some hidden additional properties. One is 'Name', which is optional and can remain anonymous, and the other is the 'Code' property. This is where the actual code sits. So the function is an object with properties. The code is just one property. Although what is special about this property is that it is invocable. So function contain executable code, which is invoked with ().

Functions are also the primary mechanism of scope (see the scope section).



Function Expressions and Function Statements (declarations):


JavaScript functions are defined with the function keyword. You can use a function declaration, a function expression, or a constructor.

Recall that expressions return a value and statements do work. For example 'if' is a statement. It gets some looping done. A function declation is also a statement:

    function functionName(parameters) {
      //code to be executed
    }


Declared functions are not executed immediately. They are "saved for later use", and will be executed later, when they are invoked (called upon). They are also hoisted; put into memory a head of time and thus available to be invoked before it is declared.

(Semicolons are used to separate executable JavaScript statements. Since a function declaration is not an executable statement, it is not common to end it with a semicolon.)


A JavaScript function can also be defined using an expression. A value of type function can then be stored in a variable (aka a binding; the binding refers to a memory address where the function object is stored). That is, the function is treated like a value. Not only can you pass a value (argument) to a function, but a function itself can be a value that's assigned to variables, or passed to or returned from other functions:

    var x = function (a, b) {return a * b};
    var z = x(4, 3);

Functions stored in variables do not need function names. They can thus be "anonymous" functions. They are always invoked (called) using the variable name.

To call either an expression function or a declared function you need to follow the name with brackets, eg x(), otherwise the console will just reproduce the definition. Note that function expressions are not hoisted (you can't swap the two lines in the above code).

In this example a function is declared that takes a function-expression as a parameter, and this related expression is typed 'on the fly':

    function log(someFunction) {
        someFunction();
    }

    log(function () {
        console.log('hi');
    })



Passing By Value and By Reference

Both primitive and complex variables actually store a memory reference. However when you assign a variable holding a primitive value a copy of the value in question is created at a new memory address and that reference is stored in the new variable.

    // this is the same as passing to a function
    var a = 1;  // variable a references something like 0x001, which holds '1' in coded binary form
    var b = a;  // variable b references something like 0x002, which also holds a '1'; value copied

'By value': a copy of a primivite value is placed into another memory location. If you make changes to 'a' it will not affect the value bound to 'b'.

When an complex type is assigned to a variable the variable again hold a memory location for that object. However when we assign one variable to another variable, or pass a complex variable into a function, thenew variable gets the same location in memory. No new copy of the object is created at another memory location.

    var a = {key: 'value'}; // variable a references something like 0x001, which holds the object 
    var b = a;  // variable b hold the same memory address, 0x001; it refers to the same object.

'By reference': all object interact via memory reference. "Mutations" (ie changes) to the value of the object type bound to 'a' will change the object-value bound to/referenced by variable 'b'.

(note: something is 'immutable' if it cannot be changed)

The assignment operator tends to set up new memory space (a new address) when it sees that it is not being asked to assign an existing object. That is, the operator looks to see if something is already asigned a place in memory. So, creating a new object literal with the same properties does not create a new copy.

    var a = {key: 'value'};
    var b = {key: 'value'}; // changing this object will not affect the object refered to by 'a'.





So far we have shown two ways to define a function (declaration and expression). Both use the 'function' keyword. However, we can also use the built in Function() constructor:

var myFunction = new Function("a", "b", "return a * b");

var x = myFunction(4, 3);

But this is really the same as using:

var myFunction = function (a, b) {return a * b};


Immiediately Invoked Function Expression

None of the previous approaches result in automatic execution of the function. We will need to include something like foo(x). Another to execute a function expression is an 'immiediately invoked function expression' or IIFE or "Iffy":


(function IIFE(){
    console.log( "Hello!" );
})();
// "Hello!"


The outer ( .. ) that surrounds the (function IIFE(){ .. }) function expression is just a nuance of JS grammar needed to prevent it from being treated as a normal function declaration. The final () on the end of the expression -- the })(); line -- is what actually executes the function expression referenced immediately before it.

One advantage if IIFE is that internal variables will not affect the surrounding code, such as with a naming conflict:

    var a = 42;
    
    (function IIFE(){
        var a = 10;
        console.log( a );   // 10
    })();
    
    console.log( a );       // 42

Using a function expression, IIFEs can also have return values:

    var x = (function IIFE(){
        return 42;
    })();
    
    x;  // 42

That is, we create a function object, and the next part of code to be executed is (), that then invokes the function.

The round brackets are very helpful. They trick the syntax parser. Normally, when the parser reads the 'function' keyword as the first word in a statement, then it expects a normal function statement (ie declaration), not an evaluation. Round parentheses relates to expression evaluation: 

    (function(){ return 42;}())  // Note that this IIFE is anonymous, and you can invoke inside ()

Arguments can also be passed into the IIFE function:

(function (a, b) {return a * b})(2,2);  // 4


IIFEs help create safe code. When the global execution context is beign created an IIFE just becomes an object with some code inside.It goes inside the variable environment for this context. The JS engine then sees the invoking (). It creates a new, annonymous execution context. The variables inside the IIFE then go inside the variable environment in this new execution context. Because the function was anonymous naming conflicts are avoided. For example, this is safe despite being in the same file:

    var greeting = 'hello';

    (function(name) {
        var greeting = 'Hola';
        console.log(greeting + ' ' + name); 
    }('John'))

    console.log(greeting);
    // 'Hola John'
    // 'hello'

Both greetings exist but in separate variable environemnts in separate execution contexts. If we had named the function greeting and called it then an error would result. This can become more of an issue when a webpage imports several scripts. Generally IIFEs are used in many libraies (with entire files being wrapped in '()') to prevent conflicts.

If you do want to interact with the global object you can just pass it into your function:

    (function(global, name) {
        global.greeting =  'Hello ' + name;
    }(window, 'John'))




Function Parameters/arguments:

Function parameters are the names listed in the function definition. Function arguments are the real values received by the function when it is invoked. Inside the function, the arguments behave as local variables.

JavaScript function definitions do not specify data types for parameters.

JavaScript functions do not perform type checking on the passed arguments.

JavaScript functions do not check the number of arguments received.

If a function is called with missing arguments (less than declared), the missing values are set to undefined.

Sometimes this is acceptable, but sometimes it is better to assign a default value to the parameter:

function myFunction(x, y) {
    if (y === undefined) {
          y = 0;
    } 
}

In ES6 you can define a default argument if the argument is 'undefined'. Here is part of a function that first checks that the argument is not undefined:


    function counter (state, action) {
    	if(typeof state === 'undefined') {
    		return 0;
    	}
    	
    	...now that it's not undefined do some stuff...
    }

Or we could use this tidier pattern:

    function counter (state, action) {
    // OR only ever evaluates (and coerces) the second operand if the first operand coerces false. 
    // It then returns the uncoerced version of which every operand it was up to. So this is
    // actually wider than above, since it catches anything that coerces to false. 
        state = state || 0  
        
        ...now that it's not undefined do some stuff...
    }

Replace it with:

    function counter (state = 0, action) {

    	...if state is undefined (not null nor NaN), make it zero, and then do some stuff...
    }

So here, either no argument, or the actual argument 'undefined', will result in the default value being used. However if the argument is null or NaN then coercion will be applied and the default is not used. Consider:

    function makeMoreExciting (string = "") {
      return string + '!!!!'
    }

    makeMoreExciting(null) // "null!!!!"
    makeMoreExciting(NaN) // "NaN!!!!"
    makeMoreExciting() // "!!!!"
    makeMoreExciting(undefined) // "!!!!"

However if the function declaration has no default argument then explictly stating 'undefined', or just leaving an empty argument, both produce different results:

    function makeMoreExciting (string) {
      return string + '!!!!'
    }

    makeMoreExciting(null) // "null!!!!"
    makeMoreExciting(NaN) // "NaN!!!!"
    makeMoreExciting() // "undefined!!!!"
    makeMoreExciting(undefined) // "undefined!!!!"


If a function is called with too many arguments (more than declared), these arguments can be reached using the arguments object (see further below). 


Return and Function Assignment

When JavaScript reaches a return statement, the function will stop executing. If the function was invoked from a statement, JavaScript will "return" to execute the code after the invoking statement. Functions often compute a return value. The return value is "returned" back to the "caller":

    var x = myFunction(4, 3);        // Function is called, return value will end up in x

    function myFunction(a, b) {
        return a * b;                // Function returns the product of a and b
    }

Accessing a function without (), will return the function definition.

In the next example we see that the function produces a new string from an exisiting string:

    function makeMoreExciting (string) {
      return string + '!!!!'
    }

The expression string + '!!!!' returns a new string and what ever variable we passed stays the same (since we never updated it to anything else with = ).

Now, if you took the return line out of this function then any variable assigned to its output would hold "undefined" eg:

    function makeMoreExciting(string) {};
    var sent = makeMoreExciting("String");
    console.log(sent); //undefined


One way to call a function is within the script tags:

    <p id="demo"></p>
    <script>
    function myFunction() {
        document.getElementById("demo").innerHTML = "Hello World!";
    }
    myFunction(); // call the function here
    </script>

or we can pull the standard getElementById out of the function:

    <script>
    function myFunction(name) {
        return "Hello " + name;
    }
    document.getElementById("demo").innerHTML = myFunction("John");
    </script>

One powerful JavaScript feature is assigning an entire function (ie. not just a function return value) to a function variable:


    var foodDemand = function(food){
        console.log("I want to eat " + food);
    }


    function foodDemand2(food) {
            console.log("I too want to eat " + food);
    }


    foodDemand = foodDemand2;

    foodDemand("hot dogs");   //we get the output from foodDemand2

    var mysteryFunction = foodDemand;
    mysteryFunction("dogs");     //again we get the output expected from foodDemand2


    if (mysteryFunction == foodDemand2) {
        console.log("They are the same");
    };                                       // returns "They are the same" [same reference then, so the same object, see next few lines]





Pure Functions:


Pure functions are affected soly by the values of their arguments.  Pure functions do not have any observable side affects like network or database calls [see more below somewhere, I think, for side effects]. Pure functions just calculate a new value. You can be confident that if whenever a pure function is called with the same set of arguments it will always return the same value. They are predictable.

Also, pure functions do not modify the values to passed to them.

    //pure functions

    function square(x) {
        return x * x;
    }

    function sqaureAll(items) {
        return items.map(square);    //unlike the sqaureAll() example below, .map() returns a new array so that it does not override the items array. 
    }


    // impure functions

    function square(x) {
        updateInDatabase(x);
        return x * x;
    }

    function squareAll(items) {
        for(let i = 0; i < items.length; i++) {
        items[i] = square(items[i])
        }
    }



Namespaces


A namespace is a container for variables and functions. It is typically used to keep variables and fuctions with the same name separate and avoid naming collisions. JS does not have namespaces but we can fake it with objects.

    var greet = 'hello'
    var greet = 'hola';

    console.log(greet); // hola 
    
    var english = {greet: 'hello'};
    var spanish = {greet: 'hola'};

    console.log(english.greet); // hello



Arguments Object


JavaScript functions have a built-in object called the arguments object. It is a special construct available inside all function calls. 

It represents the list of arguments that were passed in when invoking the function. The arguments object is an array-like object. It has a length property that corresponds to the number of arguments passed into the function. You can access these values by indexing into the array, e.g. arguments[0] is the first argument. 

One example is using a function to find the highest value in a list of numbers:


    x = findMax(1, 123, 500, 115, 44, 88); //allowing for an indeterminant number of arguments! 

    function findMax() {
        var i;
        var max = -Infinity;
        for (i = 0; i < arguments.length; i++) {
            if (arguments[i] > max) {
                max = arguments[i];
            }
        }
        return max;
    }


The only other standard property of arguments is callee. This always refers to the function currently being executed. 


    var myfunc = function(one) {
      console.log(arguments.callee === myfunc);         //true
      console.log(arguments[0] === one);                //true
      console.log(arguments[1] === 2);                  //true
      console.log(arguments.length === 3);              //true
    }

    myfunc(1, 2, 3);

This construct is very useful and gives javascript functions a lot of flexibility. But there is an important gotcha. The arguments object behaves like an array, but it is not an actual array. It does not have Array in it's prototype chain and it does not respond to any array methods, e.g. arguments.sort() raises a TypeError. Instead you need to copy the values into a true array first. An easy approach is a for-loop:

    var args = [];

    for(var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }


The traditional was in ECMA 5 is to use:

    var argsArray = Array.prototype.slice.apply(arguments)


In ECMA 6 it is easier with a special 'from' method:

    var argsArray = Array.from(arguments)






CallBack Functions (see also Closures)


Callback functions are derived from a programming paradigm known as functional programming. At a fundamental level, functional programming specifies the use of functions as arguments. A callback function, also known as a higher-order function, is a function that is passed to another function. 

In JavaScript, functions are first-class objects. That is, functions are of the type Object and they can be used in a first-class manner like any other object (String, Array, Number, etc.) since they are in fact objects themselves. They can be stored in variables, passed as arguments to functions, created within functions, and returned from functions.

Here is an example in which we pass a function as a parameter (note that the forEach() method calls a provided function on each element in an array, in order):

    var friends = ["Mike", "Stacy", "Andy", "Rick"];

    friends.forEach(function (eachName, index){                 
        console.log(index + 1 + ". " + eachName);                   // 1. Mike, 2. Stacy, 3. Andy, 4. Rick
    });

In this case we pass an anonymous function (a function without a name) to the forEach method as a parameter. (Functions stored in variables do not need function names. They are always invoked (called) using the variable name.)

In the next example the function fn is passed as a callback to the setTimeout function. Set timeout returns immediately however 5 seconds later the function passed as a callback is executed.

    function fn() { alert("Hello, World"); }
    window.setTimeout(fn, 5000);

We can pass functions around like variables and return them in functions and use them in other functions. When we pass a callback function as an argument to another function, we are only passing the function definition. We are not executing the function in the parameter. In other words, we aren’t passing the function with the trailing pair of executing parenthesis () like we do when we are executing a function.

And since the containing function has the callback function in its parameter as a function definition, it can execute the callback anytime. Even without a name, it can still be accessed later via the arguments object by the containing function.

When we pass a callback function as an argument to another function, the callback is executed at some point inside the containing function’s body just as if the callback were defined in the containing function. The callback function can access the containing functions’ variables, and even the variables from the global scope. This means the callback is a closure [see closures - function plus the variables locked in from the surrounding scope when the outer function was executed].

We can use named or anonymous functions as callbacks. Here is an example with a named function:

    // generic logStuff function that prints to console
    function logStuff(userData) {
        if ( typeof userData === "string")
        {
            console.log(userData);
        }
        else if ( typeof userData === "object")
        {
            for (var item in userData) {
                console.log(item + ": " + userData[item]);
            }
        }
    }
    
    // A function that takes two parameters, the last one a callback function
    function getInput(options, callback) {
        callback (options);
    }
    
When we call the getInput function, we pass logStuff as a parameter. So logStuff will be the function that will called back (or executed) inside the getInput function
    
    getInput ({name:"Rich", speciality:"JavaScript"}, logStuff);
    //  name: Rich
    //  speciality: JavaScript



Currying (Curry) Functions:

Something like this:

    var greet = function(greeting, name) {
      console.log(greeting + ", " + name);
    };
    greet("Hello", "Heidi"); // "Hello, Heidi"


Can be instead written like this:

    var greetCurried = function(greeting) {
      return function(name) {
        console.log(greeting + ", " + name);
      };
    };


One way to now call it:

    var greetHello = greetCurried("Hello");
    greetHello("Heidi"); //"Hello, Heidi"
    greetHello("Eddie"); //"Hello, Eddie"


But we can also just call it this way:

    greetCurried("Hi there")("Howard"); //"Hi there, Howard"


There can be multiple levels of nested functions, and thus more than two sets of parenthesis.

[so this is an anonymous way of doing closures.]




Self-Invoking Functions (see also IIFE above for more details):


Function expressions can be made "self-invoking", i.e. they are invoked (started) automatically, without being called.

Add parentheses around the function to indicate that it is a function expression:

    (function () {
        var x = "Hello!!";
        console.log(x)         //Console: Hello!!
    })();


`


'this' keyword  ( this keyword , "this" ):

In JavaScript, the thing called 'this', is the object that "owns" the current code. The value of this, when used in a function, is the object that "owns" the function.  Compare the next two functions. The second works on a property from some other object that has not been passed into the function:

    function talk(sound) {
        console.log(sound)
    }

    function talk() {
        console.log(this.sound)
    }

When code is executed it enters a [function based] 'execution context'. Part of the set up for this context is the assignment of a value to 'this'. If the value assigned refers to an object then property accessors prefixed with the 'this' keyword reference properties of that object. If the value assigned (internally) is null then the this keyword will refer to the global object.

So, the value of 'this' depends upon how a function is called. That is, how the execution context was generated.

{
    Aside on global and context:

    When JS code is executed an execution context is created. This is where your code sits inside a 'variable environment' along side other things that have been supplied by the engine. One such thing is a variable called 'this'. In the global execution context a global object is also supplied.

    In the global exececution context the global object is 'this'. In browsers this is the 'Window' object, and it is automatically supplied by the engine. In other environemnts, like node, it will be something else. The global object is accessible by all parts of the code. Also, each tab or window has it's own global execution context.

    Another way of thinking about global is code 'not inside a function'. Variables and functions that are not inside a function are automatically attached to the global object as a key value pair.

        var a = "hello world";
        console.log(window.a) // "hello world"   // window.a is the same thing as a

    If the code is not in a the global execution context then the engine supplies a link to the outer environment. In this way, a non-global execution context has several features: a 'this', a link to the outer environment, a variable environment and 'arguments'. 'Arguments' hold all those values you have passed to the function.

    A non-global execution content is created when a function is invoked/called. These execution contexts stack on top of each other, so that whichever is on top is the currently running context. Code is executed line by line and if another function invocation is reached, then a new context is generated and sits on the top of the stack. When all the code in the top context has been executed, then that context is popped off the stack.
}

In most cases, the value of 'this' is determined by how a function is invoked. It can't be set by assignment during execution ('this' is not a variable. It is a keyword), and it may be different each time the function is called. It also has some differences between strict mode and non-strict mode. ES5 introduced the bind method to set the value of a function's this regardless of how it's called, and ECMAScript 2015 introduced arrow functions (see below) whose 'this' is lexically scoped; it is set to the 'this' value of the lexically enclosing execution context.

JavaScript functions can be invoked in 4 different ways. Each method differs in how 'this' is initialized. The code in a function is not executed when the function is defined. It is executed when the function is invoked. Some people use the term "call a function" instead of "invoke a function". It is also quite common to say "call upon a function", "start a function", or "execute a function". Here, we will use invoke, because a JavaScript function can be invoked without being called (a bit of a non-distinction perhaps. But, when you call a function, you are directly telling it to run. When you invoke a function, you are letting something run it. eg myFunc() is an invocation and call, whereas myObj.myFunc() is only a call ????).

1. In the global execution context (outside of any function), 'this' refers to the global object, whether in strict mode or not:

    console.log(this.document === document); // true

    // In a web browser the global object is the browser window:
    console.log(this === window); // true

    this.a = 37;
    console.log(window.a); // 37


2. Inside a function, the value of this depends on how the function is invoked.   

When a function is not a method, the value of this is not changed. Since the code is not in strict mode, the value of this must always be an object so it defaults to the global object:

    function f1(){
        return this;
    }
    
    f1() === window; // true: global object

    (note: using the window object as a variable can easily crash your program).

    Also, there is no difference between function declarations and function expressions:

    function a() {
        console.log(this);
    }

    var b = function() {
        console.log(this);
    }

    a();  // Window
    b(); // Window

In these cases separate execution contexts are being created for a and b, but the value of 'this' in those contexts is being passed by reference. They are all pointing at the global object, which means you can mutate the global object inside one of these functions.

    function a() {
        this.newVariable = 'hello'; // a new property on the global object.
    }

Invoking a function as a method:

    var myObject = {
        firstName:"John",
        lastName: "Doe",
        fullName: function () {
            return this.firstName + " " + this.lastName;
        }
    }
    myObject.fullName();         // Will return "John Doe"

The fullName method is a function. myObject is the object that owns the function. The thing called this, is the object that "owns" the JavaScript code. That is, when you use 'dot' notation, the object on the LHS of the dot is 'this'. In this case the value of this is myObject. 

We could also change back to the global window by creating a new global variable that references the object method/function, and thus give up the dot notation:

    window.firstName = "comp";
    window.lastName = "gangsta";
    var globalFunc = myObject.fullName;
    globalFunc();     // "comp gangsta"

'this' is now being called in another execution context -  the global execution context. [i.e. we can type window.globalFunc(); which is what is implicitly happening here.] The usual situation in this case is that the global object will have no keys like lastName or fullname, and so you will get 'undefined'. This could be a source of bugs.

    let dog = {
        sound: 'woof',
        talk: function() {
            console.log(this.sound)
        }
    }

    dog.talk() //woof

    let talkFunction = dog.talk

    talkFunction()  //undefined

(aside: this state of affairs is due to the clash between functional programming aspect of Javascript and it object orientated past. Javascript was originally a mixture of Java (object orientated) and Scheme (?) (functional). Object orientated languages use concepts like 'this', but functional languages, in which a function can be assigned to a variable, do not. )

Here is a more complete example:

    function talk() {
        console.log(this.sound)
    }

    let boromir = {
        speak: talk,
        sound: 'One does not simply walk into mordor!'
    }

    boromir.speak()      // One does not simply walk into mordor!

We can even go a step further, and show that 'this' depends upon where we are at the time of execution:

    let blabber = boromir.speak
    blabber()                       //undefined

And here is another twist (were we just keep passing that talk function around as a variable):

    let gollum = {
        jabber: baromir.speak,
        sound: 'my precioussss...'
    }

    gollum.jabber()             // my precioussss...' 

The key point is that 'this' is determined by the context at the time of the call (object defore the dot) unless we have made a copy of the function with the bind() method.


Arrow function example:

    const a1 = {
        name: "my name is a", 
        log: function() { console.log(this) }
    };

    const a2 = {
        name: "my name is a", 
        log: () => { console.log(this) }
    };
     
    a1.log() // {name: "my name is a", log: ƒ}
     
    a2.log() // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}

Arrow functions 'don't have their own 'this'. Instead they retain the 'this' value of the enclosing lexical context. Arrow functions follow the normal variable lookup rules. So while searching for this which is not present in current scope they end up finding this from its enclosing scope. 

So, in this example the arrow function's execution context is created when it is called. However because we have an arrow funciton 'this' has not been assigned. So the scope chain, found by the surround lexical context, is followed. Here, because we are not inside a function, the surrounding lexical context, which is the next step in the scope chain, is the global context. As we know, another way of thinking about global is code 'not inside a function'. Variables and functions that are not inside a function are automatically attached to the global object.​ And in this case, the varibale of type object, a2, is not inside a function. It must be in the global context. That is, `a2.log()`, the arrow function, lexically sits inside the global execution context. 

(Arrow functions also do not have their own arguments object. Thus, arguments is simply a reference to the arguments of the enclosing scope).

Since non-arrow function's have their own 'this' binding you cannot refer to the this of the wrapping scope. Arrow functions allow us to do that. In the following code, 'this' is actually from a function that lexically wraps an arrow function:

    function normalize() {
      console.log(this.coords.map(num => num / this.length));
    }

    normalize.call({coords: [0, 2, 3], length: 5});
    // → [0, 0.4, 0.6]

There is one 'gotcha' or bug in JS that relates to functions inside object methods. 

    var myObj = {
        name: 'my object',
        log: function () {
            this.name = 'updated object name';  // changes the name property in this object

            var setName = function() {
                this.name = 'updated name again';  // will add a name property to global
            }
            setName(); 
        }
    }


This is a much safer and commonly used workaround using assignment by reference.

    var myObj = {
        name: 'my object',
        log: function () {
            var self = this;

            self.name = 'updated object name';  // changes the name property in this object

            var setName = function() {
                self.name = 'updated name again';  // will add a name property to global
            }
            setName(); 
        }
    }

Now we don't have to worry about what 'this' is inside our object. Another alternative is using 'let' instead of 'var'.



3. We can also over-ride 'this' with apply and bind (see more below on these methods):

    var myObject = {
        firstName:"John",
        lastName: "Doe",
        fullName: function () {
            return this.firstName + " " + this.lastName;
        }
    }

    window.firstName = "comp";
    window.lastName = "gangsta";
    myObject.fullName.apply(window); // "comp gangsta"

Now the global object in the browser is 'this'. takes presedence when setting 'this'.

With our dog object we can use bind() to reset talkFunction back to dog:

    let boundFunction = talkFunction.bind(dog)

    boundFunction() //woof


Note that bind() really means makeCopyBoundTo(). 


4. The fourth way to bind 'this' involves the new keyword. That is, invoking a function constructor. It may appear that you are creating a new function, but since JavaScript functions are objects you actually create a new object.


    // This is a function constructor:
    function myFunction(arg1, arg2) {
        this.firstName = arg1;
        this.lastName  = arg2;
    }
    
    // This	creates a new object
    var x = new myFunction("John","Doe");
    x.firstName;                             // Will return "John"

A constructor invocation creates a new object. The new object inherits the properties and methods from its constructor. So, the this keyword in the constructor does not have a value. The value of this will be the new object created when the function is invoked.
    
So, in summary, when some function contains a reference to 'this', four possibilities exist. The first is a default binding to the global object for a regular function call. The second is using apply() to set 'this' to a particular object. The third invloves using the dot notation; 'this' refers to whatever becomes before the dot. And fourth, the new keyword


More on explicit binding:

In JavaScript functions are objects and therefore have properties and methods. call() and apply() are predefined JavaScript function methods. Both methods can be used to invoke a function, and both methods must have the owner object as first parameter. So these functions change the value of 'this' when an execition context is made.

call() example:

    var myObject = {};                   // (if you only declare myObject, and don't assign {} to it, then 'this' will be the 
                                        //  window global object - see below)
    function myFunction(a, b) {
        console.log(this);                  //console shows the contents of myObject, not the MyFunction function-object.
        return a * b;
    }
    myObject = myFunction.call(myObject, 10, 2);     // Will return 20


apply() example:

    var myObject = {};
    function myFunction(a, b) {
        return a * b;
    }
    myArray = [10, 2];
    myObject = myFunction.apply(myObject, myArray);  // Will also return 20


Both methods take an owner object as the first argument. The only difference is that call() takes the function arguments separately, and apply() takes the function arguments in an array. With call() or apply() you can set the value of this, and invoke a function as a new method of an existing object.



bind():

The bind() method creates a ***new*** function that, when called, has its this keyword set to the provided value. (call() and apply() execute the original function).

The simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:

    this.x = 9;    // this refers to global "window" object here in the browser
    var module = {
      x: 81,
      getX: function() { return this.x; }
    };

    module.getX(); // 81

    var retrieveX = module.getX;
    retrieveX();   
    // returns 9 - The function gets invoked at the global scope

    // Create a new function with 'this' bound to module
    // New programmers might confuse the
    // global var x with module's property x
    var boundGetX = retrieveX.bind(module);
    boundGetX(); // 81


A common method is bind(). In this example we assign the talk method to the click handler of the button. When the click handler is being called 'this' will not be the dog. The add event listeners are triggered in the window object:

    let dog = {
        sound: 'woof',
        talk: function() {
            console.log(this.sound)
        }
    }

    let button = document.getElementById('myNiceButton')

    button.addEventListener(
        'click',
        dog.talk  // correct this by using dog.talk.bind(dog)
    )

The call and apply methods can also be used with an IIFE. 

    (function(){ //...}).call(myobj);. 
    
    
They are also used in function 'borrowing', in which a method from one object is applied to another object that lacks the method. The borrower can then apply it's own properties as arguments in the function.

    lendingObject.borrowedMethod.apply(borrowingObject)  // you can grab methods from other objects.

The bind method applies to 'function currying', which is "creating a copy of a function but with some preset parameters". This is often used in mathmatical situations. With bind you can supplying aguments before invocation.

    function multiply(a, b) {
        return a*b;
    }

    var multiplyByTwo = multiply.bind(this, 2);  // locking in the value of the 'a' parameter

    multiplyByTwo(4); // 8




In react we often use .bind() aswell. For example, we might have a class that includes render(), a constructor, class properties, and a function called func(). When we go on to invoke func from within render, we want to make sure we are working with the properties from this class. So we bind the invocation of func() to within this class. We streamline the code by binding just once with this.func =  this.func.bind(this):

Class definition:

    func(a,b)(this.props = blah)
    
    Constructor(){
        Super()
        this.func = this.func.bind(this);  //our tidy up line
    }
    
    props = {stuff}
    
    render(){
        stuff
        return <div onclick {this.func(a,b)}>
    }

If we did not have our tidy up line of code to keep this all inter-class, then this.func(a,b) would have to be something like this.func.call(this,a,b) or this.func.bind(this). Over many lines of render return it looks clumsy and unreadable.

Note, bind() is similar to call() and apply(). Call/apply invoke the function immediately, whereas bind returns a function that when later executed will have the correct context set for calling the original function. This way you can maintain context in async callbacks, and events.


Strict Mode:

For all these methods, in "non-strict" mode, if the value of the first argument is null or undefined, it is replaced with the global object. In JavaScript strict mode, the first argument becomes the value of this in the invoked function, even if the argument is not an object.

That is, in strict mode, the first argument becomes the value of 'this' in the invoked function, even if the argument is not an object. In "non-strict" mode, if the value of the first argument is null or undefined, it is replaced with the global object.

In the next strict mode example 'this; is undefined. The function, f2(), is invoked directly and not as a method or property of an object (eg, window.f2()). In strict mode, the value of this remains at whatever it's set to when entering the execution context. If it's not defined, it remains undefined:


    function f2(){
      "use strict"; // see strict mode
      return this;
    }
    
    f2() === undefined; //true



In arrow functions, 'this' is set lexically, i.e. it's set to the value of the enclosing execution context's 'this'. In global code, it will be set to the global object:

    var globalObject = this;
    var foo = (() => this);
    console.log(foo() === globalObject); // true


It doesn't matter how foo is called, its 'this' will stay as the global object. This also holds if it's called as a method of an object (which would usually set its this to the object), with call or apply or bind is used:


// Call as a method of an object
var obj = {foo: foo};
console.log(obj.foo() === globalObject); // true [I actually get false in the F12 console!]

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
foo = foo.bind(obj);
console.log(foo() === globalObject); // true

No matter what, foo's 'thi's is set to what it was when it was created (in the example above, the global object). The same applies for arrow functions created inside other functions: their this is set to that of the outer execution context.

    var obj = { bar : function() {
                        var x = (() => this);
                        return x;
                      }
              };
              
    var fn = obj.bar();
    console.log(fn() === obj); // true

In the above, the function(call it anonymous function A) assigned to obj.bar returns another function(call it anonymous function B) that is created as an arrow function. As a result, function B's  this is permanently set to the this of obj.bar (function A)when called. When the returned function(function B) is called, its this will always be what it was set to initially. In the above code example, function B's this is set to function A's this which is obj, so it remains set to obj even when called in a manner that would normally set its this to undefined or the global object (or any other method as in the previous example in the global execution context).



See also the next section on binding 'this' in arrow functions.

For more on 'this' see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this  which includes object methods and constructors.




Arguments Variable / Argument Object

Regular JS does not complain if expected parameters are not passed in as arguments. These parameters are already assigned undefined (they were hoisted anyway - memory space was put aside for them). If not enough arguments are passed then they are assigned in the order of the function signature.

One nice way to deal with undefined variables is an OR to suppy a default value:

    function greet(firstName, lastName, language) {
        language = language || 'en'  // undefined coerces to false
        // ...
    }

Or you can just supply a default value in the signature:

    function greet(firstName, lastName, language = 'en') {
        // ...
    }

One way to access the arguments passed into a function is the 'arguments' keyword. This data structure is created as part of the execution context. 

    function greet() {
        console.log(arguments);
    }

    greet('a', 'test');  

    //Arguments(4) ["a", "test", callee: ƒ, Symbol(Symbol.iterator): ƒ]


Although the copy and paste does not show it here, the logging gives italicised elements. This is because this the arguments object is 'array-like'. It acts and looks like an array but does not have all the features of an array.

As time goes on this will be replaced with spread parameters. You can wrap up an any extra arguments into an array. Eg, function greet(firstName, lastName, language, ...other) will have an array called other available.


Function Overloading

JS does not suport function overloading (the same function with differing paramaters). However you can just create more specific function that call a more general function.

    function greet(firstName, lastName, languages) {// language dependant code}

    function greetEnglish(firstName, lastName) {
        greet(firstName, lastName, 'english')
    }

    function greetSpanish(firstName, lastName) {
        greet(firstName, lastName, 'spanish')
    }





Arrow Functions


By using arrow function we avoid typing the function keyword and possibly also the return keyword (depending on whether you use curly braces or not).

An arrow function expression has a shorter syntax compared to function expressions and lexically binds the this value (in C# they are called lambda expressions). The same applies for arrow functions created inside other functions: their this is set to that of the outer execution context (see above). Arrow functions make our code more concise, and simplify function scoping and the this keyword.

Arrow functions are always anonymous, in fact they help to replace annonymous functions. These function expressions are best suited for non-method functions and they can not be used as constructors.

Basic Syntax:

        (param1, param2, …, paramN) => { statements }
        (param1, param2, …, paramN) => expression
                 // equivalent to:  => { return expression; }
        
        // Parentheses are optional when there's only one parameter:
        (singleParam) => { statements }
        singleParam => { statements }
        
        // A function with no parameters requires parentheses:
        () => { statements }

examples:

        let square = x => x * x;            //cf var square = function(x) { return x * x; };
        let add = (a, b) => a + b;          //cf var add = function(a, b) { return a + b; };
        let pi = () => 3.1415;              //var pi = function() { return 3.1415; };

        console.log(square(5)); // 25
        console.log(add(3, 4)); // 7
        console.log(pi()); // 3.1415



Advanced syntax:

        // Parenthesize the body to return an object literal expression:
        params => ({foo: bar})
        
        // Rest parameters and default parameters are supported
        (param1, param2, ...rest) => { statements }
        (param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }
        
        // Destructuring within the parameter list is also supported
        var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
        f();  // 6


shorter example:

    var a = [
      "Hydrogen",
      "Helium",
      "Lithium",
      "Beryllium"
    ];

var a2 = a.map(function(s){ return s.length });  //[8,6,7,10]

var a3 = a.map( s => s.length ); //[8,6,7,10]




Error Handling and Exceptions
-------------------------------------------

When a function cannot proceed normally, rather than just crash, what we would like to do is just stop what we are doing and immediately jump to a place that knows how to handle the problem. This is what exception handling does.
 
Exceptions are a mechanism that makes it possible for code that runs into a problem to raise (or throw) an exception. An exception can be any value. Raising one somewhat resembles a super-charged return from a function: it jumps out of not just the current function but also its callers, all the way down to the first call that started the current execution. This is called unwinding the stack. An exception zooms down this stack, throwing away all the call contexts it encounters.
 
If exceptions always zoomed right down to the bottom of the stack, they would not be of much use. They’d just provide a novel way to blow up your program. Their power lies in the fact that you can set “obstacles” along the stack to catch the exception as it is zooming down. Once you’ve caught an exception, you can do something with it to address the problem and then continue to run the program.

The throw keyword is used to raise an exception. Catching one is done by wrapping a piece of code in a try block, followed by the keyword catch. When the code in the try block causes an exception to be raised, the catch block is evaluated, with the name in parentheses bound to the exception value. After the catch block finishes, or if the try block finishes without problems, the program proceeds beneath the entire try/catch statement. 

    function promptDirection(question) {
      let result = prompt(question);
      if (result.toLowerCase() == "left") return "L";
      if (result.toLowerCase() == "right") return "R";
      throw new Error("Invalid direction: " + result);
    }

    function look() {
      if (promptDirection("Which way?") == "L") {
        return "a house";
      } else {
        return "two angry bears";
      }
    }

    try {
      console.log("You see", look());
    } catch (error) {
      console.log("Something went wrong: " + error);
    }


In this case, we used the Error constructor to create our exception value. This is a standard JavaScript constructor that creates an object with a message property. In most JavaScript environments, instances of this constructor also gather information about the call stack that existed when the exception was created, a so-called stack trace. This information is stored in the stack property and can be helpful when trying to debug a problem: it tells us the function where the problem occurred and which functions made the failing call.


Cleaning up after an exception:

The effect of an exception is another kind of control flow. Every action that might cause an exception, which is pretty much every function call and property access, might cause control to suddenly leave your code. This can cause problems if you part way through changing values when an exception is thown.

One way to address this is to use fewer side effects. A programming style that computes new values instead of changing existing data helps. If a piece of code stops running in the middle of creating a new value, no one ever sees the half-finished value, and there is no problem.

But that isn’t always practical. So there is another feature that try statements have. They may be followed by a finally block either instead of or in addition to a catch block. A finally block says “no matter what happens, run this code after trying to run the code in the try block.”


    function transfer(from, amount) {
      if (accounts[from] < amount) return;
      let progress = 0;
      try {
        accounts[from] -= amount;  // already subtracted the money
        progress = 1;
        accounts[getAccount()] += amount;
        progress = 2;
      } finally {
        if (progress == 1) {
          accounts[from] += amount;    // return the money if unable to complete the t/f
        }
      }
    }

Be careful not to hide information. Make sure you use the error in the catch statement, and try not to blanket too much code in one try block.

So we want to catch a specific kind of exception. We can do this by checking in the catch block whether the exception we got is the one we are interested in and rethrowing it otherwise. 

We could compare its message property against the error message we happen to expect. But that’s a shaky way to write code—we’d be using information that’s intended for human consumption (the message) to make a programmatic decision. As soon as someone changes (or translates) the message, the code will stop working.

Rather, let’s define a new type of error and use instanceof to identify it.

    class InputError extends Error {}

    function promptDirection(question) {
      let result = prompt(question);
      if (result.toLowerCase() == "left") return "L";
      if (result.toLowerCase() == "right") return "R";
      throw new InputError("Invalid direction: " + result);
    }

    // for loops runs until the break is executed, but if we have some unexpected
    // error we need to catch the exception and figure out what it is.
    for (;;) {
      try {
        let dir = promptDirection("Where?");
        console.log("You chose ", dir);
        break;
      } catch (e) {
        if (e instanceof InputError) {
          console.log("Not a valid direction. Try again.");
        } else {
          throw e;  // something else we didn't expect but would like to track down
        }
      }
    }

Assertions are checks inside a program that verify that something is the way it is supposed to be. They are used not to handle situations that can come up in normal operation but to find programmer mistakes.

If, for example, firstElement is described as a function that should never be called on empty arrays, we might write it like this:

    function firstElement(array) {
      if (array.length == 0) {
        throw new Error("firstElement called with []");
      }
      return array[0];
    }

Now, instead of silently returning undefined (which you get when reading an array property that does not exist), this will loudly blow up your program as soon as you misuse it. This makes it less likely for such mistakes to go unnoticed and easier to find their cause when they occur.

I do not recommend trying to write assertions for every possible kind of bad input. That’d be a lot of work and would lead to very noisy code. You’ll want to reserve them for mistakes that are easy to make (or that you find yourself making).





Importing and Exporting
-------------------------------------------

The syntax really depends on the version of JS you are using. And this will depend upon the version of Node or Electron or whether Babel is used, etc. In the following simple and explicit example we export a sum function into a test file for testing:

sum.js :

    var exports = module.exports = {};     //create an exports object

    exports.sum = function(a, b) {            //append the sum function into the exports object
        return a + b;
    }


sume.test.js:

    const sumModule = require("./sum.js")           //import the module into another document with the require function.

    test('adding 1 and 2 equals 3', () => {         
        expect(sumModule.sum(1, 2)).toBe(3)         //some is a property of the imported module; very explicit here. In ECMA5 you can use deconstruction to make it look a lot better.
    })


In the egg head reduc videos (no. 6) these three import statements are the same:

    const { createStore } = Redux;   //es 6 syntax and structure
    //var createStore = Redux.createStore;
    //import { createStore } from 'Redux';   // for using NPM and something like Babel to transpile 


see also http://2ality.com/2014/09/es6-modules-final.html and also see the modules section, below.


HTML import and Naming Conflicts

What happens if two different authors create their own librairies, and in each library use the same variable name but with a different value? Say lib1.js contains var libraryName = "Lib 1" and lib2.js contains var libraryName = "Lib 2".

    <html>
        <head></head>

        <body>
           <script src="lib1.js"></script>
           <script src="lib2.js"></script>
           <script src="app.js"></script>
        </body>

    </html>

These script tags do not create a different execution context for each library. Instead their content is just placed together insde the global execution context as if it is from a single file. (In many applications all the code is minifed into one bundle).
 
    console.log(libraryName)  // Lib 2 (written in app.js) 

One common way around this problem is recognizing that we are in the global context/namespace and check that namespace for a naming conflict:

    window.libraryName =  window.libraryName || "lib 2";  // in lib2.js

    console.log(libraryName)  // Lib 1 (written in app.js) 




Modules
------------------------------

Modules are a great way to organise more complex code, kind of like dividing a book into chapters. There is thus a clear focus for every module and related things can be found close together. They also provide for reuse. Also, like an interface, they isolate/privatise code and provide a public interface (see the module example in the Closure section). This is called decoupling.

Most modern programming languages have a scope level between global (everyone can see it) and local (only this function can see it). JavaScript does not. Thus, by default, everything that needs to be visible outside of the scope of a top-level function is visible everywhere. This can lead to the problem of namespace pollution; the problem of a lot of unrelated code having to share a single set of global variable names.

External modules are libraries. NPM is an example of a services that organises a large number of libraries (see Node.js at http://eloquentjavascript.net/20_node.html). 


Using functions as namespaces: functions are the only things in JavaScript that create a new scope. So if we want our modules to have their own scope, we will have to base them on functions.



Objects
----------------------------

"Objects are really just containers for an unordered list of properties, each of which has a name [aka key] and a value." The object contains memory references to these properties. Functions properties are often called methods. Without methods we would only have a database.

Objects are the most fundamental data type, and they are the only complex type. And, unlike primitive data types objects are mutable.

Using objects, we can put our information and the functions that use that information in the same place, It's like haveing nouns (variables) and their actions (verbs) in the one place. There are many ways to create object, one of which is object literal notation with curly braces:

    var someObj = {
        aProperty: value,
        someMethod: function(some, params) { }
    };

Additional properties can be added to an object after the object has been created. In this more complicated literal example. We see that we can reference a previously created function object and make it a method:

    function talk() {
        console.log(this)
        console.log(this.sound)
    }

    let animal = {
        talk: talk    //in ECMA 6, when the property components have the same title, we can just type 'talk'
    }

    animal.talk();

Mutation, creation and the referening of properties is done with the same notation. This notation revolves around the property name. Property names can be a string or a number, but if the property name is a number, it has to be accessed with the bracket notation:

    objectRef.name = "Charlie"; // aka:  objectRef["name"] = "Charlie";
    objectRef[3] = 99;


The first form, using the 'dot' operator (or 'Member Access' - 2nd highest on the precedence table) is used when you know the name of the property.    

The second form uses the 'computed member access' operator ('[]' - very near the top of the operator precedence table), which is used when the name of the property is dynamically determined. The operator looks for "name" on the object and if it does not exist then it creates a variable and supplies the object with a reference to that variable. This operator takes a string, or something that evaluates to a string:

    var nameProperty = "name";
    console.log(objectRef[firstNameProperty]); // "Charlie"

We can also an include a reference to an object property:

    objectRef.address = new Object();  // not the prefered way to create a new object
    objectRef.address.street = '111 Main Street';  // aka objectRef['address']['street']

Since both of these operators have left-right associativity we know that objectRef.address, on the left, will be evaluated first. A property or method will be searched out that has the name 'address'. Once that is found in memory, the second dot operator looks for a property or method called "street".

The dot operator is preferred over the computed member accesss operator. It looks cleaner and is easier to debug. You would only use coputed member access if you were dealing with a dynamically computed string.

Bracket notation is useful if you have a property name that has special characters in it, like obj["hello world!"] -- such properties are often referred to as keys when accessed via bracket notation. The [ ] notation requires either a variable (explained next) or a string literal (which needs to be wrapped in " .. " or ' .. ').

Bracket notation is also useful if you want to access a property/key but the name is stored in another variable, such as:

    var obj = {
        a: "hello world",
        b: 42
    };

    var b = "a";

    obj[b];         // "hello world"
    obj["b"];       // 42

Another second way of creating an object is the object constructor:

    var objectRef = new Object(); // create a generic javascript object 

This tells JavaScript: "I want you to make me a new thing, and I want that thing to be an Object." And then it uses a constructor (see below) to make the object. Here we use a built-in constructor called Object. This constructor is already defined by the JavaScript language and just makes an object with no properties or methods.
 
Early in the development of JS, there was a language war going on. To attract Java developers to JS, the name JavaScript was used. Microsoft did the same thing with VB script and Visual Basic programmers. JS is actually very different to Java, but some features were used for familarity. One of which was using the new keyword to create an object. This looked very much like OOP, which is the paradigm Java works within. It was a marketing move.

    function Person(firstName, lastName) {
        console.log(this);  // Person {}
        this.firstName = firstName;
        this.lastName = lastName;
    }
    var john = new Person('John', 'Doe');

    console.log(john); // log out an object: Person {firstName: "John", lastName: "Doe"}

The 'new' keyword is actually an operator. As soon as you use it a new object is created. It then calls the function. This means an execution context is created. Part of that context is a 'this'. The keyword 'new' changes what 'this' points to: the new empty object (already of type Person - see the logging above). So, the Person() function above, is adding properties to the new object via it's reference to 'this'. Then, as long as Person() does not return a value, the JS engine knows (because of 'new') to automatically return the new object. (There is an example, below, on recreating 'new').

Since we have constructed an object via a function, we call the function a 'function constructor': "a normal function that is used to construct objects". 

[insert the inheritance section here????]

So when we use a function constructor how do we set the prototype? Well it is actually supplied automatically. Recall that functions are special objects because they have some extra properties, such as 'name' (which can be anonymouse) and 'code' (which holds the code that is executed when you invoke the function). Another property is 'prototype'. It is first created as an empty object. Unless you use a function as a function consturctor it is never used. However, once you use the new operator it does something. 

This is very confusing, because if use myFuncObject.prototype you may well think you are accessing myFuncObject's prototype. To do that you actually need __proto__. Instead, .prototype is the prototype of any object created from your function object. So, when you construct an object from myFuncObject with the new keyword, say newObject, then newObject's __proto__ is myFuncObject's .prototype .


    function Person(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    Person.prototype.getFullName = function() {
        return this.firstName + ' ' + this.lastName;
    }

    var john = new Person('John', 'Doe');

    console.log(Person.prototype);                      // {getFullName: ƒ, constructor: ƒ}
    console.log(john.__proto__);                        // {getFullName: ƒ, constructor: ƒ}
    console.log(john.__proto__ === Person.prototype);   // true


And you can add to the constructors .prototype property after it has made objects, and those extra features can be accessed by these pre-existing objects.

    var john = new Person('John', 'Doe');
    
    Person.prototype.getFormalName = function() {
        return this.lastName + ', ' + this.firstName;
    }

    console.log(john.getFormalName()); // Doe, John

The advantage of keeping properties and methods in the prototype is that we save memory. All the constructed objects point to the same properties and methods at the same location in memory. So it's better to put your methods on the prototype. 

ReAt any rate here is a counter-example in which each object gets its own non-proto methods:

    function Rectangle(height, width) {
    this.height = height;
    this.width = width;
    this.corners = 4; //applies to all objects
    this.calcArea = function() { //method definition
        return this.height * this.width;
    };
        this.calcPerimeter = function() {
        return this.height*2 + this.width*2;
    };
    }

    var rex = new Rectangle(7,3);
    var area = rex.calcArea();
    var perimeter = rex.calcPerimeter();

Danger warning: we know that the new keyword creates an empty object of the contructor's type, has the contructor return an object if there is no 'return' statement in the constructor, and points __proto__ for the new object back to .prototype in the constructor. But, the constructor is still just a function. So, if we forget to use 'new' then the function is executed in the normal way and will return undefined. No methods and properties will be available to this new binding of undefined type. Using a captial letter for constructor names can help both you and linting tools.

JS also supplies some built in function constructors (we saw Object() above). 

    var a = new Number(3);
    console.log(a); // Number {3}__proto__: Number[[PrimitiveValue]]: 3 // ie an object, not a primitive
    console.log(a.toFixed(2)); // number methods are available from the protoype chain (Number.prototype).

In this example the primitive value is still there, but we say it is 'boxed inside' the object. 'new' returns objects! 

The JS engine will automatically box, or 'wrap up' string primitives for you (but not numbers - use 'new' as above):

    "john".length // 4

JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers), in this case String (capital S) object wrapper. number can be wrapped by a Number object, and a boolean can be wrapped by a Boolean object. Generally the object verion of a primitive complicates your code and slows down execution speed.

You also have the flexibility to add to any of the built-in protoypes.

    String.prototype.isLengthGreaterThan = function(limit) {
        return this.length > limit;
    }

    "John".isLengthGreaterThan(3)  // true

This is the power of prototypal inheritance. It is very easy to enhance the entire language. With a few lines all strings have a new method available (but be very careful not to overwrite an existing method).

Built in function constructors can also be dangerous. 

    var a = 3;
    var b = new Number(3);
    a === b; // false (not of the same type, which === checks first and then stops)
    a == b; // true - because coercion is allowed.

    var c = Number('3');  // no 'new' here; so not an object.
    a === c; true

So when possible use only literals. Also, if you are doing a lot of date work, use momentjs (momentjs.com) instead of the built in date cotructor. 

Danger warning: arrays and for...in. Recall that we have already looked and reflecting and extending an object by looping through all it's properties. Arrays are objects, so we can do the same thing. 

    var array = ['john', 'jane', 'jim'];

    for (var prop in array) {
        console.log(prop + ': ' + array[prop]);
    }

    // 0: john
    // 1: jane
    // 2: jim

So the indicies in JS arrays are different to other languages. They are the property keys. Arrays are still objects with name value pairs. In fact the square brackets are just a short hand for new Array(). However a problem occurs if someone adds an extra method onto the Array .prototype property, then a for-in loop will also pick up this property. So, don't use for in loops on arrays. Just use a standard index based for-loop through the elements. 

Object.create and Pure Prototypal Inheritance

There is another way to make objects without awkwardly mimicking the OOP 'new' approach.  

    var person = {
        firstName: 'Default',
        lastName: 'Default',
        greet: function() {
            return 'Hi ' + this.firstName; 
        }
    }

Side note: we need 'this.firstName' here and not just firstName. Objects do not create an execution context and firstName is not defined in the greet function. This means that the JS engine will fail to find firstName in the function and then go straight to the global context, where it will again not find firstName.

    var john = Object.create(person);

Object.create creates an object with whatever that is passed in as a prototype (ie __proto__ references person's  properties: firstName, lastName, and greet).

    john.greet(); // 'Hi Default'

The pattern now is to override which ever properties you want.

    john.firstName = 'John';

So in pure prototypal inheritance you just make objects from objects, rather than objects from functions. It is very simple and straightforward. And you can still mutate the prototype as you go, making it powerful.

If you a working with older engines, that were made before Object.create was incorporated into the language, you can use a polyfill. 

Polyfill: "Adds a feature which the engine may lack".

    if(!Object.create) {
        Object.create = function(o) {
            if(arguments.length > 1) {
                throw new Error('Object.create implementation'
                + ' only accepts the first parameter.');
            }
            function F() {}
            F.prototype = o;
            return new F();
        }
    }

ES6 and classes provides another way to make objects. A JS class defines an object. It has a constructor that acts similarly to a constructor function. 

    class Person {
        constructor(firstName, lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        greet() {
            return 'Hi ' + this.firstName;
        }
    }

    var john = new Person('John', 'Doe');

The difference with other languages is that this is not a template. Person is still an object. We continue to make objects from objects. 

If you want to set the prototype (__proto__) for this class object use the 'extends' keyword. By then calling super() you can call the contructor of the prototype.

    class InformalPerson extends Person {
        constructor(firstName, lastName) {
            super(firstName, lastName);
        }

        greet() {
            return return 'Yo ' + this.firstName;
        }
    }

This is syntactic sugar: "a different way to type something that does not change how it works under the hood";



Example of creating an object with methods that include a switch statement:

var cashRegister = {
    total: 0,
//insert the add method here    
    add: function(itemCost){
        this.total += itemCost;    
    },
    
    scan: function (item) {
        switch (item) { 
        case "eggs": 
            this.add(0.98); 
            break;
        
        case "milk": 
            this.add(1.23); 
            break;
        
        //Add other 2 items here
        case "chocolate":
            this.add(0.45);
            break;
        
        case "magazine":
            this.add(4.99);
            break;
        }
        return true;
    }
};

//Scan 2 eggs and 3 magazines

cashRegister.scan("eggs");
cashRegister.scan("eggs");
cashRegister.scan("magazine");
cashRegister.scan("magazine");
cashRegister.scan("magazine");

//Show the total bill
console.log('Your bill is '+cashRegister.total);


We could have written the switch statement more concisely:

    scan: function(item) {
        switch (item) {
        case "eggs": this.add(0.98); break;
        case "milk": this.add(1.23); break;
        case "magazine": this.add(4.99); break;
        case "chocolate": this.add(0.45); break;
        }
    }



Objects are Reference Data Types:

One of the main differences between reference data types and primitive data types is reference data type’s value is stored as a reference, it is not stored directly on the variable, as a value, as the primitive data types are. For example:

    var person = "Kobe";  
    var anotherPerson = person; // anotherPerson = the ***value*** of person
    person = "Bryant"; // value of person changed but anotherPerson is not affected
    
    console.log(anotherPerson); // Kobe
    console.log(person); // Bryant


However for an object:

    var person = {name: "Kobe"};
    var anotherPerson = person;
    person.name = "Bryant";
    
    console.log(anotherPerson.name); // Bryant
    console.log(person.name); // Bryant


A example with iteration through a nested object can be found in the Flow Control section. Objects are iterative structures in that an iterative for-in loop can work through its contents (ie work though each key: value pair) (see below in this section for an example relating to access keys and values). 


The delete operator and the in operator:

You can delete an object property with the unary delete operator. The binary in operator:



Arrays as Objects

Recall that arrays are objects. In this example we make an array of pre-defined person objects:

function Person (name, age) {
    this.name = name;
    this.age = age;
}

// Now we can make an array of people
var family = new Array();
family[0] = new Person("alice", 40);
family[1] = new Person("bob", 42);
family[2] = new Person("michelle", 8);

This example shows a limitation in arrays, they are good as a list but are not so good for storing multiple pieces of information about each list item. This object approach is a nice way around.

An important aspect of arrays is that they preserve order; they remember the order in which items are added. Not all data structures do this.


The sort() method sorts an array alphabetically, while reverse() reverse the elements in an array.

By default, the sort() function sorts values as strings. This works well for strings ("Apple" comes before "Banana"). However, if numbers are sorted as strings, "25" is bigger than "100", because "2" is bigger than "1". Because of this, the sort() method will produce incorrect result when sorting numbers. You can fix this by providing a compare function:


    var points = [40, 100, 1, 5, 25, 10];
    document.getElementById("demo").innerHTML = points;

    function myFunction() {
        points.sort(function(a, b){return a - b});
        document.getElementById("demo").innerHTML = points;
    }

The compare function should return a negative, zero, or positive value, depending on the arguments. 

Sorting an array into random order:

var points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return 0.5 - Math.random()});


Sorting object arrays: 

Even if objects have properties of different data types, the sort() method can be used to sort the array. The solution is to write a compare function to compare the property values:

var cars = [
{type:"Volvo", year:2016},
{type:"Saab", year:2001},
{type:"BMW", year:2010}];

cars.sort(function(a, b){return a.year - b.year});

Comparing string properties is a little more complex:

 cars.sort(function(a, b){
    var x = a.type.toLowerCase();
    var y = b.type.toLowerCase();
    if (x < y) {return -1;}
    if (x > y) {return 1;}
    return 0;
});


The array filter method:

var ages = [32, 33, 16, 40];

function checkAdult(age) {
    return age >= 18;
}

function myFunction() {
    document.getElementById("demo").innerHTML = ages.filter(checkAdult);  //32,33,40
}



Copy an Object:

Object.assign(target, ...sources) returns a shallow copy (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) . [By shallow, we mean that any nested sub objects have the same reference so can suffer side effects]. To be a copy though, the target must be a new empty object, eg:

    Object.assign({}, state, {
        visibilityFilter: action.filter
    }


Wheras one way to create a deep copy is let copyObject = JSON.parse(JSON.stringify(sourceObject));

You can also use the spread operator for a shallow copy

    let copy = {...origional}



Property Determination:

Once we know we are dealing with an object (eg, see the typeof operator), then we know it will have properties. We can then use the hasOwnProperty method, which belongs to all objects:

var myObj = {
    // finish myObj
    name: "Obj"
};

    console.log( myObj.hasOwnProperty('name') ); // should print true
    console.log( myObj.hasOwnProperty('nickname') ); // should print false

We see that hasOwnProperty returns a boolean, so we can use it if statements to avoid errors in our code.

We can also traverse through an object and log all the keys/property names:

    var nyc = {
        fullName: "New York City",
        mayor: "Bill de Blasio",
        population: 8000000,
        boroughs: 5
    };

    for(var property in nyc) {
    console.log(property);
    }

    // fullName
    // mayor
    // population
    // boroughs

If you want the property value then note that the for-in loop produces a string of the property name. Therefore we used the bracket access notation:

    for(var property in nyc){
        console.log(nyc[property]);    
    };

    // New York City
    // Bill de Blasio
    // 8000000
    // 5




Prototypes (Protypical Inheritance) and Constructors
----------------------------------------------------------

"Inheritance": One object gets access to the properties and methods of another object. Javascript uses prototypal inheritance.

Inheritance is realted to the DRY principle of programming: Do not Repeat Yourself. 

Watch closely:

    var empty = {};
    console.log(empty.toString);
    // function toString(){…}
    console.log(empty.toString());
    // [object Object]

We just pulled a property out of an empty object. Magic!

Javascript is a prototypal inheritance language. That means that objects can inherit properties directly from other objects. The language is class free. A class system is now available in Javascript, but it only really wraps around the prototype structure. Thus, it is still worth learning about prototypes.

In classical object-orientated prgramming this can become a complicated mess. With keywords like friend, protected, private, and interface flying around, it can be difficult to work out how a change in one place will affect another.

A real world analogy to classes is a blueprint. From one blueprint you can create many buildings (ie objects). The real world analogy of a prototype is a back-up. Rather than making a fully new object with all the methods from the parent, JS instead moves up the prototype chain and checks to see if a method is available from another object.

For example, objects created using an object literal, or with new Object(), inherit from a prototype called Object.prototype. And, objects created with new Date() inherit the Date.prototype. 

All objects may have prototypes, and prototypes are objects so they, in turn, may have prototypes, which may have prototypes, and so on forming what is called the prototype chain (not the same as the scope chain). The prototype chain ends when one of the objects in the chain has a null prototype. The default prototype for the Object constructor has a null prototype so

    var objectRef = new Object(); //create a generic javascript object.

creates an object with the prototype Object.prototype that itself has a null prototype. So the prototype chain for objectRef contains only one object: Object.prototype. That is, the Object.prototype is on the top of the prototype chain. Similarly, what is the prototype of that empty object? It is the great ancestral prototype, the entity behind almost all objects, Object.prototype.

So each object has a prototype property, which in turn will reference some properties. If a second object also references the same prototype object (which it can), then it is same properties, at the same place in memory, that both objects have access to.

    console.log(Object.getPrototypeOf({}) ==
                Object.prototype);
    // → true
    console.log(Object.getPrototypeOf(Object.prototype));
    // → null

As you might expect, the Object.getPrototypeOf function returns the prototype of an object. The prototype relations of JavaScript objects form a tree-shaped structure, and at the root of this structure sits Object.prototype.


Example:

    function talk() {
        console.log(this); 
        console.log(this.sound);
    }

    let animal = {
        talk
    }

    let cat = { 
        sound: 'meow!'
    }

    // cat.talk()  // causes a type error. Cats don't talk (yet)

    Object.setPrototypeOf(cat, animal)  // don't do actually do this. Use Object.create() - 
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf
    
    cat.talk()      // meow!

So eventhough cat does not have a talk method, JS assigns cat to 'this' and also applies the talk method from further up the chain.

To really explore the chain idea we can take this example further:

    let dog = {
        sound:  'woof!',  // a default property for all dogs
        growl: 'rrrr',
        makeGrowl: function() {
            console.log (this.growl) // when this function is invoked the execution context uses the calling object as 'this'
        }
    }

    let prarieDog = {
        sound: 'Arghhh!',
        howl : function() {
            console.log(this.sound.toUpperCase())
        }
    }

    //Object.setPrototypeOf(dog, animal);  // dogs inherit from animals so priareDog will as well
    Object.setPrototypeOf(prarieDog, dog);

    prarieDog.howl();       // Arghhh!  
                            // Why don't I get woof!? Because of the prototype chain. Once something is found the chain search stops.
    prarieDog.makeGrowl();  // rrrr   


Browsers provide you a direct way to directly assign a prototype but DO NOT ever do it. It has serious performance issues. 

    prarieDog.__proto__ = dog;  // The double underscore is reminder that should never use this!


However you can use __proto__ in the dev tools to see the properties avaialble in the scope chain.

    prarieDog.__proto__     // {sound: "woof!", growl: "rrrr", makeGrowl: ƒ}

    prarieDog.__proto__.__proto__  // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ


That last example is showing those properties and methods from the built-in core Object protoype and the base of the prototype chain.

    [].__proto__ // will show array based methods like push and reduce. 

And doing this on a function will show methods like call and bind. This is how the functionality built into JS is made available to you.



We can use "relection" to implement "extend".

Reflection: "An object can look at itself, listing its properties and methods".

    // log out all these properties 
    for (var prop in prarieDog) {
        console.log(prop + ': ' + prarieDog[prop])  // recall the brackets operator accepts a string as a property name.
    }

    // sound: Arghhh!
    // howl: function() {
    //  console.log(this.sound.toUpperCase())
    // }
    // growl: rrrr
    // makeGrowl: function() {
    //  console.log (this.growl) 
    // }

So we see that with a for-in loop we pick up properties from the protoype chain as well. Fix this with hasOwnProperty:

    for (var prop in prarieDog) {
        if (prarieDog.hasOwnProperty(prop)) {
            console.log(prop + ': ' + prarieDog[prop])  // recall the brackets operator accepts a string as a property name.
        }
    }

So now we can have an object reflect upon it's own properties. To extend this object to another object (ie, let another object share this object's properties) we can now just add the properties directly on the new object:

    newObject[key] = oldObject[key];

This powerful extension pattern, which is not using the protoype chain, shows up in a lot of frameworks and libraries. However don't mix up this relfection-extend pattern with the 'extends' keyword (ends with an 's').

When you add a property to an object, whether it is present in the prototype or not, the property is added to the object itself, which will henceforth have it as its own property. If there is a property by the same name in the prototype, this property will not noramlly affect the object. The prototype itself is not changed [ie the compiler looks to the object itself for the key in question and only looks further if it cannot find that key]. It is as if the upstream version has been hidden. 

If you do want to access a hidden upstream method you can still do so. Say we have written our own toString method but we still want to plug the current object into the original toString (tries to convert the contents of an object into a string):

    Object.prototype.toString.call(myObject);

Incidentially, this is is also one workaround for the typeof bug, in which arrays are reported as objects.

    Object.prototype.toString.call([1, 2, 3]); // [Object Array]

See also (Array.isArray()).

More complicated example:

    function MyObject1(formalParameter){  // A "constructor" function for creating objects of the MyObject1 type.
        this.testNumber = formalParameter;
    }

    function MyObject2(formalParameter){
        this.testString = formalParameter;
    }

    /* The next operation replaces the default prototype associated with
       all MyObject2 instances with an instance of MyObject1, passing the
       argument 8 to the MyObject1 constructor so that its 
       testNumber property will be set to that value.
    */

    MyObject2.prototype = new MyObject1( 8 );  

    /* Finally, create an instance of MyObject2 and assign a reference
       to that object to the variable objectRef passing a string as the
       first argument for the constructor:
    */

    var objectRef = new MyObject2( "String_Value" );


    console.log(objectRef.testNumber)  // 8 testNumber is available to us via the protoype chain


The instance of MyObject2 referred to by the objectRef variable has a prototype chain. The first object in that chain is the instance of MyObject1 that was created and assigned to the prototype property of the MyObject2 constructor. The instance of MyObject1 has a prototype, the default Object prototype that corresponds with the object referred to by Object.prototype. Object.prototype has a null prototype so the prototype chain comes to an end at this point.

In the simple case:-

    var val = objectRef.testString;

The instance of MyObject2 referred to by objectRef has a property with the name "testString" so it is the value of that property, set to "String_Value", that is assigned to the variable val. [I like this wording "the instance of Object refered to by objectRef ..."]

Now consider:

    var val = objectRef.testNumber;

The variable val is set to the value of 8 rather than undefined because having failed to find a corresponding named property on the object itself [this is first place in the chain checked; it has the highest priority. Such properties may only apply to a specific instance] the interpreter then examines the object that is its prototype. Its prototype is the instance of MyObject1 and it was created with a property named "testNumber" with the value 8 assigned to that property, so the property accessor evaluates as the value 8. 

Neither MyObject1 or MyObject2 have defined a toString method, but if a property accessor attempts to read the value of a toString property from objectRef:

    var val = objectRef.toString;

The val variable is assigned a reference to a function. That function is the toString property of Object.prototype and is returned because the process of examining the prototype of objectRef, when objectRef turns out not to have a "toString" property, is acting on an object, so when that prototype is found to lack the property its prototype is examined in turn. Its prototype is Object.prototype, which does have a toString method so it is a reference to that function object that is returned.

Also:

    var val = objectRef.madeUpProperty;

returns undefined, because as the process of working up the prototype chain finds no properties on any of the object with the name "madeUpPeoperty" it eventually gets to the prototype of Object.prototype, which is null, and the process ends returning undefined.


Some variations on the above MyObject example (both prototypes have testNumber so shows priority within the chain):

1. The testnumber value is not overridden by the prototype when we still have the ability to make use it in the costructor:

    function MyObject1(formalParameter){  
        this.testNumber = formalParameter;
    }

    function MyObject2(formalParameter){
        this.testArray = [1,2,3];
        this.testNumber = formalParameter;
    }

    MyObject2.prototype = new MyObject1(8);

    var objectRef = new MyObject2(9);     

    console.log(objectRef.testArray)    // [1,2,3]
    console.log(objectRef.testNumber)   // 9
    console.log(MyObject2.prototype.testNumber) // 8


2. This is also the case when we leave the value undefined when invoking the myObject1 constructor:

    function MyObject1(formalParameter){  
        this.testNumber = formalParameter;
    }

    function MyObject2(formalParameter){
        this.testArray = [1,2,3];
        this.testNumber = formalParameter;
    }

    MyObject2.prototype = new MyObject1();

    var objectRef = new MyObject2(9);   
        
    console.log(objectRef.testArray)                        // [1,2,3]
    console.log(objectRef.testNumber)                       // 8
    objectRef instanceof MyObject1                          // true (see below)
    objectRef instanceof MyObject2                          // true (see below)
    console.log(objectRef.__proto__ == MyObject2.prototype)  // true (see below)

instanceof

The instanceof operator tests the presence of constructor.prototype in an object's prototype chain. That is, it tests whether an object is an instance of a particular class. The general syntax is: 

    object instanceof constructor

example:

    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    var myPoint = new Point();

    // the following are all true
    myPoint.__proto__ == Point.prototype
    myPoint.__proto__.__proto__ == Object.prototype
    myPoint instanceof Point;
    myPoint instanceof Object;
 
In this variation we add in additional property for a specific instance. However all the same tests remain true. This is because specific properties are not part of the prototype. Instead they belong only to the object in question.

     function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    var myPoint = new Point(2,2);

    myPoint.sum = this.x + this.y;  //additional method for the object reference represented by myPoint

    // the following are all true
    console.log(myPoint.__proto__ === Point.prototype);
    console.log(myPoint.__proto__.__proto__ === Object.prototype);
    console.log(myPoint instanceof Point);
    console.log(myPoint instanceof Object);



Recreating the 'new' Keyword

Under-the-hood the 'new' keyword carries out a four stage process to re create the class system. First it creates an empty object. Then it sets the prototype property ( __proto__ ) of new object to the prototype of the function/constructor. That is, we are setting the prototype of the new object 'to whatever object is on the prototype property of the constructor'. The third step is to execute the constructor function with 'this' refering to the new object. Lastly, 'new' then returns the new object and does setPrototypeOf between the objects. This is why the class system in JavaScript is just a thin syntax layer over the prototype framework. Classess are faked. We can emulate 'new' (a great way to learn anything):

Consider this:

    function Person(saying) {
        this.saying = saying;
        this.talk = function() {
            console.log('I say:', this.saying);
        }
    }

    var crockford = new Person('SEMIColans!!!1one1');

    crockford.talk()    // I say: SEMIColans!!!1one1



Now we make our own "New" following the four steps from above:


    function Person(saying) {
        this.saying = saying
        this.talk = function() {
        console.log('I say:', this.saying)
        }
    }

    function New(constructor) {
        let obj = {}                    // step 1; make a new object
       
        Object.setPrototypeOf(obj, constructor.prototype)  // step 2: set the prototype
        
        //step 3: execute the constructor with 'this' set to the new object
        
        // create an array from the arguments object
        var argsArray = Array.prototype.slice.apply(arguments) // see the Arguments Object section for the better ECMA 6 way
        
        // take out the first element of the arguments array with slice so that we ignore the constuctor name: 'Person', leaving 'saying'
        constructor.apply(obj, argsArray.slice(1)); // apply is like bind except it executes immediately rather than making a copy 
        
        //step 4: return the created object
        return obj
    }

    var crockford = New(Person, 'SEMIColans!!!1one1')

    crockford.talk()  // I say: SEMIColans!!!1one1



Public/Private

In JavaScript all properties are automatically public. That is, they can be accessed outside the class. This is information that an object can share. To make a property private, we declare it inside the constructor with var (instead of 'this'). 

In the following example 'firstname', 'lastname', and 'age' are public properties while 'backBalance' is a private variable.

function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;     //any attempt to print this to the console will fail (for a specific object created from this class definition).
}

The way to get around this is define a public method to access a private variable [a "getter"]. See the getBalance method below:


function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;
  
   this.getBalance = function() {
      // your code should return the bankBalance
      return bankBalance;
   };
}

var john = new Person('John', 'Smith', 30);
console.log(john.bankBalance);                          // undefined

// create a new variable myBalance that calls getBalance()
var myBalance = john.getBalance();
console.log(myBalance);                                      //works


Methods can also be private. In the above example we could change this.getBalance from the last exercise to var returnBalance. The get around is to create a public method to access the private method.


function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;
  
   var returnBalance = function() {     //here we have a private method
      return bankBalance;
   };
       
   // create the new function here
   this.askTeller = function(){
        return returnBalance;       //this is a public method. Note that it returns an entire method so there are no brackets. This is not a call to returnBalance().
   };
}

var john = new Person('John','Smith',30);
console.log(john.returnBalance);                           //produces 'undefined'
var myBalanceMethod = john.askTeller();                 //assigning the method ebing return by askTeller to a function
var myBalance = myBalanceMethod();              //assigning the return value of our new function to a variable which we then go on to use below.
console.log(myBalance);

In the next example we see that for-in loops will skip over private method and properties:

function StudentReport() {
    var grade1 = 4;
    var grade2 = 2;
    var grade3 = 1;
    this.getGPA = function() {
        return (grade1 + grade2 + grade3) / 3;
    };
}

var myStudentReport = new StudentReport();

for(var x in myStudentReport) {
    console.log(x); 
};                                  //only "getGPA" is printed in the console.





Strict Mode
----------------------------------

ES5 added a "strict mode" to the language, which tightens the rules for certain behaviors. Generally, these restrictions are seen as keeping the code to a safer and more appropriate set of guidelines. Also, adhering to strict mode makes your code generally more optimizable by the engine. Strict mode is a big win for code, and you should use it for all your programs.

You can opt in to strict mode for an individual function, or an entire file, depending on where you put the strict mode pragma "use strict":


    function foo() {
        "use strict";
    
        // this code is strict mode
    
        function bar() {
            // this code is strict mode
        }
    }
    
    // this code is not strict mode


Compare that to:
    
    "use strict";
    
    function foo() {
        // this code is strict mode
    
        function bar() {
            // this code is strict mode
        }
    }
    
    // this code is strict mode


One key difference (improvement!) with strict mode is disallowing the implicit auto-global variable declaration from omitting the var (see the Scope section):

    
    function foo() {
        "use strict";   // turn on strict mode
        a = 1;          // `var` missing, ReferenceError. Without strict mode this would have become a global variable. Happens a lot with typos.
    }
    
    foo();

If strict mode causes issues in your program, almost certainly it's a sign that you have things in your program you should fix. Not only will strict mode keep your code to a safer path, and not only will it make your code more optimizable, but it also represents the future direction of the language.

See also https://blog.oio.de/2013/04/16/ecmascript-5-the-current-javascript-standard/






ES5 Changes
--------------------------------------------

See https://blog.oio.de/2013/04/16/ecmascript-5-the-current-javascript-standard/

But the more interesting bits are:

Two methods for native JSON support: 

JSON.parse() cConverts a JSON string into a JavaScript object

    var fromJSON = JSON.parse( '{"var1":"foo","var2":"bar"}' );
    console.log(fromJSON.var1 + " - " + fromJSON.var2);
    // prints foo - bar


JSON.stringify() converts a JavaScript object into a JSON string

    var obj = {
        var1: "foo",
        var2: "bar"
    };
    console.log(JSON.stringify(obj));
    // prints {"var1":"foo","var2":"bar"}

Array.isArray(someVar):

The typeof operator has existed for a long time in JavaScript. Unfortunately it doesn’t really work with arrays:

    var anArray = [1, 2, 3];
    console.log(typeof anArray);    // prints 'object'

Although this is no bug (because arrays in JavaScript are internally treated and represented as objects with normal property key: value pairs) it surely doesn’t help much. This is why Array.isArray() was added to ES5.

    var anArray = [1, 2, 3];
    console.log(Array.isArray(anArray)); // prints 'true'

forEach(): 

Is used to iterate on an array and to apply a callback function on every element

    var anArray = [1, 2, 3];
    anArray.forEach(function(x){
    console.log(x * 3);     // prints 3, 6, 9

say we have an array called listeners inside a Redux app, and we want to go through all of them:

    listeners.forEach(listener => listener())



map() and filter():

Map() basically works like forEach() with the difference being that in contrast to forEach(), where only a function is invoked on every method, map() returns a new array with all elements after the callback function was applied to them.

Filter() expects a callback function returning true for elements that should be included in the new array and false for elements that should be discarded.


    var anArray = [1, 2, 3, 4, 5, 6];
    var squared = anArray.map(function(x){
        return x * x;
    });
    squared.forEach(function(x) {
        console.log(x);     // prints 1, 4, 9, 16, 25, 36
    });
     
    var oddOnesOut = anArray.filter(function(x){
        if(x % 2 == 0) {
            return true;
        } else {
            return false;
        }
    });
    oddOnesOut.forEach(function(x) {
        console.log(x);     // prints 2, 4, 6
    });


Say we want to remove a 'listener' from an array called 'listeners' in A redux app:

    listeners = listeners.filter(l => !== listener)    


every() and some():

Like filter() these methods also expect a callback method intended to test an element and to return true if the element passes the test and otherwise false. Every() returns true if the callback method returned true for all elements in the array, otherwise false, some() returns true if the callback passed for at least one element.

    var anArray = [10, 100, 1000];
    console.log(anArray.every(function(x){
        return x % 10 == 0;
        //prints 'true' because every element is a multiple of 10
    }));
     
    console.log(anArray.every(function(x){
        return x > 500;
        //prints 'false' because NOT every element is
        //greater than 500
    }));
     
    console.log(anArray.some(function(x){
        return x > 500;
        //prints 'true' because at least one element is
        //greater thant 500
    }));

reduce():

This methods basically allows you to transofrm an array into something else. It applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.

Reduce() is handy for example to calculate the sum of all elements or to find the maximum/minimum.

    var anArray = [9, 3, 5, 13, 2, 4, 11];
    console.log(anArray.reduce(function(elem, prev){
        return elem > prev ? elem : prev;       // prints 13
    }));

    var sum = [0, 1, 2, 3].reduce(function(acc, val) {
      return acc + val;
    }, 0);                      //0 is the initial value
    // sum is 6

In API testing Aidan demonstrated two ways to use reduce() to add all the entries in a data file as a kind of hash:

    let dataSum = convertedData.reduce(function(memo, x) {
        return memo + x
    }, 0)
    expect(dataSum).to.equal(6746799)


    // aka ...
    
    expect( 
        convertedData.reduce( (memo, x) => (memo + x), 0) 
        ).to.equal(6746799)

Another usage is flattening an array of arrays:

    var list1 = [[0, 1], [2, 3], [4, 5]];
    var list2 = [0, [1, [2, [3, [4, [5]]]]]];

    const flatten = arr => arr.reduce(
      (acc, val) => acc.concat(
        Array.isArray(val) ? flatten(val) : val
      ),
      []
    );
    flatten(list1); // returns [0, 1, 2, 3, 4, 5]
    flatten(list2); // returns [0, 1, 2, 3, 4, 5]

Another flattening example:

    SomeArray.reduce((prevVal, currentVal) => {
                return prevVal.concat(currentVal)
            }, []);



In the next example reduce() is used to build up an object. Say we have a text file, called data.txt, that looks like this:

    Mark Johnson    waffle iron    80   2
    Mark Johnson    blender 200   1
    Mark Johnson    knife   10   4
    Nikita Smith    waffle iron    80   1
    Nikita Smith    knife   10   2
    Nikita Smith    pot   20   3  


And we want it to look like this:

    {
      "Mark Johnson": [
        {
          "name": " waffle iron",
          "price": " 80",
          "quantity": "2"
        },
        {
          "name": " blender 200",
          "price": "1"
        },
        {
          "name": " knife",
          "price": "10",
          "quantity": "4"
        }
      ],
      "Nikita Smith": [
        {
          "name": " waffle iron",
          "price": " 80",
          "quantity": "1"
        },
        {
          "name": " knife",
          "price": "10",
          "quantity": "2"
        },
        {
          "name": " pot",
          "price": "20",
          "quantity": "3"
        }
      ]
    }

Then we use:

    //import fs from 'fs';  //es6
    var fs = require('fs')

    var output = fs.readFileSync('data.txt', 'utf8')
        .trim()
        .split('\r\n')
        .map( (line) => line.split("   ") )
        .reduce( (customers, line) => {
            customers[line[0]] =  customers[line[0]] || []  //creates the two top level properties, reusing it if it exists
            customers[line[0]].push({
                name: line[1],
                price: line[2],
                quantity: line[3]
                })
            return customers
        }, {})

    console.log(JSON.stringify(output, null, 2))



Note that we needed a return state for the object to be passed on to the next iteration. We also had to use square bracket notation for the object because the object keys are being dynamically created. Importantly, if the key had already been created by reduce() then it was just over written (this is how we reduce multiples of the two customer names). 


Hash Example using bitwise operator <<
--------------------------------------------


function makeHash(source) {
  var hash = 0;
  if (source.length === 0) return hash;
  for (var i = 0; i < source.length; i++) {
    var char = source.charCodeAt(i);
    hash = ((hash<<5)-hash)+char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}



Reading Files with FileReader
--------------------------------------------

The FileReader interface provides a number of asynchronous methods that can be used to read either File or Blob objects (a Binary Large OBject (BLOB) is a collection of binary data stored as a single entity in a database management system. Blobs are typically images, audio or other multimedia objects, though sometimes binary executable code is stored as a blob). 

    var reader = new FileReader();          // create a new instance of FileReader


Because we use asynchronous methods we need to setup an event listener for when the file has finished loading. When the onload event is called we can examine the result property of our FileReader instance to get the file’s contents. You will need to use this same approach for all of the read methods provided by FileReader.

ReadAsText method:

    var reader = new FileReader();

    reader.onload = function(e) {
      var text = reader.result;
    }

    reader.readAsText(file, encoding);


[aside on HTML image elements and Data URIs :   

The <img> tag defines an image in an HTML page. It has two required attributes: src and alt. 
    eg: <img src="smiley.gif" alt="Smiley face" width="100" height="100"></img>

It's not necessary to link to an external image file when using <img>.  You can embed the image data directly into the document with data URIs.

With CSS, it looks like this:

    li {
      background:
        url(data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7)
        no-repeat
        left center;
      padding: 5px 0 5px 25px;
    }

With HTML, it looks like this:

    <img width="16" height="16" alt="star" src="data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7" />

The format, to be specific:

    data:[<mime type>][;charset=<charset>][;base64],<encoded data>

Basically, a super long string of gibberish characters. It's not gibberish to the browser though of course. This data is interpreted as the type of file you are saying it is. The basic advatage is that it saves on http requests.

Online conversion tool: http://jpillora.com/base64-encoder/

]


readAsDataURL() method:

The readAsDataURL() method takes in a File or Blob and produces a data URL. You can use this data URL for things like setting the src property for an image. 

    var reader = new FileReader();

    reader.onload = function(e) {
      var dataURL = reader.result;
    }

    reader.readAsDataURL(file);


Other methods include readAsBinaryString(), readAsArrayBuffer(), and abort(). Abort will stop the load operation and is handy for large files. See http://blog.teamtreehouse.com/reading-files-using-the-html5-filereader-api . This page also has an indepth example.







JSON: Javascript Object Notation
--------------------------------------------

JSON (JavaScript Object Notation) is an open-standard format that uses human-readable text to transmit data objects consisting of attribute–value pairs. JSON is a language-independent data format. It derives from JavaScript object literal notation, but code to generate and parse JSON-format data is available in many programming languages. It has largely superceeded XML. Since XML uses tags as property names (similar to HTML) then a lot of bandwidth is wasted sending each property name twice (closing tags).

JSON is a way to store information in an organized, easy-to-access manner. In a nutshell, it gives us a human-readable collection of data that we can access in a really logical manner. JSON allows sites to be able to load data quickly and asynchronously, or in the background without delaying page rendering. Switching up the contents of a certain element within our layouts without requiring a page refresh adds a "wow" factor to our applications, not to mention the added convenience for our users.

JSON can be represented as either a list of values, e.g. an Array, or a hash of properties and values, e.g. an Object. YAML is a super-standard; it includes JSON. Object properties must be wrapped in quotes, which is optional is JS. So JSON is technically a subset of JS object literal syntax; JSON is sricter.

JSON allows us to store all out information in one structure. This then also allows us to have just one variable to represent that data.

    // a JSON array
    ["one", "two", "three"]
    
    // a JSON object
    { "one": 1, "two": 2, "three": 3 }
    
    //mixed example, in which all the data is assigned to one variable:
    
    var thePets = [
        {
            "name": "Meowsalot",
            "species": "cat",
            "favFood": "tuna"
        },
        {
            "name": "Barky",
            "species": "dog",
            "favFood": "carrots"
        }
    ]


However, the array style is beneficial because it allows us to loop through stored information with an incrementing value.

In the real world you normally wont have a JSON file already in existance. Usually you will obtain the JSON file from a dynamic URL like a database. This is where AJAX comes in - see the next section.

Javascript provides 2 methods for encoding data structures to json and encoding json back to javascript objects and arrays. They are both available on the JSON object that is available in the global scope.

JSON.stringify takes a javascript object or array and returns a serialized string in the JSON format.

var data = {
  name: "John Doe"
  , age: 32
  , title: "Vice President of JavaScript"
}

var jsonStr = JSON.stringify(data);

console.log(jsonStr);

// prints '{"name":"John Doe","age":32,"title":"Vice President of JavaScript"}'
JSON.parse takes a JSON string and decodes it to a javascript data structure.  //otherwise you get a lot os useless {object, object} stuff.

Stringify can also take extra arguments which aid in formatting. eg JSON.stringify(/* object */, undefined, "  "), which spaces out the string based on what a tab should be read as, which in this case is several spaces.

var jsonStr = '{"name":"John Doe","age":32,"title":"Vice President of JavaScript"}';

JSON.parse takes a string and coverts it to a JSON object:

var data = JSON.parse(jsonStr);

console.log(data.title);

// prints 'Vice President of JavaScript'


There are a few rules to remember when dealing with data in JSON format. There are several gotchas that can produce invalid JSON as well.

Empty objects and arrays are okay
Strings can contain any unicode character, this includes object properties
null is a valid JSON value on it's own
All object properties should always be double quoted
Object property values must be one of the following: String, Number, Boolean, Object, Array, null
Number values must be in decimal format, no octal or hex representations
Trailing commas on arrays are not allowed
These are all examples of valid JSON.

{"name":"John Doe","age":32,"title":"Vice President of JavaScript"}

["one", "two", "three"]

// nesting valid values is okay
{"names": ["John Doe", "Jane Doe"] }

[ { "name": "John Doe"}, {"name": "Jane Doe"} ]

{} // empty hash

[] // empty list

null

{ "key": "\uFDD0" } // unicode escape codes


These are all examples of bad JSON formatting:

{ name: "John Doe", 'age': 32 } // name and age should be in double quotes

[32, 64, 128, 0xFFF] // hex numbers are not allowed

{ "name": "John Doe", age: undefined } // undefined is an invalid value

// functions and dates are not allowed
{ "name": "John Doe"
  , "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT')
  , "getName": function() {
      return this.name;
  }
}
Calling JSON.parse with an invalid JSON string will result in a SyntaxError being thrown. If you are not sure of the validity of your JSON data, you can anticipate errors by wrapping the call in a try/catch block.

Notice that the only complex values allowed in JSON are objects and arrays. Functions, dates and other types are excluded. This may not seem to make sense at first. But remember that JSON is a data format, not a format for transfering complex javascript objects along with their functionality.






AJAX
--------------------------------------


The process of sending or recieveing data "on the fly", without a page reload, is called AJAX. 

Web browsers have a built in tool called XMLHttpRequest. This tool does the "heavy lifting". It establishes a connection with the url, and then it lets us send or recieve data. 

We begin by creating a new instance of this tool (in our JavaScript code, such as main.js):

    var ourRequest = new XMLHttpRequest();   //new instance of the tool

    //now we tell the tool to do something. The "open" method is expected by the browser.
    //first arg: send or recieve data to a server (eg the http requests such as POST to send or GET to receive)
    //second arg: the url we wish to talk to.

    ourRequest.open('GET', 'https://learnwebcode.github.io/json-example/animals-1.json');  //gets the JSON data from the specified url.

    //No we say what we want to do with the data once it has been downloaded (in this case just display it in the console):
    
    ourRequest.onload = function() {
        console.log(ourRequest.responseText);
    }
    
    //The final step is to actually send the request
    ourRequest.send()



In the above example we displayed the data in the the console. Normally, however, we would assign the data to a variable within out anonimous function within .onload:

    ourRequest.onload = function() {
        var ourData = ourRequest.responseText;
    }
    
Gotcha: the ourData variable is not a JSON array; it is a string. If you try isolate one part of the data, say the first array element, you get unexpected results:

    ourRequest.onload = function() {
        var ourData = ourRequest.responseText;
        console.log(ourData[0]);                   // console shows: '['
    }

We only see a left side square bracket. This is the first character in the string.

So we need t




Scope and Hoisting
-------------------------------------
 
Scope basically means 'where can I access a variable?' or "where a variable is available in your code".

Primer example:

    function b() {console.log(myVar)}
    function a() {var myVar = 2; b()}
    var myVar = 1;
    a(); // 1 (i.e. not undefined and not 2)  // the same also occurs if we use 'let'

Recall that part of an execution context is a reference to the outside environment (another execution context). If you ask for a variable that has not been declared in the local execution context then the JS engine looks within the outer reference context. 

Here the b() execution context has a reference to the global execution context. The JS engine is bypassing the a() execution context in it's search for myVar's value. While the b() execution context does sit on top of the a() execution context, we say 'lexically' that the b() execution context actually sits on top of the global execution context. The b() 'lexical environment' sits next to the a() lexical environment. That is, both functions are declared at the same level in the same file. While b() is called inside a(), b() is not declared inside a().

So, the scope chain is a series of links of outer environment references.

Here we change the lexial environment for b() and see that myVar comes from a():

    function a() {function b() {console.log(myVar)}; var myVar = 2; b()}
    var myVar = 1;
    a(); // 2
    b(); // uncaught ReferenceError: b is not defined.

Again, three execution contexts were created, but b()'s outer reference changed. The scope chain has an extra step. b()'s context is not created until a()'s context is created. Since b's context was created inside a's context, b's outer reference is to a's execution context.


The main type of scope in Javascript is Lexical Scoping. Present in the language from the very beginning, this is the scope created within a function, and the one most developers are familiar with (traditionally functions were the only thing that could create a new scope). ES6 recently defined Block Scoping. This scope is created within curly braced blocks.

Lexical scope: 

var is used to denote a variable which is Lexically Scoped to the current
function:

    function someFunc() {
      var aVariable;
    }

(If var had not been used here then aVariable would have been on the global scope).    

aVariable is lexically scoped within someFunc

Block Scope:

let & const are used to denote variables which are Block Scoped to the
current curly braced block:

    if (true) {
      let aVariable;
    }

aVariable is block scoped within the if's curly braces. Unike var, if a variable is declared inside a block it is not available outside the block:

    console.log('Before the IF block d is: ', d)
    // console.log('Before the IF block c is: ', c)  // Uncaught ReferenceError: c is not defined

    if(a > b){var d; let c; console.log('c is now: ', c); c = true; console.log('c is now: ', c)}

    //Before the IF block d is:  undefined
    // c is now:  undefined
    // c is now:  true



There are also 4 other scopes in the language: Global, `with`, `catch`,and `eval`. These tend not to be used much.

Scopes can be nested. Both Lexical and Block scopes can contain other scopes. All nested scopes follow the same rule: each nested inner scope has access to outer scope variables, but NOT vice-versa. While we can look a scope as a tree, from the outer function down, it is more intuitive to start from the bottom up. This is because the bottom function has access to all the variables from the functions that surround it. Looking from most inner to most outer scope forms a Scope Chain.

Understanding where Scope Chains end is an important part of scoping. All Javascript runtimes must implicitly create a Global Scope object (window in the browser, global in node), which sits at the top of every scope chain.

When assigning a variable without using either of var,
let, etc, the variable is assumed to exist in an outer scope.

The javascript runtime follows these steps to assign a variable:

 1) Search within the current scope.
 2) If not found, search in the immediately outer scope.
 3) If found, go to 6.
 4) If not found, repeat 2. Until the Global Scope is reached.
 5) If not found in Global Scope, create it (on window / global objects).
 6) Assign the value.

In this way, it is possible to accidentally define a global variable (step 5).So remember to use var or let when defining a variable.

Shadowing:

It is also valid to do this in nested scopes:

    function someFunc() {
       var foo = 1;
       function inner() {
          var foo = 2;
       }
    }

This is called Shadowing. The foo inside inner() is said to Shadow the foo inside someFunc.

Shadowing means that the inner() scope only has access to its own foo. There is no way for it to access the foo defined in someFunc(). This can also be an accidental source of bugs, especially when there is deep nesting, or long functions.

A variable’s scope is the context in which the variable exists. JavaScript variables can belong to the local or global scope. Private variables can be made possible with closures (see the closures section; A "closure" is an expression (typically a function) that can have free variables together with an environment that binds those variables (that "closes" the expression)).

In JavaScript, objects and functions are also variables. In JavaScript, scope is the set of variables, objects, and functions you have access to. JavaScript has function scope: the scope changes inside functions. In JavaScript, functions are the only way to create new scope. Also, functions have access to the scope "above" them. In fact generally, lexical scope rules say that code in one scope can access variables of either that scope or any scope ***outside*** of it. (see below on closures).

Variables declared within a JavaScript function, become LOCAL to the function (ie we have used var, let or const). Local variables have local scope: They can only be accessed within the function. If you attempt to do otherwise you will get an 'undefined' object. Locally initialised variables have priority over global variables.

A variable declared outside a function, becomes GLOBAL. A global variable has global scope: All scripts and functions on a web page can access it. (see more on Closures for accessing variables in outer functions from inner functions). For typical applications the global scope is the window object, or the entire HTML document. Variables created without the keyword var, are always global, even if they are created inside a function.

The lifetime of a JavaScript variable starts when it is declared. Local variables are deleted when the function is completed. Global variables are deleted when you close the page.

You use the var keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function.


Simple example:

var name = "Richard";

function showName () {
	var name = "Jack";      // local variable; only accessible in this showName function
	console.log (name);         // Jack
}
console.log (name);         // Richard: the global variable


Since a nested function is also within the scope of an outer function, the inner function can access the variable from both functions:

function outer() {
    var a = 1;

    function inner() {
        var b = 2;

        // we can access both `a` and `b` here
        console.log( a + b );   // 3
    }

    inner();

    // we can only access `a` here
    console.log( a );           // 1
}

outer();

So, code inside the inner() function has access to both variables a and b, but code in outer() has access only to a -- it cannot access b because that variable is only inside inner().

Identifier resolution starts with the first object in the scope chain. It is checked to see if it has a property with a name that corresponds with the identifier. Because the scope chain is a chain of objects this checking encompasses the prototype chain of that object (if it has one). If no corresponding value can be found on the first object in the scope chain the search progresses to the next object. And so on until one of the objects in the chain (or one of its prototypes) has a property with a name that corresponds with the identifier or the scope chain is exhausted.



Nested Functions and the Counting dilemma  (Nested Scope):



When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes. For example:

    function foo() {
        var a = 1;
    
        function bar() {
            var b = 2;
    
            function baz() {
                var c = 3;
    
                console.log( a, b, c ); // 1 2 3
            }
    
            baz();
            console.log( a, b );        // 1 2
        }
    
        bar();
        console.log( a );               // 1
    }
    
    foo();

Notice that c is not available inside of bar(), because it's declared only inside the inner baz() scope, and that b is not available to foo() for the same reason.

If you try to access a variable's value in a scope where it's not available, you'll get a ReferenceError thrown. If you try to set a variable that hasn't been declared, you'll either end up creating a variable in the top-level global scope (bad!) or getting an error, depending on "strict mode" (see "Strict Mode").

ES6 lets you declare variables to belong to individual blocks (pairs of { .. }), using the let keyword. Besides some nuanced details, the scoping rules will behave roughly the same as we just saw with functions:

    function foo() {
        var a = 1;

        if (a >= 1) {
            let b = 2;

            while (b < 5) {
                let c = b * 2;
                b++;

                console.log( a + c );
            }
        }
    }

    foo();
    // 5 7 9

Because of using let instead of var, b will belong only to the if statement and thus not to the whole foo() function's scope. Similarly, c belongs only to the while loop. Block scoping is very useful for managing your variable scopes in a more fine-grained fashion, which can make your code much easier to maintain over time.

Variables declared by let have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function.

    function varTest() {
      var x = 1;
      if (true) {
        var x = 2;  // same variable!
        console.log(x);  // 2
      }
      console.log(x);  // 2
    }

    function letTest() {
      let x = 1;
      if (true) {
        let x = 2;  // different variable
        console.log(x);  // 2
      }
      console.log(x);  // 1
    }


let allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope.

let will hoist the variable declaration to the top of the block, but not the initialization:

    function do_something() {
      console.log(bar); // undefined
      console.log(foo); // ReferenceError: foo is not defined
      var bar = 1;
      let foo = 2;
    }



Counting dilemma: 

If we globally declare a counting variable then any code could modify the count and cause a bug:

    var counter = 0;
    
    function add() {
        counter += 1;
    }
    
    add();
    add();
    add();

So if we really only want the add() function to modify this variable then we might consider making count local:

    function add() {
        var counter = 0;
        counter += 1;
    }
    
    add();
    add();
    add();

However now count is deleted every time add() completes, so we only get a count of 1 after three calls. The work around is an inner function. Nested functions have access to the scope "above" them. In the next example, the inner function plus() has access to the counter variable in the parent function:

    function add() {
        var counter = 0;
        function plus() {counter += 1;}
        plus();    
        return counter; 
    }

This could have solved the counter dilemma, if we could reach the plus() function from the outside. We also need to find a way to execute counter = 0 only once. We need a closure (see the closures section; the nested function definition is returned from outer function).

    var add = (function () {
        var counter = 0;
        return function () {return counter += 1;}  //this increments and returns the result of the incrementation.
    })();
    
    add();
    add();
    add();     //counter is now 3


The variable add is assigned the return value of a self-invoking function. The self-invoking function only runs once. It sets the counter to zero (0), and returns a function expression. This way add becomes a function. The "wonderful" part is that it can access the counter in the parent scope. This is called a JavaScript closure. It makes it possible for a function to have "private" variables. The counter is protected by the scope of the anonymous function, and can only be changed using the add function.

{Aside: we did not need an IIFE. This still works:

    function outer() {
        var counter = 0;
        return function () {return counter += 1;}  
    };

    var add2 = outer();

    add2(); // 1
    add2{}; // 2
}


Aidan's nice click-counting example solves this problem using setters and getters (ie. Object orientated programming). It also does not require a self-invoking function:


    <!DOCTYPE html>
    <html>
    <body>
    
    <p>Counting with a local variable.</p>
    
    <button type="button" onclick="myFunction()">Count!</button>
    
    <p id="demo">0</p>
    
    <script>
    
    function counterFactory() {
        var counter = 0;
    
        var counterObject = {
          set: function (newValue) { 
            counter = newValue;
          },
          get: function() { return counter; },
          inc: function(amount) { counter += amount; }
        };
    
        return counterObject;
    }
    
    var counterObj = counterFactory(); //self-invoking function not necessary because we have a named function definition
    
    function myFunction(){
        counterObj.inc( Math.floor(10 * Math.random()) );
        document.getElementById("demo").innerHTML = counterObj.get();
    }
    </script>
    
    </body>
    </html>


A closure is a nested function having access to the parent scope, even after the parent function has closed (see the Closures section).





More scope examples:


A little more complicated (non-block level scope so that a change in an if stmt effects a global variable):

var name = "Richard";
// the blocks in this if statement do not create a local context for the name variable
if (name) {
	name = "Jack"; // this name is the global name variable and it is being changed to "Jack" here
	console.log (name); // Jack: still the global variable
}

// Here, the name variable is the same global name variable, but it was changed in the if statement
console.log (name); // Jack


Similarly (ie non-blocking example again):

// Both firstName variables are in the global scope, even though the second one is surrounded by a block {}. 
var firstName = "Richard";
{
var firstName = "Bob";
}

So curly brackets, {}, on their own, do not affect scope [only within objects like functions then?].

Lastly on non-blocking, we see that a varable declared in a for loop is global:

for (var i = 0; i<=10; i++){                    //this also works nont declaring i (as discussed below): for (i = 0; i<=10; i++){
};
function aNumber(){ console.log(i)};
aNumber();                          //11




Watch out for undeclared local variables that share the same name with a global variable. We may accidentially modify a global variable:


var my_number = 7;                              //this has global scope

var timesTwo = function(number) {
    my_number = number * 2;                                      
    console.log("Inside the function my_number is: ");
    console.log(my_number);                                 //6
}; 

timesTwo(7);

console.log("Outside the function my_number is: ")              
console.log(my_number);                                             //6 (if we put a var on my_number within timesTwo line we get no naming conflict)




If a variable is initialized (assigned a value) without first being declared with the var keyword, it is automatically added to the global context and it is thus a global variable:

function showAge () {
	
	age = 90; // Age is a global variable because it was not declared with the var keyword inside this function
	console.log(age);  // 90
}

showAge (); // 90

console.log(age); // 90 Age is in the global context, so it is available here, too





Function arguments (parameters) work as local variables inside functions. 



With JavaScript, the global scope is the complete JavaScript environment. In HTML, the global scope is the window object. That is, in HTML, all global variables will become window variables. All global variables belong to the window object:


<script>
var carAge = 12;
myFunction();
document.getElementById("demo").innerHTML =
"I can display " + window.adjAge;

function myFunction() {
    adjAge = carAge+2;    //accessing the carAde global variable here. adjAge is first declared here so is also global.
}
</script>

Your global variables (or functions) can overwrite window variables (or functions). Any function, including the window object, can overwrite your global variables and functions.




Hoisting:



Hoisting is JavaScript's default behavior of moving declarations to the top of the current scope. All variable declarations are hoisted (lifted and declared) to the top of the function, if defined in a function, or the top of the global context, if outside a function.

It is important to know that only variable declarations are hoisted to the top, not variable initialization or assignments (when the variable is assigned a value).

Example:

    b();
    console.log(a);

    var a = 'Hello World!';

    function b() {
        console.log('Called b!')
    }

    // called b! - declaration of a function moved to the top of the current scope
    // undefined - the declaration of a is hoisted but not its assignment.
    // (if we had deleted the line var a = 'Hello World!'; then we would have generated not defined error)


Example:


    var a = 2;

    foo();                  // works because `foo()`
                            // declaration is "hoisted"
    
    function foo() {
        a = 3;
    
        console.log( a );   // 3
    
        var a;              // declaration is "hoisted"
                            // to the top of `foo()`
    }
    
    console.log( a );   // 2



Example:


function showName () {
    console.log ("First Name: " + name);   // First Name: undefined
    var name = "Ford";
    console.log ("Last Name: " + name);     // Last Name: Ford
}
showName (); 


This is how the above code is processed by the JavaScript engine:


function showName () {
	var name;                               // name is hoisted (note that is undefined at this point, since the assignment happens below)
    console.log ("First Name: " + name);  // First Name: undefined

    name = "Ford"; // name is assigned the value Ford

    console.log ("Last Name: " + name); // Last Name: Ford
}


Both function declaration and variable declarations are hoisted to the top of the containing scope. And function declaration takes precedence over variable declarations (but not over variable assignment). As is noted above, variable assignment is not hoisted, and neither is function assignment.


// Here both the variable and the function are named myName, and the function declaration overrides the variable name.
var myName;
function myName () {
    console.log ("Rich");
}

console.log(typeof myName); // function


However, in this example, the variable assignment overrides the function declaration:

var myName = "Richard";    //the variable is not just declared first, but also initialised.

function myName(){
    console.log("Rich");
}

console.log(typeof myName); // string


Also, fuction expressions (as opposed to function declarations) are not hoisted:

var myName = function () {
    console.log ("Rich");
} 


In strict mode, an error will occur if you assign a variable a value without first declaring the variable. Always declare your variables.

Hoisting is actually related to the work the JS engine does in setting up the execution context. Hoisting is the creation step where the engine sets up enough memory space for variables and functions within the context. It parses the file and brings all declarations to the front of the file, and sets the value of all these declared variables as undefined.




Closures (see also Currying and Callbacks [which are examples of closures])
-------------------------------------------

The simplest example of a closure is this:

    var a = 10;
    function test() {
      console.log(a); 
      console.log(b); 
    }
    var b = 6;
    test();  // will output 10 and then 6 on another line

That is, every JS function creates a closure!

A closure is the combination of a function and the lexical environment within which that function was declared:    
    
    function greet(whatToSay) {
        return function(name) {
            console.log(whatToSay + ' ' + name)
        }
    }
    const hiFunc = greet('Hi);
    hiFunc('Joseph'); // Hi Joseph
    hiFunc('Dad'); // Hi Dad
    greet('Hey')('Joseph');  // Hey Joseph

The function 'greet' has finished executing and has come off the executon stack. Yet, 'whatToSay' still exists. The variable 'whatToSay' was sitting in the variable environment in the greet execution context. And all execution contexts occupy a place in memory. Normally a finished context is garbage collected.

When hiFunc is called it enters it's own execution context. It's local variable is 'name'. However, it has a reference to 'whatToSay'. Since it can't find it locally it begins to look up the scope chain. It turns out that the hiFunc execution context still has an outer reference to it's lexical environemnt (where it sits in the code). So while the 'greet' execution context is gone from the stack, the contents of the variable environment still exist. The JS engine makes sure that it stays there for hiFunc to find. 

So we can now say the the hiFunc execution context has 'closed in' it's outer variables. The scope chain still holds when the execution context is gone. A closure is a functions execution context (and all that that context holds) plus the variables in it's scope chain.

Here is a very interesting example in which we see that the value assigned to a scope variable can update before final invocation:

    function buildFunctions() {
        let arr = [];
        for(var i = 0; i < 3; i++) {
            arr.push(
                function() {
                    console.log(i)
                }
            )
        }
        return arr;  
    }

    const fs = buildFunctions();
    fs[0]();
    fs[1]();
    fs[2]();

    // 3
    // 3
    // 3  all three execution contexts have the same 'i' in their scope chain, and 'i' is now 3 because the loop has finished.

However, if you use 'let' instead of 'var' for the loop variable, the value is also baked in. 'let' variables are scopped to the block.

Another work around is to use an IIFE to create a new execution context for each loop variable:

        arr.push(
            (function(j) {
                return function(j){
                    console.log(j)
                }
            })(i);
        )

When the array element function looks for j it will first go and look in the IIFE's environment variables and part of the scope chain. 

Closures provide an excellent mechanism for handling the asynchronous nature of most Javascript tasks. They rely upon the scope chain and nesting (see the Scope section); any variable declared in a parent scope is available to the inner scope. If the inner scope remains unexecuted it's scope is closed over those original variables from the parent scope. However, this does have interesting implications for memory (see Garbage Collection).

A closure is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result. As such it is a way of supporting first class functions. Another way to see a closure is as a stack frame which is allocated when a function starts its execution, and not freed after the function returns (as if a 'stack frame' were allocated on the heap rather than the stack!).

A "closure" is an expression (typically a function) that can have free variables together with an environment that binds those variables (that "closes" the expression). A closure is formed by returning a function object that was created within an execution context of a function call from that function call and assigning a reference to that inner function to a property of another object. Or by directly assigning a reference to such a function object to, for example, a global variable, a property of a globally accessible object or an object passed by reference as an argument to the outer function call

The simple explanation of a Closure is that ECMAScript allows inner functions; function definitions and function expressions that are inside the bodies of other functions. And that those inner functions are allowed access to all of the local variables, parameters and declared inner functions within their outer function(s). A closure is formed when one of those inner functions is made accessible outside of the function in which it was contained, so that it may be executed after the outer function has returned. At which point it still has access to the local variables, parameters and inner function declarations of its outer function. Those local variables, parameter and function declarations (initially) have the values that they had when the outer function returned and may be interacted with by the inner function.

You can think of closure as a way to "remember" and continue to access a function's scope (its variables) even once the function has finished running. More specifically, a closure is a nested function having access to the parent scope, even after the parent function has closed. There are many other circumstances when a reference to a function object is assigned so that it would be executed at some future time where it is useful to provide parameters for the execution of that function that would not be easily available at the time of execution but cannot be known until the moment of assignment. [We might have the variables available for the outer function but we do not yet have the variables fixed for the inner function. So we return the inner function with the outer variables locked in for later.]

The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables. The closure also as access to the outer function’s parameters (although note that the inner function cannot call the outer function’s arguments object).

A closure is more than a nested function. Closures are nested functions that continue to live even when the outer function has completed is closure. The day-to-day way in which we are able to see closure is callbacks. Callbacks are functions which are usually executed when an event completes. When they are executed they have access to outer functions variables even though the outer function has completed its execution.

For a simple example see the counting dillemma in the scope section. Consider also this:


    function sayHello2(name) {
      var text = 'Hello ' + name; // Local variable
      var say = function() { console.log(text); }
      return say;
    }
    var say2 = sayHello2('Bob');
    say2(); // logs "Hello Bob"

The above code has a closure because the anonymous function function() { console.log(text); } is declared inside another function, sayHello2(). In JavaScript, if you use the function keyword inside another function, you are creating a closure. In C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. In JavaScript, if you declare a function within another function, then the local variables can remain accessible after returning from the function you called. This is demonstrated above, because we call the function say2() after we have returned from sayHello2(). Notice that the code that we call references the variable text, which was a local variable of the function sayHello2(). The anonymous function can reference text which holds the value 'Hello Bob' because the local variables of sayHello2() are kept in a closure.  In JavaScript a function reference also has a secret reference to the closure in which it was created.

This example shows that the local variables are not copied — they are kept by reference [really?????; looks like the value is baked in]:

    function say667() {
      // Local variable that ends up within closure
      var num = 42;
      var say = function() { console.log(num); }
      num++;
      return say;
    }
    var sayNumber = say667();

    sayNumber(); // logs 43
    // my testing: 
    sayNumber(); // logs 43
    sayNumber(); // logs 43
    var sayNumber2 = say667();
    sayNumber2(); // log 43  [The "closure" is the value of the variables as they were when the outside function finished; they are locked in. These variables also include those that are declared after the inner function is delcared or worked upon, as in the next example. It is also possible to have variables update; see newClosure() below.]

This example shows that the closure contains any local variables that were declared inside the outer function before it exited.

    function sayAlice() {
        var say = function() { console.log(alice); }
        // Local variable that ends up within closure
        var alice = 'Hello Alice';
        return say;
    }
    sayAlice()();// logs "Hello Alice"

Note that the variable alice is actually declared after the anonymous function. The anonymous function is declared first; and when that function is called it can access the alice variable because alice is in the same scope (JavaScript does variable hoisting). Also sayAlice()() just directly calls the function reference returned from sayAlice() — it is exactly the same as what was done previously, but without the temporary variable.


The next example is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure do not act as you might first think.

    function buildList(list) {
        var result = [];
        for (var i = 0; i < list.length; i++) {
            var item = 'item' + i;
            result.push( function() {console.log(item + ' ' + list[i])} );
        }
        return result;
    }

    function testList() {
        var fnlist = buildList([1,2,3]);
        // Using j only to help prevent confusion -- could use i.
        for (var j = 0; j < fnlist.length; j++) {
            fnlist[j]();
        }
    }

     testList() //logs "item2 undefined" 3 times  //for a fix see http://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17200991#17200991 (pull the loop and array creation outside of buildlist)


In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again each time the outside function is called. Here "item2 undefined" is alerted three times because there is only one closure for the local variables for buildList. When the anonymous functions are called on the line fnlist[j](); they all use the same single closure, and they use the current value for i and item within that one closure (where i has a value of 3 because the loop had completed, and item has a value of 'item2'). Note we are indexing from 0 hence item has a value of item2. And the i++ will increment i to the value 3.

This example shows that each call creates a separate closure for the local variables. There is not a single closure per function declaration. There is a closure for each call to a function.

    function newClosure(someNum, someRef) {
        // Local variables that end up within closure
        var num = someNum;
        var anArray = [1,2,3];
        var ref = someRef;
        return function(x) {
            num += x;
            anArray.push(num);
            console.log('num: ' + num +
                '; anArray: ' + anArray.toString() +
                '; ref.someVar: ' + ref.someVar + ';');
          }
    }
    obj = {someVar: 4};
    fn1 = newClosure(4, obj);
    fn2 = newClosure(5, obj);
    fn1(1); // num: 5; anArray: 1,2,3,5; ref.someVar: 4;
    fn2(1); // num: 6; anArray: 1,2,3,6; ref.someVar: 4;
    obj.someVar++;
    fn1(2); // num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;
    fn2(2); // num: 8; anArray: 1,2,3,6,8; ref.someVar: 5;

Some summary points:

- Whenever you use function inside another function, a closure is used.
- Whenever you use eval() inside a function, a closure is used. The text you eval can reference local variables of the function, and within eval you can even create new local variables by using eval('var foo = …')
- When you use new Function(…) (the Function constructor) inside a function, it does not create a closure. (The new function cannot reference the local variables of the outer function.)
- A closure in JavaScript is like keeping a copy of all the local variables, just as they were when a function exited.
- A new set of local variables is kept every time a function with a closure is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way).
- Two functions might look like they have the same source text, but have completely different behaviour because of their 'hidden' closure.
- It is possible to get function declarations within function declarations within functions — and you can get closures at more than one level.
- I think normally a closure is the term for both the function along with the variables that are captured


JavaScript always uses references when dealing with objects. If say, you called foo with an object, the closure it returns will reference that original object!

    function foo(x) {
      var tmp = 3;

      return function (y) {
        console.log(x + y + tmp);
        x.memb = x.memb ? x.memb + 1 : 1;
        console.log(x.memb);
      }
    }

    var age = new Number(2);
    var bar = foo(age); // bar is now a closure referencing age.
    bar(10);

As expected, each call to bar(10) will increment x.memb. What might not be expected, is that x is simply referring to the same object as the age variable! After a couple of calls to bar, age.memb will be 2! This referencing is the basis for memory leaks with HTML objects.


Closures are used extensively in Node.js; they are workhorses in Node.js’s asynchronous, non-blocking architecture. 

Example:

    function exampleClosureForm(arg1, arg2){
        var localVar = 8;
        function exampleReturned(innerArg){
            return ((arg1 + arg2)/(innerArg + localVar));
        }
        /* return a reference to the inner function defined as -
           exampleReturned:
        */
        return exampleReturned;
    }

    var globalVar = exampleClosureForm(2, 4);

    typeof globalVar      // "function"

    globalVar(-2)   // 1


Now the function object created within the execution context of the call to exampleClosureForm cannot be garbage collected because it is referred to by a global variable and is still accessible, it can even be executed with globalVar(n). 

(aside:

ECMAScript uses automatic garbage collection. The general idea is that if an object becomes un-referable (by having no remaining references to it left accessible to executing code) it becomes available for garbage collection and will at some future point be destroyed and any resources it is consuming freed and returned to the system for re-use. This would normally be the case upon exiting an execution context. 

)

If the exampleClosureForm function was called again as:

    var secondGlobalVar = exampleClosureForm(12, 3);

A new execution context would be created and a new function object would be returned, with its own distinct scope chain 

If we execute secondGlobalVar again a new Activation object will appear at the front of the scope chain but the remainder of the scope chain will be used again in the resolution of the identifiers arg1, arg2 and localVar.

Another Example:

    function makeAdder(x) {
        // parameter `x` is an inner variable
    
        // inner function `add()` uses `x`, so
        // it has a "closure" over it
        function add(y) {
            return y + x;
        };
    
        return add;  //note that 'add' has not been executed; only the reference has been returned. 
    }

The reference to the inner add(..) function that gets returned with each call to the outer makeAdder(..) is able to remember whatever x value was passed in to makeAdder(..). Now, let's use makeAdder(..):


    // `plusOne` gets a reference to the inner `add(..)`
    // function with closure over the `x` parameter of
    // the outer `makeAdder(..)`
    
    var plusOne = makeAdder( 1 );  //add(..) remembers x as 1. We call this function reference plusOne(..)
    
    //When we call makeAdder(10), we get back another reference to its inner add(..) that remembers x as 10. 
    // We call this function reference plusTen(..).
    
    var plusTen = makeAdder( 10 );
    
    plusOne( 3 );       // 4  <-- 1 + 3
    plusOne( 41 );      // 42 <-- 1 + 41
    
    plusTen( 13 );      // 23 <-- 10 + 13


A similar example:

    function celebrityName (firstName) {
        var nameIntro = "This celebrity is ";
        
        function lastName (theLastName) {
            return nameIntro + firstName + " " + theLastName; // this inner function has access to the outer function's variables, including the parameter
        }
        return lastName;                  //No parenthsis here; only the inner function definition is being return, and it has not been executed.
    }
    
    var mjName = celebrityName ("Michael"); // At this juncture, the celebrityName outer function has returned the inner function definition with Michael "pre loaded"
    
    console.log(mjName);   //displays the lastName function (the closure) in the console. So when we call mjName below, its argument is actually used as the theLastName parameter.
    
    // The closure (lastName) is called here after the outer function has returned above
    // Yet, the closure still has access to the outer function's variables and parameter
    mjName ("Jackson"); // This celebrity is Michael Jackson



A simpler example with the inner function being called upong execution of the return statement:


    function showName (firstName, lastName) {
    
        var nameIntro = "Your name is ";
  
  
        function makeFullName() {        
            return nameIntro + firstName + " " + lastName;   // the inner function has access to the outer function's variables, including the parameters
    }
        return makeFullName();      //[parenthesis, (), inducates the inner function is being executed]
    }
    
    showName ("Michael", "Jackson"); // Your name is Michael Jackson


Closures store references to the outer function’s variables; they do not store the actual value. Closures get more interesting when the value of the outer function’s variable changes before the closure is called.

Because closures have access to the updated values of the outer function’s variables, they can also lead to bugs when the outer function’s variable changes with a for loop. To fix this side effect (bug) in closures, you can use an Immediately Invoked Function Expression (see above on IIFE).


Practical example; Modules [there is a module section; I'm not sure what kind of module we are talking about here]:

The most common usage of closure in JavaScript is the module pattern. Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that is accessible from the outside.

In the next example, the User() function serves as an outer scope that holds the variables username and password, as well as the inner doLogin() function; these are all private inner details of this User module that cannot be accessed from the outside world.


    function User(){
        var username, password;

        function doLogin(user,pw) {
            username = user;
            password = pw;

        // do the rest of the login work
        }

        var publicAPI = {
            login: doLogin
        };

        return publicAPI;
    }

    // create a `User` module instance
    var fred = User();

    fred.login( "fred", "12Battery34!" );

Warning: We are not calling new User() here, on purpose, despite the fact that probably seems more common to most readers. User() is just a function, not a class to be instantiated, so it's just called normally. Using new would be inappropriate and actually waste resources.

Executing User() creates an instance of the User module -- a whole new scope is created, and thus a whole new copy of each of these inner variables/functions. We assign this instance to fred. If we run User() again, we'd get a new instance entirely separate from fred.

The inner doLogin() function has a closure over username and password, meaning it will retain its access to them even after the User() function finishes running.

For more complex examples and the bug-issue of accidental closures see http://jibbering.com/faq/faq_notes/closures.html#clResO 


Closures example: function factories

A factory is a function that makes things for you. A function factory makes functions. 

funciton makeGreeting() {
    return function(firstName, lastName) {
        if(language = 'en') {
            console.log('Hello ' + firstName + ' ' + lastName);
        } 
        if(language = 'es') {
            console.log('Hola ' + firstName + ' ' + lastName);
        } 
    }
}

var greetEnglish = makeGreeting('en');
var makeSpanish =  makeGreeting('es');

Here, the language variable is not passed to the inner function, only the outer function. Language is collected as part of the closure rather than just the inner the function. However, the two resultant functions do look up the same scope chain. They arrise from different execution contexts. The outer function, makeGreeting, was called twice. Each time a new execution context was made, with their own variable environments that are now kept in memory as part of a scope chain.

Callback example:

    function sayHiLater() {
        var greeting = 'Hi!';
        setTimeout(function() {
            console.log(greeting);
        },3000)
    }

    sayHiLater(); // three second later: 'Hi!';

This example demonstates a number of JS freatures. setTimeout takes an anonyous function as an argument: anonymous functions, functions as first class values, function expressions. sayHiLater actually executes and closes before the greeting is logged in the console. So setTimeout stays in existance waiting for 3 seconds (asynchronus) and has access to greeting as part of a closure. Lastly, we also see a callback. When setTimeout has done something (waited for three seconds by regeristering an event in the event queue) then it exectutes a callback function. A callback function is "A function you give to another function to be run when the other function is finished". So the function you call (ie invoke) 'calls back' by calling the function you gave it when it is finished. 


Garbage Collection
-------------------------------

Memory in Javascript is managed automatically by the runtime. The runtime
decides when/if to release any allocated memory. This decision process is called
Garbage Collection.

Every javascript runtime has their own algorithm for garbage collection, but
most use a variation of Mark & Sweep. The Mark & Sweep algorithm works by
marking references to memory (variables, functions, etc) which are still
reachable from active code. Any reference which is not marked, is swept into
the garbage (i.e. the memory is freed).

This concept of marking reachable memory is particulary relevant to closures:

     someFunc()
      var bar
    return inner
         ↑
         |
      inner()
     alert(bar)
         ↑
         ⋮

When the closure inner() is returned from someFunc(), it maintains its
reference to bar. The Mark & Sweep algorithm will mark bar as reachable, and
hence will not garbage collect it.

For inner() to correctly resolve its reference to bar, not only does the
memory for bar need to be kept, but the scope chain which describes how to
reach bar must also be kept.

Once the reference to inner() is no longer required, it can be marked for
garbage collection, which in turn means bar can also be marked, and finally
the entire scope chain can be marked, resulting in the freeing of all the
memory.

In this way, Scope, Scope Chains, Closures, and Garbage Collection are all
closely related.

One particularly interesting thing of note is the length of time Garbage
Collection can take: Often well beyond the 16ms maximum required to keep it
within a single frame (at 60fps). While garbage collection occurs, it blocks the
main thread, which means other Javascript cannot be executed until the event
completes. Be conscious of how janky your application may become due to
extensive Garbage Collection events!





Events
-------------------------------

HTML events are "things" that happen to HTML elements. When JavaScript is used in HTML pages, JavaScript can "react" on these events. 

An HTML event can be something the browser does, or something a user does. Here are some examples of HTML events:

    An HTML web page has finished loading
    An HTML input field was changed
    An HTML button was clicked

And JavaScript lets you execute code when such events are detected.

HTML allows event handler attributes, with JavaScript code, to be added to HTML elements:

<some-HTML-element some-event='some JavaScript'> or <some-HTML-element some-event="some JavaScript">

For example, we can attache the buit-in Date() function to an html button click:

    <button onclick='getElementById("demo").innerHTML=Date()'>The time is?</button>

We could also just get the date to be displayed directly on the button:

    <button onclick="this.innerHTML=Date()">The time is?</button>

Here is a list of some common HTML events (for more see html DOM events at http://www.w3schools.com/jsref/dom_obj_event.asp):

Event 			Description

onchange 		An HTML element has been changed
onclick 		The user clicks an HTML element
onmouseover 	The user moves the mouse over an HTML element
onmouseout 		The user moves the mouse away from an HTML element
onkeydown 		The user pushes a keyboard key
onload 			The browser has finished loading the page

an example: <span onmouseover="this.style.color='red'">Mouse over me!</span>  //'Mouse over me!' goes red.

http://www.w3schools.com/js/js_htmldom.asp for HTML DOM Tutorials


Many different methods can be used to let JavaScript work with events:

    -HTML event attributes can execute JavaScript code directly
    -HTML event attributes can call JavaScript functions   eg <button onclick="displayDate()">The time is?</button>
    -You can assign your own event handler functions to HTML elements
    -You can prevent events from being sent or being handled
    -And more ...see HTML DOM


When we use the addEventListener() method we can then work in a javascript file. The general syntax is: 

    element.addEventListener(event, function, useCapture);   //note that you do not need the 'on' for an event. eg use 'click' instead of 'onclick'.

In the file reading example at http://blog.teamtreehouse.com/reading-files-using-the-html5-filereader-api we have a file <input> element and a text display element (<pre>):

    <div>
      Select a text file: 
      <input type="file" id="fileInput">
    </div>
    <pre id="fileDisplayArea"></pre>

In our .js file we need to get references to these important elements within our HTML and then store these references in variables. In this case the variables are called fileInput and fileDisplayArea. We also set up an event listener on fileInput. This will be fired whenever the user selects a file.

    window.onload = function() {
        var fileInput = document.getElementById('fileInput');
        var fileDisplayArea = document.getElementById('fileDisplayArea');

        fileInput.addEventListener('change', function(e) {
          // Put the rest of the demo code here.
        });
    }








Strings
---------------------------------

Special Characters:

Because strings must be written within quotes, JavaScript will misunderstand this string: 

var y = "We are the so-called "Vikings" from the north."

The string will be chopped to "We are the so-called ". The solution to avoid this problem, is to use the \ escape character. The backslash escape character turns special characters into string characters:

var y = "We are the so-called \"Vikings\" from the north."

The escape character (\) can also be used to insert other special characters in a string:

Code 		Outputs
\' 			single quote
\" 			double quote
\\ 			backslash
\n 			new line
\r 			carriage return
\t 			tab
\b 			backspace
\f 			form feed

Breaking Long Code Lines: For best readability, programmers often like to avoid code lines longer than 80 characters. If a JavaScript statement does not fit on one line, the best place to break it is after an operator:

document.getElementById("demo").innerHTML =
"Hello Dolly.";

You can also break up a code line within a text string with a single backslash: 

document.getElementById("demo").innerHTML = "Hello \
Dolly!"; 


Note that some browsers do not allow spaces behind the \ character.  The safest (but a little slower) way to break a long string is to use string addition:

document.getElementById("demo").innerHTML = "Hello" +
"Dolly!";

Strings Can be Objects: normally, JavaScript strings are primitive values, created from literals: var firstName = "John"

But strings can also be defined as objects with the keyword new: var firstName = new String("John"):

<p id="demo"></p>

<script>
var x = "John";              // x is a string
var y = new String("John");  // y is an object

document.getElementById("demo").innerHTML =
typeof x + "<br>" + typeof y;
</script>

This produces string for x and object for y.

Generally, don't create strings as objects. It slows down execution speed. Also, the new keyword complicates the code. This can produce some unexpected results. An equality test between the x and y will be true (equal values) but a triple equality test (===) will be false (not also of the same type). To add to the complication, objects cannot be compared:

var x = new String("John");             
var y = new String("John");

// (x === y) is false because x and y are different types  [=== tests "equal value and equal type" ]
// (x == y) is true because they have equal value [somehow!!! What properties are being tested here????]




Template literals:

Template literals are string literals allowing embedded expressions. They sit within back ticks and produce a string. In comparison to string concatenation, they allow for a tidier way to format strings.

The general format is `string text ${expression} string text`, where the expression can be an evaluation.

Example:

    var cliff = "Cliff is a good guy";
    var comment = "strongly agree";
    var num = 20;
    `We all think that ${cliff}, in fact we ${comment} to the ${num + 4}th power`
    // "We all think that Cliff is a good guy, in fact we strongly agree to the 24th power"

The old way would have been:

    "We all think that " + cliff + ", in fact we " + comment + " to the " + (num + 4) + "th power"

(note the extra brackets around num * 4; otherwise we would have seen '204' with the coercion of 20 and 4 to strings before the + is applied)


We can also use other methods:

`We all think that ${cliff}, in fact we ${comment.split("").join('_')} to the ${num + 4}th power`

// "We all think that Cliff is a good guy, in fact we s_t_r_o_n_g_l_y_ _a_g_r_e_e to the 24th power"







String Methods and Properties
----------------------------------------

Primitive values, like "John Doe", cannot have properties or methods (because they are not objects). But with JavaScript, methods and properties are also available to primitive values, because JavaScript treats primitive values as objects when executing methods and properties. Briefly, there is a String (capital S) object wrapper form, typically called a "native," that pairs with the primitive string type; it's this object wrapper that defines the toUpperCase() method on its prototype. When you use a primitive value like "hello world" as an object by referencing a property or method (e.g., a.toUpperCase() in the previous snippet), JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers).

Some string properties includes .constructor, which returns the function that created the String object's prototype, .length, which returns the length of a string, and .prototype, which allows you to add properties and methods to an object.

For example, the length of a string is found in the built in property length:

<p id="demo"></p>
<script>
var txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
document.getElementById("demo").innerHTML = txt.length; //displays '26'
</script>


String Methods:

Method 					Description

charAt() 				Returns the character at the specified index (position)
charCodeAt() 			Returns the Unicode of the character at the specified index
concat() 				Joins two or more strings, and returns a copy of the joined strings
fromCharCode() 			Converts Unicode values to characters
indexOf() 				Returns the position of the first found occurrence of a specified value in a string
lastIndexOf() 			Returns the position of the last found occurrence of a specified value in a string
localeCompare() 		Compares two strings in the current locale
match() 				Searches a string for a match against a regular expression, and returns the matches
replace() 				Searches a string for a value and returns a new string with the value replaced
search() 				Searches a string for a value and returns the position of the match
slice() 				Extracts a part of a string and returns a new string
split() 				Splits a string into an array of substrings
substr() 				Extracts a part of a string from a start position through a number of characters
substring() 			Extracts a part of a string between two specified positions
toLocaleLowerCase() 	Converts a string to lowercase letters, according to the host's locale
toLocaleUpperCase() 	Converts a string to uppercase letters, according to the host's locale
toLowerCase() 			Converts a string to lowercase letters
toString() 				Returns the value of a String object
toUpperCase() 			Converts a string to uppercase letters
trim() 					Removes whitespace from both ends of a string
valueOf() 				Returns the primitive value of a String object


some examples of these methods follow.

Index locations of a word within a string;  .indexOf(), .lastIndexOf(), and .search()

<p id="p1">Please locate where 'locate' occurs!.</p>
<button onclick="myFunction()">Try it</button>    //this produces a '7', so is the index of the letter l in the first 'locate'.
<p id="demo"></p>

<script>
function myFunction() {
    var str = document.getElementById("p1").innerHTML;   //note that we are now using .getElementById to obtain information
    var pos = str.indexOf("locate");
    document.getElementById("demo").innerHTML = pos;   
}
</script>


If we replace the previous var pos declaration/assignment with var pos = str.lastIndexOf("locate"); then the answer is 21.

Both the indexOf(), and the lastIndexOf() methods return -1 if the text is not found.

search() is similar to index but takes on more powerful search values. 

Extracing a slice of a string: there are three methods available:

	1. slice() extracts a part of a string and returns the extracted part in a new string. The method takes 2 parameters: the starting index (position), and the ending index (position).
	
	var str = "Apple, Banana, Kiwi";
	var res = str.slice(7,13);  //will produce 'Banana'
	
	If a parameter is negative, the position is counted from the end of the string. eg using var res = str.slice(-12,-6); in th previous example will again give 'banana'

	If you omit the second parameter, the method will slice out the rest of the string: var res = str.slice(7); gives 'Banana, Kiwi'. Counting from the end with var res = str.slice(-12); will give the same result.
	
	2. substring() is similar to slice(). The difference is that substring() cannot accept negative indexes. ag 'hello world'.substring(2,5); will return the new string 'llo' (it counts curser positons from zero across thestring)
	
	3. substr() is also similar to slice(). The difference is that the second parameter specifies the length of the extracted part. So var res = str.substr(7,6); will give 'Banana'. If the first parameter is negative, the position counts from the end of the string. The second parameter can not be negative, because it defines the length. If you omit the second parameter, substr() will slice out the rest of the string.
	

Replacing String Content: the replace() method replaces a specified value with another value in a string: 

<button onclick="myFunction()">Try it</button>

<p id="demo">Please visit Microsoft!</p>

<script>
function myFunction() {
    var str = document.getElementById("demo").innerHTML;    //[passing in information but not as an argument]
    var txt = str.replace("Microsoft","W3Schools");
    document.getElementById("demo").innerHTML = txt;
}
</script>
	
By default, the replace() function replaces only the first match. To replace all matches, use a regular expression with a g flag (for global match): var n = str.replace(/Microsoft/g,"W3Schools");


Concatenation: concat() joins two or more strings:

var text1 = "Hello";
var text2 = "World!";
document.getElementById("demo").innerHTML = text1.concat(" ",text2);

All string methods return a new string. They don't modify the original string. Formally said: Strings are immutable: Strings cannot be changed, only replaced. 

Extracting String Characters: There are 2 safe methods for extracting string characters; 
    1. charAt(position)  (returns the character)
    2. charCodeAt(position) (returns the unicode)
	
Accessing a String as an Array is Unsafe: eg var str = "HELLO WORLD"; str[0];                   // returns H
This makes strings lok like arrays when they are not. A string can be converted to an array with the split() method:

var txt = "a,b,c,d,e";   // String
txt.split(",");          // Split on commas
txt.split(" ");          // Split on spaces
txt.split("|");          // Split on pipe


If the separator is omitted, the returned array will contain the whole string in index [0]. If the separator is "", the returned array will be an array of single characters:

var str = "Hello";
var arr = str.split("");
var text = "";								//initialise a new string for later insertion in a html paragraph
var i;							
for (i = 0; i < arr.length; i++) {
    text += arr[i] + "<br>"					//this for loop populates the new string so that it need only be inserted once in the next line.
}
document.getElementById("demo").innerHTML = text;
	
The complete string reference is at http://www.w3schools.com/jsref/jsref_obj_string.asp





Math 
------------------------------------------

For a random number between between zero and one (non-inclusive): Math.random() 

Order of operation is normal. Eg 'hi'.length-1*2 evaluates as 0 since the multiplication occurs first.

Math.floor(Math.random() * 2);  //will give a random boolean/binary number.

Math.floor(Math.random()*5 + 1); //provides a random number between 1 and 5





Flow Control
-------------------------------------

[see also break and continue in the statements section. These change the behaviour of for loops]

If Statement: the boolean check in the if parameter/argument evaluate as true for any number greater than zero, not just 1. eg:

    if(20){console.log(true);}
    else{console.log(false)}                 //true

So you can check whether you have an array for example:

   if (pow.size) {
      return pow.map(val => Math.pow(Math.E,val))  //this branch is run if pow is an array.
   }
   return Math.pow(Math.E,pow);
   
   




For Loop



    for (var i = 1; i >= 1; i++) {
    	console.log(i);
    }      // note that the incremental part only actions once the code block is complete

    var cities = ["Melbourne", "Amman", "Helsinki", "NYC"];

    for (var i = 0; i < cities.length; i++) {      // note use of .length 
        console.log("I would like to visit " + cities[i]);
    }   


The for (;;) construct is a way to intentionally create a loop that doesn’t terminate on its own. Since there is no check for the end of the loop, we break out of the loop only when a valid direction is given.

    for (;;) {
      try {
        let dir = promptDirection("Where?"); // ← typo!
        console.log("You chose ", dir);
        break;
      } catch (e) {
        console.log("Not a valid direction. Try again." e.value);
      }
    }

This example finds the first number that is both greater than or equal to 20 and divisible by 7.

    for (let current = 20; ; current = current + 1) {
      if (current % 7 == 0) {
        console.log(current);
        break;
      }
    }

The continue keyword is similar to break, in that it influences the progress of a loop. When continue is encountered in a loop body, control jumps out of the body and continues with the loop’s next iteration.


While Loop




while(condition){           
    // Do something!
}                                                       //you always need a condition in the code body that will eventually make the condition false,

Recall that the condition inside the parentheses is boolean and so we can also use 1,0 instead of true/false. And we dont need equality either. While(myBool === true) is the same as while(myBool), and this is the case whether myBool is actually of boolean type or binary.

All while loops must have code in their main body that will at some finite time, make the condition false. It is also more readable if the condition reads like a verb. eg while(running){...} So while some variable is running then we will also do this loop.

A while loop with a counter does the same work as a for loop.







Do-while loop



do{} while(condition)  //runs at least once. In the next example the loop condition is never true but we still obtain one iteration:

var loopCondition = false;

do {
	console.log("I'm gonna stop looping 'cause my condition is " + loopCondition + "!");	
} while (loopCondition);






Switch Statement


Switch Statement; looks through a preset number of options for a match. If there is no match then a default option is taken. Good for a fixed number of choices.

switch (/*Some expression*/) {
    case 'option1':
        // Do something
        break;
    case 'option2':
        // Do something else //No break here so option2 and option3 cases will execute
    case 'option3':
        // Do a third thing
        break;
    default:
       // Do yet another thing
       break;
}

Without the break statements the code will then go on and execute the default case as well.






For-in 


Generally:

for(var x in obj) {
executeSomething();
}


for/in Lopp example with nested objects:

var friends = {};
friends.bill = {
  firstName: "Bill",
  lastName: "Gates",
  number: "(206) 555-5555",
  address: ['One Microsoft Way','Redmond','WA','98052']
};
friends.steve = {
  firstName: "Steve",
  lastName: "Jobs",
  number: "(408) 555-5555",
  address: ['1 Infinite Loop','Cupertino','CA','95014']
};

var list = function(obj) {      //provides a summary of the all the nested objects.
  for(var prop in obj) {
    console.log(prop);
  }
};

var search = function(name) {           //picks one object and gives the contents. Objects are iterative structures.
  for(var prop in friends) {
    if(friends[prop].firstName === name) {              //we can only use the more native array-like notation here rather than friends.prop.firstName. Perhaps the for/in loop produces a string.
      console.log(friends[prop]);                   //this also seems to imply that prop is a string. Otherwise we would have needed to add a quote.
      return friends[prop];
    }
  }
};

list(friends);
search("Steve");

//produces:

//bill
//steve                                 //These first two lines are from the list function; notice the lower case first letter. These are object references.
//{ firstName: 'Steve',                 
//  lastName: 'Jobs',
//  number: '(408) 555-5555',
//  address: [ '1 Infinite Loop', 'Cupertino', 'CA', '95014' ] }
//{"firstName":"Steve","lastName":"Jobs","number":"(408) 555-5555","address":["1 Infinite Loop","Cupertino","CA","95014"]} 



Regular Expressions (regex)
-----------------------------------------

Regular expressions are a way to describe patterns in string data.

In jS regular expressions are a type of object. It can be either constructed with the RegExp constructor or written as a literal value by enclosing a pattern in forward slash (/) characters.

    let re1 = new RegExp("abc");
    let re2 = /abc/;

Both of those regular expression objects represent the same pattern: an a character followed by a b followed by a c.

The second notation, where the pattern appears between slash characters, treats backslashes somewhat differently. First, since a forward slash ends the pattern, we need to put a backslash before any forward slash that we want to be part of the pattern.

In addition, backslashes that aren’t part of special character codes (like \n) will be preserved, rather than ignored as they are in strings, and change the meaning of the pattern. Some characters, such as question marks and plus signs, have special meanings in regular expressions and must be preceded by a backslash if they are meant to represent the character itself.

    let eighteenPlus = /eighteen\+/;

We use the test method to check a string:

    console.log(/abc/.test("abcde"));
    // → true
    console.log(/abc/.test("abxde"));
    // → false

Putting a set of characters between square brackets makes that part of the expression can match any of the characters between the brackets.

    console.log(/[0123456789]/.test("in 1992"));
    // → true
    console.log(/[0-9]/.test("in 1992"));
    // → true

Within square brackets, a hyphen (-) between two characters can be used to indicate a range of characters, where the ordering is determined by the character’s Unicode number. Characters 0 to 9 sit right next to each other in this ordering (codes 48 to 57), so [0-9] covers all of them and matches any digit.

A number of common character groups have their own built-in shortcuts. Digits are one of them: \d means the same thing as [0-9].
    \d	Any digit character
    \w	An alphanumeric character (“word character”)
    \s	Any whitespace character (space, tab, newline, and similar)
    \D	A character that is not a digit
    \W	A nonalphanumeric character
    \S	A nonwhitespace character
    .	Any character except for newline

Whitespace example:

    console.log(/\sc/.test("ab cde"));  //true


Finding a date format:

    let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
    console.log(dateTime.test("01-30-2003 15:20"));
    // → true
    console.log(dateTime.test("30-jan-2003 15:20"));
    // → false

These backslash codes can also be used inside square brackets. For example, [\d.] means any digit or a period character. But the period itself, between square brackets, loses its special meaning. The same goes for other special characters, such as +.

To invert a set of characters—that is, to express that you want to match any character except the ones in the set—you can write a caret (^) character after the opening bracket.

    let notBinary = /[^01]/;
    console.log(notBinary.test("1100100010100110"));
    // → false
    console.log(notBinary.test("1100100010200110"));
    // → true

When you put a plus sign (+) after something in a regular expression, it indicates that the element may be repeated more than once. Thus, /\d+/ matches one or more digit characters. Thus, /\d+/ matches one or more digit characters.

    console.log(/'\d+'/.test("'123'"));
    // → true
    console.log(/'\d+'/.test("''"));
    // → false 

The star (*) has a similar meaning but also allows the pattern to match zero times. 

    console.log(/'\d*'/.test("'123'"));
    // → true
    console.log(/'\d*'/.test("''"));
    // → true

Something with a star after it never prevents a pattern from matching—it’ll just match zero instances if it can’t find any suitable text to match.

A question mark makes a part of a pattern optional, meaning it may occur zero times or one time. In the following example, the u character is allowed to occur, but the pattern also matches when it is missing.

    let neighbor = /neighbou?r/;
    console.log(neighbor.test("neighbour"));
    // → true
    console.log(neighbor.test("neighbor"));
    // → true

To indicate that a pattern should occur a precise number of times, use braces. Putting {4} after an element, for example, requires it to occur exactly four times. It is also possible to specify a range this way: {2,4} means the element must occur at least twice and at most four times.

Here is another version of the date and time pattern that allows both single- and double-digit days, months, and hours. It is also slightly easier to decipher.

    let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
    console.log(dateTime.test("1-30-2003 8:45"));
    // → true

You can also specify open-ended ranges when using braces by omitting the number after the comma. So, {5,} means five or more times.

Grouping subExpressions: to use an operator like * or + on more than one element at a time, you have to use parentheses. A part of a regular expression that is enclosed in parentheses counts as a single element as far as the operators following it are concerned.

let cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// → true
The first and second + characters apply only to the second o in boo and hoo, respectively. The third + applies to the whole group (hoo+), matching one or more sequences like that.

The i at the end of the expression in the example makes this regular expression case insensitive, allowing it to match the uppercase B in the input string, even though the pattern is itself all lowercase.


The test method is the absolute simplest way to match a regular expression. It tells you only whether it matched and nothing else. Regular expressions also have an exec (execute) method that will return null if no match was found and return an object with information about the match otherwise.

    let match = /\d+/.exec("one two 100");
    console.log(match);
    // → ["100"]
    console.log(match.index);
    // → 8

String values have a match method that behaves similarly.

    console.log("one two 100".match(/\d+/));      // → ["100"]

When the regular expression contains subexpressions grouped with parentheses, the text that matched those groups will also show up in the array. The whole match is always the first element. The next element is the part matched by the first group (the one whose opening parenthesis comes first in the expression), then the second group, and so on.

    let quotedText = /'([^']*)'/;
    console.log(quotedText.exec("she said 'hello'"));
    // → ["'hello'", "hello"]

When a group does not end up being matched at all (for example, when followed by a question mark), its position in the output array will hold undefined. Similarly, when a group is matched multiple times, only the last match ends up in the array.

    console.log(/bad(ly)?/.exec("bad"));
    // → ["bad", undefined]
    console.log(/(\d)+/.exec("123"));
    // → ["123", "3"]

Groups can be useful for extracting parts of a string. If we don’t just want to verify whether a string contains a date but also extract it and construct an object that represents it, we can wrap parentheses around the digit patterns and directly pick the date out of the result of exec.

Date example:

    function getDate(string) {
    let [_, month, day, year] =
        /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
    return new Date(year, month - 1, day);   // the Date object counts months and days differently (month is from zero while days are from 1)
    }
    console.log(getDate("1-30-2003"));
    // → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)

(The _ (underscore) binding is ignored and used only to skip the full match element in the array returned by exec.)






Summary

    /abc/	A sequence of characters
    /[abc]/	Any character from a set of characters
    /[^abc]/	Any character not in a set of characters
    /[0-9]/	Any character in a range of characters
    /x+/	One or more occurrences of the pattern x
    /x+?/	One or more occurrences, nongreedy
    /x*/	Zero or more occurrences
    /x?/	Zero or one occurrence
    /x{2,4}/	Two to four occurrences
    /(abc)/	A group
    /a|b|c/	Any one of several patterns
    /\d/	Any digit character
    /\w/	An alphanumeric character (“word character”)
    /\s/	Any whitespace character
    /./	Any character except newlines
    /\b/	A word boundary
    /^/	Start of input
    /$/	End of input







Functional Programming
-----------------------------------------

Having first class class function objects allows the use of functional programming in JS. We think and code in terms of functions. How can I simplify my code by taking in fucntions as arguments, or return them from other functions? This is what takes JS to a new level.

See the section on Mutability; in functional programming we want to avoid side effects.

There are many examples throughout these notes (EJS has a nice summary). However, what do we do when a callback has one argument too many? We can use bind to create a copy with one argument bound.

    var checkPastLimit = function(limiter, element) {
        return element > limiter;
    }

    // make a copy of checkPastLimit on the fly, with limiter locked in; map() expects this callback to work on elements.
    const newArray = array.map(checkPastLimit.bind(this, 1));

We can also generalise this so that we don't have to explicitly keep calling bind:

    var checkPastLimitSimplified = function(limiter) {
        return function(limited, element) {
            return element > limiter;
        }.bind(this, limiter);
    }

Another option is to make a closure with the limiter variable becoming an outer variable further up the scope chain.

    function limiterFixed(limiter){
        return function(element) { return element > limiter; }
    }

    const newArray = array.map(limiterFixed(1));

A great place to checkout a lot of real life functional programming is within underscorejs.org. This is a very popular open source library. By clicking on the 'Annotated source' link you can see comments (another popular library is lodash).

You'll first notice that all the underscore.js code is wrapped in an IIFE. This is stop naming collisions with your code. This library uses an underscrore as a valid object name place on the global object. From this you can use all of the library's material.

    _.map(array, function(item){// ...} )



Mutability
-------------------------------------------

So what is a mutation exactly? Mutations are in-place changes to data or the data structures that contain it. Immutability on the other hand, makes a copy of such data and data structures whenever a change is required.

A function or expression is said to have a side effect if it modifies some state or has an observable interaction with calling functions or the outside world. For example, a particular function might modify a global variable or static variable, modify one of its arguments, raise an exception, write data to a display or file, read data, or call other side-effecting functions. In the presence of side effects, a program's behaviour may depend on history; that is, the order of evaluation matters. Understanding and debugging a function with side effects requires knowledge about the context and its possible histories.

Side effects are the most common way that a program interacts with the outside world (people, filesystems, other computers on networks). But the degree to which side effects are used depends on the programming paradigm. Imperative programming is known for its frequent utilization of side effects. In functional programming, side effects are rarely used. The lack of side effects makes it easier to do formal verifications of a program.

Functional programming is a programming paradigm, a style of building the structure and elements of computer programs, that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. It is a declarative programming paradigm, which means programming is done with expressions or declarations instead of statements. In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) each time [not time dependant results]. Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.

In contrast, imperative programming changes state with commands in the source language, the most simple example being assignment. Imperative programming does have functions, not in the mathematical sense, but in the sense of subroutines. They can have side effects that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack referential transparency, i.e. the same language expression can result in different values at different times depending on the state of the executing program.

JavaScript, by virtue of being a multi-paradigm language, provides a fertile ground for both mutable and immutable data structures. Although functional programming is much more than just immutability, many functional languages put a strong emphasis on immutability. For instance, Array.map applies a function to each item in an array and returns a new array, without modifying the original in the process. Instead it returns new versions of existing data. 

In practice, mutations can be split in two groups: visible mutations and invisible mutations. Visible mutations are those that either modify the data or the data structure that contains it in a way that can be noted by outside observers through the API. Invisible mutations can be considered side-effects. Immutability in the context of functional programming usually forbids any of these two modifications: not only is data immutable by default, but the data structures themselves suffer no changes once instanced.

JavaScript is a dynamic, weakly typed language (or untyped if you're familiar with programming language theory). It has typed values, not typed variables. As such it is sometimes hard to enforce certain constraints on objects and data. Object.freeze() helps in this regard. A call to Object.freeze marks all properties as immutable ()be carefule with child class objects). 

One way to eliminate side effects in your code: using immutable.js.



immutable.js
------------------------------------

Example (explanation follows):


var person = Immutable.Map({ 
    name: 'John', 
    birth: 594687600000,
    phone: '12345678'
});
 
var changePhone = function( person, newPhone ) {
    return person.set( 'phone', newPhone );
};
 
var person2 = changePhone( person, '87654321' );
 
console.log( person2 == person, person2 === person );
// false false
 
console.log( person.get('phone'), person2.get( 'phone' ) );
// 12345678 87654321
 
console.log( person.phone, person2.phone );
// underfined undefined

The changePhone function returns a new immutable map. When the changePhone function is executed, person2 is created as a return value, and person2 is strictly different than person. The phone numbers of each person map can be accessed via the get method. The properties of the maps are hidden behind the get/set interface, therefore they cannot be directly accessed or modified.





var person3 = changePhone( person, '12345678' );
 
console.log( person3 == person, person3 === person );
// true true
 
var person4 = changePhone( person, '87654321' );
var person5 = changePhone( person4, '12345678' );
 
console.log( person5 == person, person5 === person );
// false false
 

The immutable abstraction is intelligent enough to detect when an attribute is changed to the same value as before. In this case, both == and === comparisons return true, as the return of the o.set method is o. In all other cases, a real change takes place, and a new object reference is returned. This is why person5 is not equal to person even though they have the exact same keys and values. 


If we wanted to check the equality of attribute key-value pairs of person and person5, we can use the equals method of the immutable map interface:

console.log( person5.equals( person ) );
// true


We normally send JSON payloads to the server instead of an immutable.js data structure. Therefore, there is a need to convert the immutable.js data structure into a JavaScript object or a JSON string.

person5.toObject()
// Object {name: "John", birth: 594687600000, phone: "12345678"}
 
person5.toJSON()
Object {name: "John", birth: 594687600000, phone: "12345678"}
 
JSON.stringify( person5 )
// '{"name":"John","birth":594687600000,"phone":"12345678"}'

Both the toObject and the toJSON methods return a JavaScript object representation of the immutable map. As a consequence of the return value of toJSON, JSON.stringify can directly be used on immutable data structures to create a JSON string for serialization.







Data Structures


List: a List is an immutable representation of a JavaScript array. The usual array operations are available with the twist that their return value is a new immutable object whenever the content of the original object is changed.



var qwerty = Immutable.List(['q','w','e','r','t','y']);

var qwerty.size
// 6

var qwertyu = qwerty.push( 'u' );
// Object {size: 7, _origin: 0, _capacity: 7, _level: 5, _root: null…}

var qwert = qwertyu.pop().pop();
// Object {size: 5, _origin: 0, _capacity: 5, _level: 5, _root: null…}

var wertArray = qwert.shift().toJSON();
// ["w", "e", "r", "t"]

var qwertyuiArray = qwert.concat( 'y', 'u', 'i' ).toJS();
// ["q", "w", "e", "r", "t", "y", "u", "i"]




Stack: first in, last out data structure, defined with the usual operations. The serialized equivalent of a stack is an array, where the element with index 0 corresponds to the element to be popped. All elements of the stack can be accessed without popping via the get method. However, our only options for modifying the stack are to push and pop.



var filo = new Immutable.Stack();
// Object {size: 0, _head: undefined, __ownerID: undefined, __hash: undefined, __altered: false}

var twoStoreyStack = filo.push( '2nd floor', '1st floor', 'ground floor' );

twoStoreyStack.size
// 3
twoStoreyStack.get()
// "2nd floor"
twoStoreyStack.get(1)
// "1st floor"
twoStoreyStack.get(2)
// "ground floor"

var oneStoreyStack = twoStoreyStack.pop();
var oneStoreyJSON = JSON.Stringify( oneStoreyStack );
// '["1st floor","ground floor"]'



 
Map: we have already seen the Map data structure in action. It is the immutable.js representation of a JavaScript object.

OrderedMap: an ordered map is a mixture of objects and arrays. It can be treated as an object with the feature that its keys are ordered based on the order in which they were added to the map. Modifying the value belonging to an already added key does not result in a change of the order of keys.

The order of the keys can be re-defined using the sort or sortBy methods, returning a new immutable ordered map.

The dangerous part about using an ordered map is that its serialized form is a simple object. Given that some languages such as PHP also treat their objects as ordered maps, in theory, communicating via order maps could work. In practice, I don’t recommend this form of communication for the sake of clarity.



var basket = Immutable.OrderedMap()
                      .set( 'Captain Immutable 1', 495 )
                      .set( 'The Immutable Bat Rises 1', 995 );

console.log( basket.first(), basket.last() );
// 495 995

JSON.stringify( basket );
// '{"Captain Immutable 1":495,"The Immutable Bat Rises 1":995}'

var basket2 = basket.set( 'Captain Immutable 1', 695 );

JSON.stringify( basket2 );
// '{"Captain Immutable 1":695,"The Immutable Bat Rises 1":995}'

var basket3 = basket2.sortBy( function( value, key ) { 
    return -value; 
} );

JSON.stringify( basket3 );
// '{"The Immutable Bat Rises 1":995,"Captain Immutable 1":695}'



 
Set: A Set contains an array of unique elements. All usual operations are available. In theory, the order of elements in the set should not matter.



var s1 = Immutable.Set( [2, 1] );
var s2 = Immutable.Set( [2, 3, 3] );
var s3 = Immutable.Set( [1, 1, 1] );

console.log( s1.count(), s2.size, s3.count() );
// 2 2 1

console.log( s1.toJS(), s2.toArray(), s3.toJSON() );
// [2, 1] [2, 3] [1]

var s1S2IntersectArray = s1.intersect( s2 ).toJSON();
// [2]



 
OrderedSet: An OrderedSet is a Set with elements ordered according to the time of addition. When the order of elements matter, use an ordered set.



var s1 = Immutable.OrderedSet( [2, 1] );
var s2 = Immutable.OrderedSet( [2, 3, 3] );
var s3 = Immutable.OrderedSet( [1, 1, 1] );

var s1S2S3UnionArray = s1.union( s2, s3 ).toJSON();
// [2, 1, 3]

var s3S2S1UnionArray = s3.union( s2, s1 ).toJSON();
// [1, 2, 3]



 
Record: a record is like a JavaScript class with default values for some keys. When instantiating a record, the values for the keys defined in the record can be given during instantiation. In absence of a value, the default value of the record is used.



var Canvas = Immutable.Record( { width: 1024, height: 768 } );

console.log( 'constructor ' + typeof Canvas );
// constructor function

var myCanvas = new Canvas();

myCanvas.toJSON()
// Object {width: 1024, height: 768}

myCanvas.width
// 1024

var myResizedCanvas = new Canvas( {width: 400, height: 300} );

myResizedCanvas.width
// 400




 
Seq: sequences are lazy finite or infinite data structures. Elements of a Seq are only evaluated on demand. Depending on the type of sequence, we can talk about a KeyedSeq, an IndexedSeq or a SetSeq. Finite and infinite sequences can be defined using



Immutable.Range(),
Immutable.Repeat(),
a mutation of a seq using a functional utility such as map, filter.
Finite Seqs can also be defined using enumeration.



var oneToInfinitySeq = Immutable.Range( 1 );

var isEven = function( num ) { return num % 2 === 0; }
var evenPositiveSeq = oneToInfinitySeq.filter( isEven );

var firstTenPositivesSeq = evenPositiveSeq.take(10);
firstTenPositivesSeq.toJSON();
// [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

var firstTenElements = Immutable.Repeat( /* undefined */ )
                                .map( Math.random )
                                .take( 10 )
                                .toJSON();
// generates an array of ten random numbers



 
One of the benefits of lazy evaluation is that infinite sequences can be defined. Another one is performance. As a riddle, try to determine the console messages emitted by the following code:



var toUpper = function( item ) {
    var upperItem = item.toUpperCase();
    console.log( item + ' has been converted to ' + upperItem );
    return upperItem;
}

var seasons = Immutable.Seq( ['spring', 'summer', 'fall', 'winter'] )
                       .map( toUpper );

console.log( 'Item at index 1: ', seasons.get( 1 ) );
console.log( 'Item at index 0: ', seasons.get( 0 ) );
console.log( 'Seasons in an array: ', seasons.toJS() );


 
The results may be surprising. Given that evaluation is lazy and we are dealing with a finite data structure, elements of the seasons Seq can be accessed directly. Therefore, the upper case version of each element is calculated on demand. When the toJS method of seasons is called, all four elements are calculated from scratch. By default, there is no memorization in lazy sequences. Therefore the result is:



summer has been converted to SUMMER
Item at index 1:  SUMMER
spring has been converted to SPRING
Item at index 0:  SPRING
spring has been converted to SPRING
summer has been converted to SUMMER
fall has been converted to FALL
winter has been converted to WINTER
Seasons in an array:  ["SPRING", "SUMMER", "FALL", "WINTER"]

The above observations hold for infinite data structures as well. Elements are only calculated on demand, without memorization.







Asynchronus (async) Code, timing, Call Backs (callbacks)
----------------------------------------------------------

Synchronus code is code that is executed in order. It is related to the idea of being single threaded, which means that only one command is being executed at any one time. (While JS may not be the only thing happening in the browser, from the programmers view point JS is single threaded). Synchronus extend the idea of 'one command at a time' to 'And in order that those commands appear'. Despite the following discusion on asynchronus behaviour (that is: "the execution of more than one instruction at a time"), JS is both single threaded and synchronus. 

Synchronous code is easy to understand and write. One task follows another task is a sequence, such that each task completes its work and returns execution before the next task can begin. Here is an example to illustrate:

var photo = download('http://foo-chan.com/images/sp.jpg')
uploadPhotoTweet(photo, '@maxogden')

This synchronous pseudo-code downloads an adorable cat photo and then uploads the photo to twitter and tweets the photo at @maxogden.

This code is synchronous because in order for photo to get uploaded to the tweet, the photo download must be completed. This means that line 2 cannot run until the task on line 1 is totally finished. If we were to actually implement this pseudo-code we would want to make sure that download 'blocked' execution until the download was finished, meaning it would prevent any other JavaScript from being executed until it finished, and then when the download completes it would un-block the JavaScript execution and line 2 would execute. Meanwhile, because all JavaScript on the page is being blocked from being run while the download is happening, the webpage would totally freeze up and become unresponsive until the download is done.

Even when a sequence is chained, via the first step calling the second step, which calls the last step, etc, it may still may synchronus. For example:

    function getList() { return [1,2,3,4,5,6]; }  

    function getEvens() {  
      return addFour().filter(function(item) { return item % 2 == 0; });
    }

    function addFour() {  
      return getList().map(function(item) { return item + 4; });
    }

    function sum() {  
      return getEvens().reduce(function(sum, n){ return (sum += n); }, 0);
    }

    console.log("sum =", sum());  //returns 24


Each function in the chain simply calls the next function in the chain, returning a result.

However, if our getList() function had to fetch the list from a remote resource (asynchronously), how would we handle processing the result. Synchronous code is fine for things that happen fast, but it's horrible for things that require saving, loading, downloading or uploading. 

To understnd async code you have to understand the JS Engine. Within the browser there is also a rendering engine (draws to the screen), a part that deals with HTTP responses (getting data).The JS Engine has hooks into these other parts of the browser. Also while these three parts may be running asynchronously alongside each other, the JS Engine is internally running synchronously.

Inside the JS Engine we already know that we have an execution stack (a stack of function based execution contexts). There is a another list inside the JS Engine called the Event Queue. This is full of events and notifications of events. Any event of possible interest that happens elsewhere in the browser, say a click, is placed on the queue. The JS Engine will go and and periodically look at this queue when the execution stack is empty. This periodic check is called the 'event loop'. If an event is in the queue the engine looks to see if some function should be run as a response to that event. Events are processed in the order they appear.

For example, there may be a click handler. So after a click the engine then creates an execution context for clickHandler(). The event is thus processed and removed form the event queue. The next item in the queue is then processed. In this way, JS is synchronusly dealing with asynchronus events in the browser.

Check out the logging order (click in the browser within 3 seconds of reloading the page):

    function wait3Seconds() {
        let ms = 3000 + new Date().getTime();
        while (new Date() < ms) {}
        console.log('wait3Second execution context about to be removed from the execution stack');  
    }

    function clickHandler() {
        console.log('click event execution context almost finished');
    }

    wait3Seconds();
    console.log('global execution context about to be removed from the execution stack');


    // wait3Second execution context about to be removed from the execution stack
    // global execution context about to be removed from the execution stack
    // click event execution context almost finished


In the browser, the most familiar form of asynchronous programming is likely the DOM event API. But, asynchronous development in the browser happens in a number of places:

    DOM Events
    Browser API calls like setTimout(), setInterval() and setImmediate()
    XHR (XML HTTP Requests), or Ajax calls


First, though, here is a nice way to measure how many times a computer can execute a fuction in one second:


    function measureLoopSpeed() {
      var count = 0
      function addOne() { count = count + 1 }   //function being tested

      // Date.now() returns a big number representing the number of
      // milliseconds that have elapsed since Jan 01 1970
      var now = Date.now()

      // Loop until Date.now() is 1000 milliseconds (1 second) or more into
      // the future from when we started looping. On each loop, call addOne
      while (Date.now() - now < 1000) addOne()

      // Finally it has been >= 1000ms, so let's print out our total count
      console.log(count)
    }

    measureLoopSpeed()    //8527360 ie. around 8.5 million executions in one second.





Two mechanisms for asynchronus programming are callbacks and promises.

Callbacks are just functions that call other functions after some asynchronous task. They prevent blocking.  A function that performs a task asynchronously will immediately return, so as not to block the main execution thread. 

Common examples of asynchronous tasks are things like reading a photo, downloading a song, uploading a picture, talking to a database, waiting for a user to hit a key or click on someone, etc. Anything that takes time. Basically, if you have to wait for task A to finish before doing task B, you put all of the code for task B into a function and you only call that function when A is done.

for example, this is blocking-style code:

a()
b()

And this is in a non-blocking style:

a(b) [and somewhere in a there is a statement calling b; ie ...; b(); ...;]

In the non-blocking version b is a callback to a. In the blocking version a and b are both called/invoked (they both have () after them which executes the functions immediately). In the blocking version, there is no explicit relationship between a and b. In the non-blocking version it becomes a's job to do what it needs to do and then call b when it is done. Using functions in this way is called callbacks because your callback function, in this case b, gets called later on when a is all done.


Here is a pseudocode implementation of what a might look like:

function a(done) {
  download('https://pbs.twimg.com/media/B4DDWBrCEAA8u4O.jpg:large', function doneDownloading(error, png) {
    // handle error if there was one
    if (err) console.log('uh-oh!', error)

    // call done when you are all done
    done()  
  })
}

In the function definition for a above the done argument is our b function that we pass in. When you call a function, the arguments you pass in won't have the same variable names when they are in the function. In this case what we call b is called done inside the function. But b and done are just variable names that point to the same underlying function. Usually callback functions are labelled something like done or callback to make it clear that they are functions that should be called when the current function is done.

Returning to the sum example, this is how we would use a callback mechanism by modifying getList() to have a delay:

    function getList(callback) {  
      // runs asynchronously and immediately returns
      setTimeout(function(){ callback([1,2,3,4,5,6]); }, 2000);  
    }
    function getEvens(list) {  
      return list.filter(function(item) { return item % 2 == 0; });
    }
    function addFour(list) {  
      return list.map(function(item) { return item + 4; });
    }
    function sum(list) {  
      var res = getEvens(list);
      res = addFour(res);
      console.log(res.reduce(function(sum, n){ return (sum += n); }, 0));
    }

    getList(sum);  
    console.log("waiting...");  
    // waiting... //  2 seconds pass  [so we see that console.log continues on while the rest of the code is delayed]
    // 24


Here we see that sum() is the callback function. It is called when getList() has retrieved the data. This data is used as the argument for sum(). However getList() immediately returns [note that now the control flow begins with getList() but then goes to console.log(waiting...), and then goes to sum once it is called two seconds later. See the nice diagrams at http://www.datchley.name/asynchronous-in-the-browser/ ]

If we have a series of interdependant asynchronous tasks we have to build up a nested callback structure.

    function asyncTask(fn) {  
      return setTimeout(function(){ fn(); }, 2000); 
    }
    function foo(n, fn) {  
      asyncTask(function(){ fn(n); });
    }
    function bar(n, fn) {  
      asyncTask(function(){ fn(n); });
    }
    function baz(n, fn) {  
      asyncTask(function(){ fn(n); });
    }

    var n = 1;  
    foo(n, function(res) {                      //'function(res) { ... ' is the callback for foo, not bar
      bar(res+1, function(res) {
        baz(res+1, function(res) {
          console.log("result =", res);
        });
      });
    });
    // 6 seconds pass...
    // result = 3

This is known as 'callback hell'.  [foo, bar and baz are asynchonus functions and bar is a callback for foo, but baz is a callback for bar] Aidan would probably change this example around to make it easier to understand. For example, instead of "function foo(n, fn)" he would have "function foo(i, fooCallback)". This way you emphasise that fn is a callback function and that n is not the same thing all the way through. Here n is a parameter and not the same n that was initially declared.

Continuation Passing Style is common in the node API, among other places. The idea behind continuation passing style is:

    -no function is allowed to return to it's caller.
    -each function takes a callback or continuation function as its last argument.
    -that continuation function is the last thing to be called.

For example:

    function foo() {  
      bar(function (res) {
        console.log("result = " + res);
      });
    }
    function bar(fn) {  
      baz(fn);
    }
    function baz(fn) {  
      fn(3);
    }
    foo();

However this method can also lead to 'callback hell'. Consider converting a mathemetical expression CPS style:

This code

    var a=1, b=2, c=3, d=4, e=5;  
    (a + ((Math.pow(b, 2)) * c) / d) - e;   // -4


becomes this in CPS:

    function mul(x, y, cont) { cont(x*y); }  
    function add(x, y, cont) { cont(x+y); }  
    function sub(x, y, cont) { cont(x-y); }  
    function div(x, y, cont) { cont(x/y); }  
    function sqr(x, cont) { cont(x^2); }

    sqr(b, function(res){  
      mul(res, c, function(res) {
        div(res, d, function(res) {
          add(a, res, function(res) {
            sub(res, e, function(res) {
              console.log(res);  // -4
            });
          });
        });
      });
    });


In order to handle processing, we have to nest each call to retain the scope and results passed to each callback. Below is a discussion on the "stack and Recursive Functions". CPS has tail calls [returns a function], as each continuation function passed is an explicit tail call; and hence, could be optimized by the language runtime. But without optimization, CPS alone can lead to growing stack problems.

More detail on callbacks and CPS can be found in the links at the bottom of:  http://www.datchley.name/asynchronous-in-the-browser/

Error handling in Asynchronus programming can also be a problem. Refer to the section below on this topic "Async Error Handling Patterns".





Promises:


new Promise( /* executor */ function(resolve, reject) { ... } );

A Promise represents a value which may be available now, or in the future, or never. A Promise is a proxy for a value not necessarily known when the promise is created. Promises wrap an asynchronous action in an object, which can be passed around and told to do certain things when the action finishes or fails. 

A promise allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

To create a promise object, we call the Promise constructor, giving it a function that initializes the asynchronous action. The constructor calls that function, passing it two arguments, which are themselves functions. The first should be called when the action finishes successfully, and the second should be called when it fails.

So a Promise is in one of these states:

 pending: initial state, not fulfilled or rejected.
 fulfilled: meaning that the asynchronous operation completed successfully.
 rejected: meaning that the asynchronous operation failed.

A pending promise can either be fulfilled with a value, or rejected with a reason (error). When either of these options happen, the associated handlers queued up by a promise's then method are called. We call this transition the resolution of the promise. The resolved state of a promise is its final state, so once it is fulfilled or rejected, it stays there.



Methods: 

1. Promise.prototype.catch(onRejected)
Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

2. Promise.prototype.then(onFulfilled, onRejected)
Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e. if the relevant handler onFulfilled or onRejected is not a function).

    let myFirstPromise = new Promise((resolve, reject) => {
      // We call resolve(...) when what we were doing async succeeded, and reject(...) when it failed.
      // In this example, we use setTimeout(...) to simulate async code. 
      // In reality, you will probably be using something like XHR or an HTML5 API.
      setTimeout(function(){
        const randomNumber = Math.random();
        if(randomNumber > 0.5) {
            resolve("Success!"); // Yay! Everything went well!
        }
        else reject("Promise rejected");
      }, 250);
    });

    // note the above promise is only ever run once, when created, and then resolved. If you want to keep using it then return it from a function and execute that function - see the below examples.

    myFirstPromise.then((successMessage) => {
      // successMessage is whatever we passed into the resolve() or reject().
      // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
      console.log("Yay! " + successMessage);
    }, (rejectionMessage) => {
        console.log("Bad luck " + rejectionMessage);
    });

Promises are a better pattern than callbacks, but not just because they avoid 'callback hell'. They give us a way to handle asynchronous processing in a more synchronous fashion. They represent a value that we can handle at some point in the future. And, better than callbacks here, Promises give us guarantees about that future value, specifically:

    -No other registered handlers of that value can change it (the Promise is immutable)
    -We are guaranteed to receive the value, regardless of when we register a handler for it, even if it's already resolved (in contrast to events, which can incur race conditions).

Here is a simple example:

    function dieToss() {
      return Math.floor(Math.random() * 6) + 1;
    }

    console.log('1');
    var promise = new Promise(function(fulfill, reject) {
      var n = dieToss();
      if (n === 6) {
        fulfill(n);
      } else {
        reject(n);
      }
      console.log('2');
    });

    promise.then(function(toss) {
      console.log('Yay, threw a ' + toss + '.');  
    }, function(toss) {
      console.log('Oh, noes, threw a ' + toss + '.');  
    });
    console.log('3');

    //1
    //2
    //3
    //Oh, noes, threw a 4. // or Yay, threw a 6.

First, the handlers we attached to the promise were indeed called after all other code ran, asynchronously.

Second, the fulfillment handler was called only when the promise was fulfilled, with the value it was resolved with (in our case, the result of the dice toss). The same holds true for the rejection handler.

And we can extend this example into a chain situation where we want to toss the dice a maximum of three times, or until the first six comes up (which requires returning a promise from a function each time the function is called). The specification requires that the then function (the handlers) must return a promise, too, which enables chaining promises together, resulting in code that looks almost synchronous.  Each function in the promise chain gets called with the return value of the previous handler once it has completed. For all practical purposes, this serializes the calls without blocking the main execution thread.

    function tossASix() {
      return new Promise(function(fulfill, reject) {
        var n = Math.floor(Math.random() * 6) + 1;
        if (n === 6) {
          fulfill(n);
        } else {
          reject(n);
        }
      });
    }

    function logAndTossAgain(toss) {
      console.log("Tossed a " + toss + ", need to try again.");
      return tossASix();                // note that a new promise is generated, the resolution of which is used in the next chained 'then'.
    }

    function logSuccess(toss) {
      console.log("Yay, managed to toss a " + toss + ".");
    }

    function logFailure(toss) {
      console.log("Tossed a " + toss + ". Too bad, couldn't roll a six");
    }

    tossASix()
      .then(null, logAndTossAgain)   //Roll first time
      .then(null, logAndTossAgain)   //Roll second time
      .then(logSuccess, logFailure); //Roll third and last time

This example also teaches us something more. If the first toss is successful, no more tosses were made. Note that all fulfillment handlers (the first arguments in the calls to then) in the chain are null, except the last one, logSuccess. The specification requires that if a handler (fulfillment or rejection) is not a function then the returned promise must be resolved (fulfilled or rejected) with the same value. In this example, the fulfillment handler, null, is not a function and the value of the promise was fulfilled with a 6. So the promise returned by the then call (the next one in the chain) is also going to be fulfilled with 6 as its value.

This repeats until an actual fulfillment handler (one that is a function) is present, so the fulfillment trickles down until it gets handled. In our case, this happens at the end of the chain where it is cheerfully logged out onto the console.


The next example creates a promise that we will call res (resolve) after a second. Then immediately, after that, it will call coolFn logging “cool” to the console.

    var longFn = function() {
      return new Promise(function(res, rej) {
        setTimeout(res, 1000);
      });
    };

    var coolFn = function() {
      console.log('cool');
    };

    // logs cool after 1 second
    longFn().then(coolFn);



For example:

    // an immediately resolved promise
    var p2 = Promise.resolve("foo"); 

    // can get it after the fact, unlike events
    p2.then((res) => console.log(res)); 

    var p = new Promise(function(resolve, reject) {  
       setTimeout(() => resolve(4), 2000);
    });

    // handler can't change promise, just value
    p.then((res) => {  
      res += 2;  
      console.log(res);
    });

    // still gets 4
    p.then((res) => console.log(res));  

But more than just allowing us to handle future values, they give us a much better way to control asynchronous program flow than plain callbacks. Plain callbacks don't really let us use our usual language features like return and throw to handle value and error processing in synchronous flows.

The standard way to create a Promise is by using the new Promise constructor which accepts a handler that is given two functions as parameters. The first handler (typically named resolve) is a function to call with the future value when it's ready; and the second handler (typically named reject) is a function to call to reject the Promise if it can't resolve the future value.

    var p = new Promise(function(resolve, reject) {  
       if (/* condition */) {
          resolve(/* value */);  // fulfilled successfully
       }
       else {
          reject(/* reason */);  // error, rejected
       }
    });

In this way, a Promise itself has one of the following three states:

Pending - until a Promise is fulfilled it is in pending state
Fulfilled - when the first handler is called the Promise is considered fulfilled with the value passed to that handler.
Rejected - if the second handler is called, the Promise is considered rejected with the value passed to that handler.

A Promise can only be "settled" (meaning it has been fulfilled or rejected) once. Other consumers, as we stated previously, can not change the settled value.

You can also create an immediately resolved Promise by using the Promise.resolve() method.

    var p = Promise.resolve(42);  

Once we have a Promise, it can be passed around as a value. The Promise is a stand-in for a future value; and so it can be returned from a function, passed as a parameter and used in any other way a standard value would be used.

To consume the Promise - meaning we want to process the Promises value once fulfilled - we attach a handler to the Promise using it's .then() method. This method takes a function that will be passed the resolved value of the Promise once it is fulfilled. This means you can use 'then' to transform the result of a promise. 

    var p = new Promise((resolve, reject) => resolve(5));  
    p.then((val) => console.log(val)); // 5 

A Promise's .then() method actually takes two possible parameters. The first is the function to be called when the Promise is fulfilled and the second is a function to be called if the Promise is rejected.

    p.then((val) => console.log("fulfilled:", val),  
           (err) => console.log("rejected: ", err));

You can omit either handler in a .then(), so sending a null as the first handler and providing the second is the same as the standard Promise.catch(), which takes a single handler to be called when a promise is rejected.

The following are equivalent:

    p.then((val) => console.log("fulfilled:", val))  
     .catch((err) => console.log("rejected:", err));

    p.then((val) => console.log("fulfilled:", val))  
     .then(null, (err) => console.log("rejected:", err));

And, as shown above .then() calls can be chained. If a handler returns a value in the a .then() call it is automatically wrapped in a Promise when returned and then properly unwrapped to pass the value to further chained .then() calls.

https://www.youtube.com/watch?v=2d7s3spWAzo (ie MPJ at funfunfunction) gives this example showing that you can make a chain even tidier by using an array of promises:

load-image.js :

import 'babelify/polyfill'

function loadImage(url) {
  return new Promise((resolve, reject) => {
    let image = new Image()

    image.onload = function() {
      resolve(image)
    }

    image.onerror = function() {
      let message =
        'Could not load image at ' + url
      reject(new Error(msg))
    }

    image.src = url

  })
}
export default loadImage



app.js [which uses the load module]

    import loadImage from './load-image'

    let addImg = (src) => {
      let imgElement =
        document.createElement("img")
      imgElement.src = src
      document.body.appendChild(imgElement)
    }

    Promise.all([                       //see below for .all
      loadImage('images/cat1.jpg'),
      loadImage('images/cat2.jpg'),
      loadImage('images/cat3.jpg'),
      loadImage('images/cat4.jpg')
    ]).then((images) => {
      images.forEach(img => addImg(img.src))
    }).catch((error) => {
      // handle error later
    })


The Promise constructor has an all method that, given an array of promises, returns a promise that waits for all of the promises in the array to finish. It then succeeds, yielding an array of result values. If any of the promises in the array fail, the promise returned by all fails too (with the failure value from the failing promise)




Async and Await
-------------------------------------

The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just like Promises are similar to structured callbacks, async/await is similar to combining generators and promises.

When an async function is called, it returns a Promise. When the async function returns a value, the Promise will be resolved with the returned value. 


Example:

Assuming a function getJSON that returns a promise, and that promise resolves with some JSON object. We just want to call it and log that JSON, then return "done".

With promises this is how you would implement:

    const makeRequest = () =>
        getJSON()
            .then(data => {
            console.log(data)
            return "done"
        })

    makeRequest();

With async/await

    const makeRequest = async () => {
    console.log(await getJSON())
    return "done"
    }

    makeRequest()

The await keyword can only be used inside functions defined with async. Such a function pauses execution at the 'await' and waits for the resolution of any asynchronus code. 

Any async function also returns a promise implicitly, and the resolve value of the promise will be whatever you return from the function (which is the string "done" in our case). However, this means that we cannot use await at the top level of our code.

A more complicated example:

    function resolveAfter2Seconds(x) {
      return new Promise(resolve => {
        setTimeout(() => {
          resolve(x);
        }, 2000);
      });
    }

    async function add1(x) {
      var a = resolveAfter2Seconds(20);
      var b = resolveAfter2Seconds(30);
      return x + await a + await b;
    }

    add1(10).then(v => {
      console.log(v);  // prints 60 after 2 seconds.
    });

    async function add2(x) {
      var a = await resolveAfter2Seconds(20);
      var b = await resolveAfter2Seconds(30);
      return x + a + b;
    }

    add2(10).then(v => {
      console.log(v);  // prints 60 after 4 seconds.
    });


Async/await also allows us to more cleanly deal with conditionals. What if our incoming async data needs to be checked, and then perhaps run again? Previously we would have had to chain some then statements, which invovles a high degree of nesting.

    const makeRequest = async () => {
    const data = await getJSON()
    if (data.needsAnotherRequest) {
        const moreData = await makeAnotherRequest(data);
        console.log(moreData)
        return moreData
    } else {
        console.log(data)
        return data    
    }
    }

Beside being a lot cleaner and more concise, async/await makes it possible to handle both synchronous and asynchronous errors with the try/catch construct. With regular promises you need to chain a .catch() to catch any asynchronous errors.

    const makeRequest = async () => {
        try {
            const data = JSON.parse(await getJSON()); // this may fail
            console.log(data);
        } catch (err) {
            console.log(err);
        }
    }





Async Error Handling Patterns
-------------------------------------

Error handling in asynchronous programming can be problematic. Because the asynchronous functions aren't running in the main thread, you can't really wrap them in a try..catch.

try {  
    function async(cb) {
        setTimeout(function() {
            throw new Error("woops!");
            cb("done");
        }, 2000);
    }


    async(function(res) {
        console.log("received:", res);
    });
}
catch(e) {  
    console.log(e);
}
// Uncaught Error: woops!
This doesn't work because the error is thrown in a separate thread of execution, so even wrapping our entire program in a try..catch won't help. The only way to handle it would be inside the actual asynchronous call and then processing that error a different way.

To get around that, many async library APIs have been built to take two callbacks, one for successful completion and one that gets called on error. We can rework our async function above to allow for this as well.

function async2(cb, err) {  
    setTimeout(function() {
        try {
            if (true)
                throw new Error("woops!");
            else
                cb("done");
        }
        catch(e) {
            err(e);
        }
    }, 2000);
}

async2(function(res) {  
    console.log("received:", res);
}, function(err) {
    console.log("Error: async threw an exception:", err);
});
// Error: async threw an exception: Error: woops!
Now, we have a way to gracefully handle exceptions and errors encountered in our asynchronous process and can provide a fallback path of execution.

In Continuation Passing Style, a common pattern is the error first design of callbacks which is common in the node API. In this pattern, you use a single callback and the first argument is reserved for any error response, which would mean the async process didn't complete successfully.

function asyncCPS(continuation) {  
    setTimeout(function() {
        try {
            var res = 42;
            if (true)
                throw new Error("woops!");
            else
                continuation(null, res); // pass 'null' for error
        }
        catch(e) {
            continuation(e, null);
        }
    }, 2000);
}

asyncCPS(function(err, res) {  
    if (err)
        console.log("Error: (cps) failed:", err);
    else
        console.log("(cps) received:", res);
});
// Error: (cps) failed: woops!
Now, our callbacks simply check if err is defined first, and if so, handle the issue in some graceful way; otherwise, our usual continuation processing occurs.

We can generalize this type of error handling by writing a function which works as a decorator on a async function that returns a new function that is wrapped in a try..catch for us.

// Function decorator that will give us a new
// function that wraps the invocation of a given function
// in a try catch.
function Try(fn, cont) {  
    return function _tryWrapper(){
        var args = [].slice.call(arguments);
        try {
            fn.apply(this, args);
        }
        catch(e) {
            cont(e);
        }
    };
}

function asyncCPSWrap(continuation) {  
    setTimeout(Try(function _cpsAsync() {
        var res = 42;
        if (true)
            throw new Error("woops!");
        else
            continuation(null, res);

    }, continuation), 2000);
};

asyncCPSWrap(function _callback(err, res) {  
    if (err)
        console.log("(cps) error:", err);
    else
        console.log("(cps) received:", res);
});
// (cps) error: Error: woops!
Our version of Try() above is written to work with CPS as it takes the async function to wrap and takes the continuation callback as a second parameter. On any exception, it knows to pass the error as the first argument to the continuation.

You could also easily re-write this for regular callbacks to accept a success and error callback handler as well and wire them up appropriately in the function returned from Try(). As we'll see in the next article, Promises make error handling much cleaner and easier to implement than what's available using straight callbacks and CPS.







The Stack and Recursive Functions
---------------------------------------


In stack based languages, like Javascript, function invocations create a new "frame" on the stack which holds the context, scope identifiers, return location and other items necessary to execute the function and return control to the caller.

The stack itself is memory resident, and so the stack is typically a much smaller portion of the memory allocated for the browser. This means stack space is limited. When a function returns, its stack frame is removed from the stack which frees that memory.

If you've ever written a recursive function, you've likely run up against the infamous Range Error: Maximum call stack size exceeded message. For example, take a simple factorial function written in recursive style:

    function factorial(n) {  
      return n ? n * factorial(n-1) : 1;
    }
    factorial(10);     // 3628800  
    factorial(1000);   // Infinity  (integer overflow!)  
    factorial(32768);  // Range Error: stack size exceeded

Because the stack is limited in memory size, there are only so many nested functions you can call - as in the case of our recursive factorial() function. This could be solved, however, if Javascript's runtime handled "tail call elimination"3.

Tail calls occur when a function returns the result of calling another function. That function is said to be in tail position. Our factorial function isn't optimized for tail call elimination, since the it returns the result of an expression (n * factorial(n-1)), not a function invocation;

If Javascript had tail call optimization, we could rewrite our factorial() function to take advantage of that feature like so:

function factorial(n) {  
      function _factorial(n, acc) {
        acc || (acc = 1);
          return n ? _factorial(n-1, n*acc) : acc;  // tail call
      }
      return _factorial(n);
    }

Tail call optimization would transform the recursive calls into an iterative loop, which gives us a constant stack space and is much more efficient.


We can optimize for tail calls ourselves by either writing the function in tail position as a loop:

    function factorialL(n) {  
        var acc = 1;
        while(n) {
            acc *= n--;
        }
        return acc;
    }

or using a technique called trampolining. Trampolining is common in functional programming and provides us a way to call our function in tail position without growing the stack.

Here's an implementation of the trampoline() function:

    function trampoline(fn) {  
        var args = [].slice.call(arguments, 1);
        while (fn && fn instanceof Function) {
            fn = fn.apply(this, args);
        }
        return fn;
    }

The trampoline works by continuously executing a function as long as it continues to return a function. Once it returns a value, the loop terminates and the value is returned.

Here's our factorial() function written to optimize for recursive tail calls by using trampoline(). We simply wrap our call to our internal _factorial() function in a call to trampoline() and ensure that the internal function will return a reference to the next invocation of itself to be executed. Once done, we simply return our acc value and the trampoline stops.

    function factorial(n) {  
      function _factorial(n, acc) {
        acc || (acc = 1);
          return n ? _factorial.bind(this, n-1, n*acc) : acc;
      }
      return trampoline(_factorial, n);
    }

    factorial(32768);  
    // Infinity - no range error now!

So how does this help us in Continuation Passing Style? Remember, each continuation is a function, that represents the next step in processing. This continuation is executed in tail position by the current phase of processing once it has finished - the callback is now a continuation to more processing. There is no need to retain the stack frame or context of the current function once it executes the continuation, as everything needed is passed to the continuation callback.

Instead of nesting our continuations and growing the stack, we can use our trampoline() to flatten out the processing steps; and retain a constant stack space.

    // CPS functions representing our processing steps
    var steps = [  
        function first(cont) {
            cont(1);
        },
        function second(val, cont) {
            cont(val+2);
        },
        function third(val, cont) {
            cont(val+3);
        }
    ];

    // A function to flatten our CPS steps into a series
    // passing any values as we go. Takes a callback which
    // will receive the result passed to the final continuation
    function waterfall(steps, done) {  
        steps.push(done);
        trampoline(function() {
            return steps.length ? 
                function _cb(){
                    var args = [].slice.call(arguments),
                        fn = steps.shift(); 
                    fn.apply(this, args.concat(_cb));
                } :
                undefined;  // steps complete 
        });
    }

        waterfall(steps, function(res) {  
            console.log("final = ", res);   // final = 6
        });

This is very similar to the async.waterfall method in the node async module. We can define our processing steps individually and allow our waterfall() function to run them, in order, using an anonymous callback as the continuation.

Our waterfall() also takes a final callback continuation, in CPS fashion, that will be passed the result given to the last continuation in the last step. It functions like a pipeline, where we are able to pass each step's result to the next step.

Here's a non-trampolined version of the waterfall() function that uses recursion.

    function waterfall(list, final) {  
      var args = [].slice.call(arguments, 2);

      if (list.length) {
        var fn = list.shift(),
            cb = function() {
              var results = [].slice.call(arguments);
              waterfall.apply(this, [list, final].concat(results));
            };
        fn.apply(this, args.concat(cb));
      }
      else {
        final.apply(this, args);
      }
    }    




Built-in Object Constructors
--------------------------------------

JavaScript contains nine native (or built-in) object constructors. These are used to construct objects and facilitate the language. For example, functions are objects
created from the Function() constructor, but are also used to create other objects when called as
constructor functions using the new keyword.

Number()
String()
Boolean()
Object()
Array()
Function()
Date()
RegExp()
Error()

JavaScript is mostly constructed from just these nine objects (as well as string, number, and boolean primitive values). 

The Math object is the oddball here. It's a static object, rather than a constructor function, meaning you canʼt do this: var x = new Math().
But you can use it as if it has already been instantiated (e.g. Math.PI). Truly, Math is a just an object namespace set up by JavaScript to
house math functions.

If you create a constructor function and call it without the use of the new keyword the this value will
refer to the "parent" object that contains the function.







Generators
----------------------------------

These are a new type of function in ES6. However, there are differences with regular functions. The first is 'run to completion'. We have always assumed once the function starts running, it will always run to completion before any other JS code can run. 

Consider this:

    setTimeout(function(){
        console.log("Hello World");
    },1);

    function foo() {
        // NOTE: don't ever do crazy long-running loops like this
        for (var i=0; i<=1E10; i++) {
            console.log(i);
        }
    }

    foo();
    // 0..1E10
// "Hello World"

Here, the for loop will take a fairly long time to complete, well more than one millisecond, but our timer callback with the console.log(..) statement cannot interrupt the foo() function while it's running, so it gets stuck at the back of the line (on the event-loop) and it patiently waits its turn. What if foo() could be interrupted, though? With ES6 generators, we have a different kind of function, which may be paused in the middle, one or many times, and resumed later, allowing other code to run during these paused periods.

If you've ever read anything about concurrency or threaded programming, you may have seen the term "cooperative", which basically indicates that a process (in our case, a function) itself chooses when it will allow an interruption, so that it can cooperate with other code. This concept is contrasted with "preemptive", which suggests that a process/function could be interrupted against its will.

ES6 generator functions are "cooperative" in their concurrency behavior. Inside the generator function body, you use the new yield keyword to pause the function from inside itself. Nothing can pause a generator from the outside; it pauses itself when it comes across a yield. However, once a generator has yield-paused itself, it cannot resume on its own. An external control must be used to restart the generator. However, this enables 2-way message passing into and out of the generator, as it progresses. With normal functions, you get parameters at the beginning and a return value at the end. With generator functions, you send messages out with each yield, and you send messages back in with each restart. In fact, the infamous while (true) { .. } loop is something you might actually use in a generator.

Example:

    function *foo() {
        var x = 1 + (yield "foo");
        console.log(x);
    }

'*' indicates the special function generator type. The yield "foo" expression will send the "foo" string value out when pausing the generator function at that point, and whenever (if ever) the generator is restarted, whatever value is sent in will be the result of that expression, which will then get added to 1 and assigned to the x variable.

In any expression location, you can just use yield by itself in the expression/statement, and there's an assumed undefined value yielded out. So:

    function *bar() {
        yield; // just pause
        foo( yield ); // pause waiting for a parameter to pass into `foo(..)`
    }


The way we control generator functions from the outside is to construct and interact with a generator iterator. Iterators are a special kind of behavior, a design pattern actually, where we step through an ordered set of values one at a time by calling next(). next() returns a value and a signal whether or not the iteration is complete. 

We actually get back an object from each next() call, which has a value property for the yielded-out value, and done is a boolean that indicates if the generator function has fully completed or not. Note that done is not not set to false unless you call next() after all the yields have been exhausted. You get then get an undefined value: { value:undefined, done:true }.


    function *foo(x) {
        var y = 2 * (yield (x + 1));
        var z = yield (y / 3);
        return (x + y + z);
    }

    var it = foo( 5 );  //constructing an iterator and providing a value of 5 to parameter x. Amazingly, calling the generator in the normal way does not execute its contents.

    // Now we begin iterating. Note: not sending anything into `next()` here
    console.log( it.next() );       // { value:6, done:false }
    console.log( it.next( 12 ) );   // { value:8, done:false }
    console.log( it.next( 13 ) );   // { value:42, done:true }


The first next(..) call, we don't send in anything. Why? Because there's no yield expression to receive what we pass in. But if we did pass in a value to that first next(..) call, nothing bad would happen. It would just be a tossed-away value.

The yield (x + 1) is what sends out value 6. The second next(12) call sends 12 to that waiting yield (x + 1) expression, so y is set to 12 * 2, value 24. Then the subsequent yield (y / 3) (yield (24 / 3)) is what sends out the value 8. The third next(13) call sends 13 to that waiting yield (y / 3) expression, making z set to 13.

Finally, return (x + y + z) is return (5 + 24 + 13), or 42 being returned out as the last value.

ES6 also embraces this iterator pattern at the syntactic level, by providing direct support for running iterators to completion: the for..of loop. However, any return statement is lost in this pattern. Once done is true, the loop iteration stops (and does nothing with any final value returned, if any).

    function *foo() {
        yield 1;
        yield 2;
        yield 3;
        yield 4;
        yield 5;
        return 6;
    }

    for (var v of foo()) {
        console.log( v );
    }
    // 1 2 3 4 5                    //only logging the values and not the entire objectbon

    console.log( v ); // still `5`, not `6` :(




JQuery Introduction
-----------------------------------

jQuery is a popular JavaScript library that simplifies JavaScript programming. jQuery takes a lot of common tasks that require many lines of JavaScript code to accomplish, and wraps them into methods that you can call with a single line of code. jQuery also simplifies a lot of the complicated things from JavaScript, like AJAX calls and DOM manipulation. It also has the advantage of dealing with cross browser problems.

Essentially it allows you to manipulate the Document Object Model (DOM), which is a tree like structure. The DOM is in the browser but it is separate from the JS Engine. The DOM looks at HTML and decides how to render it on the screen. JS does have access to the DOM after the page has loaded. This is how JS can change the contents of a page. 

jQuery, then, as a JS library, makes it easy to look at the DOM and find elements on the page. 

The jQuery library contains the following features:

    - HTML/DOM manipulation
    - CSS manipulation
    - HTML event methods
    - Effects and animations
    - AJAX
    - Utilities

The jQuery library is a single JavaScript file, and you reference it with the HTML <script> tag.

The first example avoids you having to download and host the file yourself. If you don't want to download and host jQuery yourself, you can include it from a CDN (Content Delivery Network). Both Google and Microsoft host jQuery. 

Google CDN:
    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    </head>

Microsoft CDN:
    <head>
        <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.1.min.js"></script>
    </head>

Or ajax:     

<body>
    <!-- normal page content -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
</body>

(some people put js files at the end of the HTML doc so that the page has already loaded before the JS has imported)



Example 1:

    <!DOCTYPE html>
    <html>
    <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script>
    $(document).ready(function(){
        $("p").click(function(){
            $(this).hide();
        });
    });
    </script>
    </head>
    <body>
    
    <p>If you click on me, I will disappear.</p>
    <p>Click me away!</p>
    <p>Click me too!</p>
    
    </body>
    </html>

In this example you download the file and place it with your other files.

Example 2:

    <html>
        <head>
        </head>
        <body>
            <div id="main" class="container">
                <h1>People</h1>
                <ul class="people">
                    <li>John Doe</li>
                    <li>Jane Doe</li>
                    <li>Jim Doe</li>
                </ul>
            </div>
            <script src="jquery-1.11.2.js"></script>
            <script src="app.js"></script>
        </body>
    </html>

Also note that we have not used type="text/javascript" inside the <script> tag. This is not required in HTML5. JavaScript is the default scripting language in HTML5 and in all modern browsers.

There are also a number of useful plugings that are built with jquery. One is magnific popup at http://dimsemenov.com/plugins/magnific-popup/ . You can make image pop ups and gallaries with it, as well as pop up videos and maps. Modal dialogs are also possible.

Another useful plugin for tooltips is at http://iamceege.github.io/tooltipster/ .

Maplace.js helps you to imbed google maps into your website. 

Some other fun plug-ins include Typer.js, which can make it look like text in your page is being edited. This means you can have multiple messages in one line. onepage_scroll has each section fill one view port height. This can help you make presentation style websites. 


Basic syntax is: $(selector).action()

    - A $ sign or jQuery to define/access jQuery
        var q = $('')   // same as var q = jQuery('');
    - A (selector) to "query (or find)" HTML elements - this is a string
    - A jQuery action() to be performed on the element(s)


Examples:

$(this).hide() - hides the current element.

$("p").hide() - hides all <p> elements.

$(".test").hide() - hides all elements with class="test".

$("#test").hide() - hides the element with id="test".

The following examples will be inside a document ready event:

    $(document).ready(function(){
    
       // jQuery methods go here...
    
    });

This is to prevent any jQuery code from running before the document is finished loading (is ready).

However, there is an even shorter, but less easy to understand, method for the ready event:


    $(function(){
    
       // jQuery methods go here...
    
    });


Click example:

Sp every js file containing jquery must wait until the page has loaded. So the file with a call to the ready method.

    $(document).ready(function() {
        $('hi').click(function() {
            $(this).css('background', '#ff0000')     // 'this' refers to the currently selected h1 element. Here we change it's background when clicked
        })
    });


Using jquery to make a sticky navigation bar. Once we scroll down far so that we have left the header the nav bar will reappear.


consider a nav element that will have the className "sticky" (it does not actually have it yet though):

    <nav className='sticky'> ...

Unlike our usual navbar the background color will be transparant white. This means that some properties, like text color will need to change. Otherwise nav items will not be visible. Also, we need a different icon. This means that we actually insert a dark version of our icon directly in the HTML alongside our existing icon.

                    <img src="resources/img/logo-white.png" alt="Omnifood logo" class="logo">
                    <img src="resources/img/logo.png" alt="Omnifood logo" class="logo-black">

But, by default this new logo is hidden:

    .logo-black {
        display: none;
    }

However, if logo-black is inside the nav, then it will display as block and the normal logo will no longer display:

    .sticky .logo-black {
        display: block;
    }

    .sticky .logo {
        display: none;
    }


So altogether, in CSS we adjust margins, colors and text properties to match the small fixed div:

    .sticky {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.98); /* we need a little transparancy so that we can see the content underneath */
        box-shadow: 0 2px 2px #efefef;  /* helps to distinguish from the white background of a normal section */
        z-index: 9999;  // helps in thos cases where the nav bar gets stuck behind images.
    }

    .sticky .main-nav { margin-top: 18px; }

    .sticky .main-nav li a:link,
    .sticky .main-nav li a:visited {
        padding: 16px 0;
        color: #555;
    }

    .sticky .logo { display: none; }
    .sticky .logo-black { display: block; }

We can now use the waypoint library to trigger a function when we scroll to a certain element. Download it and import:

    <script src="vendors/js/jquery.waypoints.min.js"></script>

    $(document).ready(function() {
        $('js--section-features').waypoint(function(direction) {   // js--section-features is the class name of the waypoint
            if (direction == 'down') {
                $('nav).addClass('sticky');  // adds the sticky class to the nav element
            } else {
                $(nav).removeClass('sticky)
            }
        }, {
            offset: '60 px';   // the class name change will happen 60 pixels before the waypoint - looks nicer
        })
    });

    
We can also use jquery to have a button click scroll us to another part of the page.

    $(document).ready(function() {
        $('js--scroll-to-plans').click(function() {
            $('html, body').animate({scrollTop: $('js--section-plans').offset().top}, 1000ms;
        });
    });

This is useful for nav bar buttons in a single page.


Also see the 'Scroll Animations' section in ./CSS_WebDesign.txt .






More detail:

jQuery selectors allow you to select and manipulate HTML element(s). jQuery selectors are used to "find" (or select) HTML elements based on their name, id, classes, types, attributes, values of attributes and much more. It's based on the existing CSS Selectors, and in addition, it has some own custom selectors. 

Using Example 2, we can select in relation to the DOM's tree like structure:

    var q = $("ui")         // all unordered lists
    var q = $("ul.people")  // find all unordered lists that have a class of 'people'
    var q = $("ul.people li") // find all the li elements that are children of all uls of class 'people'

We are essectially using CSS selectors.

If you were to log out 'q' then you see an object of type jQuery.fn.init[3], which seems to be an array-like structure of DOM elements (within each DOM element object there are properties like innerHTML).

So $() returns an object and with methods. If you then checkout __proto__ you will all the methods that attach to such a jQuery object. 

Using Example 2 with (method chaining) to change a class name:

    var q = $("ul.people").addClass('newClass').removeClass('people'); // check this out in the dev tools

So, while $() returns an object, method chaining requires each method to effect the parent object. Each method must have their 'this' set to the parent object.

If you look in the source code for something like addClass, you will see that it does something to the object and then returns 'this'.



Going under the hood:

Notice, however, that we did not use the new operator. We also have this strangly named object, jQuery.fn.init[3].

If you open up the unminified file it's over 10000 line long. At any rate there is an IIFE (as expected), and this:

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

So the jQuery function we have been using is not a function constructor. It's just a regular funciton. This is we do not need to use the new operator. It is a function, however, that does call a function constructor, and then returns this new object. That means that we don't have to remember to call the new keyword, which is a neat trick; a function that returns a call to a function constructor. 

Further down we see:

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},  // ....

'fn' is a reference that points to the same memory spot as the prototype property of the jQuery function, which is the reference used as __proto__ for any object constructed from the 'jQuery' function. This effectivly saves typing '.prototype' all the time.

And then we see that .prototype is being overwriten with a new object using object literal syntax. 

Later on we see this in the init constructor:
    return jQuery.makeArray( selector, this );

Since the new keyword was being used we know that 'this' refers to the new object being created. 'makeArray' takes the new object and makes an array out of it. This is interesting because makeArray is not interfering with the function contructor; 'this' hasn't changed.

And, to round off our understanding of the object type we saw in the contructor, this comes up:

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

Recall, that init is the contructor. So it too shares the same prototype and again avpis us having to use the new keyword. This is what is being called when we use $(). 

We also see 'extend', which seems to be making a deep copy (see 'extend' in the object section above - using refection (for-in loop) to take properties from one object and add them to another object).

    jQuery.extend = jQuery.fn.extend = function() {
        var src, copyIsArray, copy, name, options, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

        // ...

    for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

We also see some deep copy work when extend is calls itself:

    target[ name ] = jQuery.extend( deep, clone, copy );
        

This also seems to be refering to the prototype but but giving it an easier to use reference.

Importantly, though, many people have gone through this code. Methods you will see like isNumeric are probably the best around, so if you need the same functionality in your own project use it. 

We also see another IIFE for sizzle. This is basically another complete library. This manages the string selectors. So we see that we can an IIFE inside an IIFE. 

You can find the end of Sizzle and then see that jQuery.find is really sizzle:

    return Sizzle;

    })( window );

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;



Near the end of the file you can see that there is a check for objects with the same name on window, and 'jQuery' and $ and made to reference the same object.

    var
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function( deep ) {
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }

        if ( deep && window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

    // Expose jQuery and $ identifiers, even in
    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if ( typeof noGlobal === strundefined ) {
        window.jQuery = window.$ = jQuery;
    }




Transpile
---------------------------

Transpile means to convert the syntax of one programming language to the another.  This is commonly done to access JS features that have not made it to browsers. Sometimes extra error messages are available to help you create better code. One is Typescript, which allows for stringly typed coding. And Traceur allows you to use the latest features like ES7. Both have a page that allows you see how yoru code looks in JS.

On large projects that will take some years often use Traceur. By the time the product has reached production, and the language features are available in the browser, then the references to Traceur can be removed.


Making a Library - Greetr
---------------------------

Requirements
    - given first and last names, and an optional language variable can produce informal and formal greetings
    - support English and Spanish
    - reusable framework / library
    - easy to type structure like jQuery. We will use 'G$()'
    - should support jQuery to fill an HTML element with a greeting


    <html>
        <head>
            
        </head>
        <body>
            <div id="logindiv">
                <select id="lang">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                </select>
                <input type="button" value="Login" id="login" />
            </div>
            <h1 id='greeting'></h1>
            <script src="jquery-1.11.2.js"></script>
            <script src="Greetr.js"></script>
            <script src="app.js"></script>
        </body>
    </html>


Stucturing safe code that has access to global and jQuery:

    (function (global, $) {

    }(window, jQuery));


Our object and its prototype:

We will set this up like jQuery; an object will be generated but without the use of the 'new' keyword. In app.js there will be something like:

    var g = G$(firstName, lastName, language);

Code:

    (function (global, $) {

        var Greetr = function(firstName, lastName, language) {
            return new Greetr.init(firstName, lastName, language);
        }

        // Create a prototype
        Greetr.prototype = {};

        // building up a new object to be returned by the Greetr function
        Greetr.init = function(firstName, lastName, language){

            // avoid problems with using 'this'
            var self = this;

            // set up default values
            self.firstName = firstName || '';
            self.lastName = lastName || '';
            self.language = language || 'en';
        }

        // now we need to set this object to the correct prototype
        Greetr.init.prototype = Greetr.prototype;

        // expose our object to the outside world so that we can call it anywhere, and supply an alias 
        global.Greetr = global.G$ = Greetr;

    }(window, jQuery));



Properties, Chainable methods and linking into jQuery:

In the final code see that properties to Greetr.prototype. It becomes one large object literal. We also return 'this' to make chainable methods. There are also some private properties that are created lixically above the object so that they are part of a closure.


    // use an extra ';' to ensure that any previous library has been closed properly
    ;(function (global, $) {

        var Greetr = function (firstName, lastName, language) {
            return new Greetr.init(firstName, lastName, language);
        }

        // Here we can create properties and methods that are not accesable by outside
        // code but, due to closure are availble to objects created here. The following
        // live inside the lexical environment of Greetr.init contructor function.
        // Other devs cannot change these values unless they change this source code.
        var supportedLangs = ['en', 'es'];

        var greetings = {
            en: 'Hello',
            es: 'Hola'
        };

        var formalGreetings = {
            en: 'Greetings',
            es: 'Saludos'
        };

        // Often we want to record which option has been used. 
        // Here we will log to the console
        var logMessages = {
            en: 'Logged in',
            es: 'Inicio sesion'
        };



        // Create a prototype
        Greetr.prototype = {

            fullName: function () {
                return this.firstName + ' ' + this.lastName;
            },

            // Looks up the scope chain for supported languages
            // Here 'this' refers to the object calling this function.
            validate: function () {
                if (supportedLangs.indexOf(this.language) === -1) {
                    throw "Invalid Language";
                }
            },

            greeting: function () {
                return greetings[this.language] + ' ' + this.firstName;
            },

            formalGreeting: function () {
                return formalGreetings[this.language] +
                    ', ' + this.fullName();
            },

            greet: function (formal) {
                var msg;

                // If undefined or null it will be coerced to false
                if (formal) {
                    msg = this.formalGreeting();
                } else {
                    msg = this.greeting();
                }

                if (console) {
                    console.log(msg);
                }

                // 'this' refers to the calling method at execution time. 
                // makes the method chainable
                return this;
            },

            log: function () {
                // console should be a variable in modern browsers
                if (console) {
                    console.log(logMessages[this.language] + ': ' + this.fullName())
                }

                // make chainable
                return this;
            },

            // A chainable method that allows you to change languages
            setLang: function (lang) {
                this.language = lang;
                this.validate();
                return this;
            },

            // Using JQuery to change the text of an element
            HTMLGreeting: function (selector, formal) {
                // make sure jQuery is available
                if (!$) {
                    throw 'jQuery not loaded';
                }

                // make sure we have a selector
                if(!selector) {
                    throw 'Missing jQuery selector';
                }

                // reusing some code form above that should be refactored
                var msg;

                if (formal) {
                    msg = this.formalGreeting();
                } else {
                    msg = this.greeting();
                }

                $(selector).html(msg);

                return this;
            }

        };

        // building up a new object to be returned by the Greetr function
        Greetr.init = function (firstName, lastName, language) {

            // avoid problems with using 'this'
            var self = this;

            // set up default values
            self.firstName = firstName || '';
            self.lastName = lastName || '';
            self.language = language || 'en';

            // validate
            self.validate();
        }

        // now we need to set this object to the correct prototype
        Greetr.init.prototype = Greetr.prototype;

        // expose our object to the outside world so that we can call it anywhere
        global.Greetr = global.G$ = Greetr;

    }(window, jQuery));

the app.js file:

var g = G$('John', 'Doe'); 
g.greet().setLang('es').greet(true).log();
// Hello John
// Saludos, John Doe
// Inicio sesion: John Doe

$('#login').click(function() {
    var loginGrtr = G$('John', 'Doe');
    
    // hide the interface
    $('#logindiv').hide();

    // good example of chaining
    loginGrtr.setLang($('#lang').val()).HTMLGreeting('#greeting', true).log();
})