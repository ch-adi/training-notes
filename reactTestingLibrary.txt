_______________________________________________

React Testing Library
-----------------------------------------------



A Basic Example
---------------------------------------

The most basic React component test invloves importing React, ReactDOM, and the component that we're going to render. We create a <div> in which to render our component. We then query around the document so that we can make assertions.

A simple component:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    expect(div.querySelector('input').type).toBe('number')
    expect(div.querySelector('label').textContent).toBe('Favorite Number')
  })


jest-dom for Improved Assertions
--------------------------------------

The assertions in the above simple example are not that helpful. For example miss-spelling a selector actually throws an obscure typerror.

  expect(div.querySelector('nput').type).toBe('number') // i is missing in 'input. TypeError: Cannot read property 'type' of null

We can extend Jest's built in assertions, and get some better messages, with the jest-dom library. Here we use `toHaveAttribute`.

  import "@testing-library/jest-dom/extend-expect";
  
  expect(div.querySelector('nput')).toHaveAttribute('type', 'number') // 'received value must be an HTMLElement or an SVGElement.'
  
Our working assertions now look like:

  expect(div.querySelector('input')).toHaveAttribute('type', 'number')
  expect(div.querySelector('label')).toHaveTextContent('Favorite Number')
  
  
  
  
dom-testing-library for Maintainable Tests
------------------------------------------

Our tests are currently tightly coupled to the implementation of our component’s element structure. A refactor to that structure wont break our application, but will definitely break our tests because we’re testing implementation details. 

dom-testing-library has a custom render function that will give us some helpful utilities for searching for elements in the DOM in the same way a user would.

For example if we had a typo in the htmlFor property of the label we are testing, then accessibility might be broken and we wouldn't know. Clicking on the label might not give it focus. The test would still pass. 

  <label htmlFor="favorte-number">Favorite Number</label>  // typo here: no link between the label and the input.
  <input
      id="favorite-number"
      type="number"
      value={this.number}
      onChange={this.handleChange}
  />

On the other hand if we were to change the dom then the selectors may not work, and create a false positive.

Imagine also, if we could somehow find the input by it's label. Then we would be ensuring the correct labels are associated with the correct inputs. 

With dom testing library we can now test for this bug and do it with less assertions:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { queries } from '@testing-library/dom'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    const input = queries.getByLabelText(div, 'Favorite Number')
    expect(input).toHaveAttribute('type', 'number')
  })

// Found a label with the text of: Favorite Number, however no form control was found associated to that label.

Some extra tips:

1. Users don't care about casing. If someone were to change 'Favorite Number' with 'Favorite number' then our tests should not break. So use a regex instead of a string:

  const input = queries.getByLabelText(div, /Favorite Number/i)
  
2. We can scope queries to a particular element

  const { getByLabelText } = getQueriesForElement(div);
  const input = getByLabelText(/Favorite Number/i)

 
 
 
