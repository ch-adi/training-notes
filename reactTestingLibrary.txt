_______________________________________________

React Testing Library
-----------------------------------------------



A Basic Example
---------------------------------------

The most basic React component test invloves importing React, ReactDOM, and the component that we're going to render. We create a <div> in which to render our component. We then query around the document so that we can make assertions.

A simple component:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    expect(div.querySelector('input').type).toBe('number')
    expect(div.querySelector('label').textContent).toBe('Favorite Number')
  })


jest-dom for Improved Assertions
--------------------------------------

The assertions in the above simple example are not that helpful. For example miss-spelling a selector actually throws an obscure typerror.

  expect(div.querySelector('nput').type).toBe('number') // i is missing in 'input. TypeError: Cannot read property 'type' of null

We can extend Jest's built in assertions, and get some better messages, with the jest-dom library. Here we use `toHaveAttribute`.

  import "@testing-library/jest-dom/extend-expect";
  
  expect(div.querySelector('nput')).toHaveAttribute('type', 'number') // 'received value must be an HTMLElement or an SVGElement.'
  
Our working assertions now look like:

  expect(div.querySelector('input')).toHaveAttribute('type', 'number')
  expect(div.querySelector('label')).toHaveTextContent('Favorite Number')
  
  
  
  
dom-testing-library for Maintainable Tests
------------------------------------------

Our tests are currently tightly coupled to the implementation of our component’s element structure. A refactor to that structure wont break our application, but will definitely break our tests because we’re testing implementation details. 

dom-testing-library has a custom render function that will give us some helpful utilities for searching for elements in the DOM in the same way a user would. The more your tests resemble the way your software is used, the more confidence they can give you.

For example if we had a typo in the htmlFor property of the label we are testing, then accessibility might be broken and we wouldn't know. Clicking on the label might not give it focus. The test would still pass. 

  <label htmlFor="favorte-number">Favorite Number</label>  // typo here: no link between the label and the input.
  <input
      id="favorite-number"
      type="number"
      value={this.number}
      onChange={this.handleChange}
  />

On the other hand if we were to change the dom then the selectors may not work, and create a false positive.

Imagine also, if we could somehow find the input by it's label. Then we would be ensuring the correct labels are associated with the correct inputs. 

With dom testing library we can now test for this bug and do it with less assertions:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { queries } from '@testing-library/dom'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    const input = queries.getByLabelText(div, 'Favorite Number')
    expect(input).toHaveAttribute('type', 'number')
  })

// Found a label with the text of: Favorite Number, however no form control was found associated to that label.

Some extra tips:

1. Users don't care about casing. If someone were to change 'Favorite Number' with 'Favorite number' then our tests should not break. So use a regex instead of a string:

  const input = queries.getByLabelText(div, /Favorite Number/i)
  
2. We can scope queries to a particular element

  const { getByLabelText } = getQueriesForElement(div);
  const input = getByLabelText(/Favorite Number/i)

3. While we want our tests to resemble the way our software is used, such as finding by text, data-testid is the escape hatch.  

4. dom-testing-library also works well with user-event, which is a browser event simulation library (click, double-click, enter text, select options). Use that library when fireEvent is not enough.

Queries:

 - getBy* queries return the first matching node for a query, and throw an error if no elements match or if more than one match is found (use getAllBy instead).

 - getAllBy* queries return an array of all matching nodes for a query, and throw an error if no elements match.
 - queryBy* queries return the first matching node for a query, and return null if no elements match. This is useful for asserting an element that is not present. This throws if more than one match is found (use queryAllBy instead).
 - findBy* queries return a promise which resolves when an element is found which matches the given query. default timeout of 4500ms.
 eg findByText(container, 'text', queryOptions, waitForElementOptions)

Tack on:
 
  ByPlaceholderText
  ByText
  ByAltText
  ByTitle
  ByDisplayValue
  ByTestId
 
 Firing events

    fireEvent(node: HTMLElement, event: Event)

    // <button>Submit</button>
    fireEvent(
        getByText(container, 'Submit'),
        new MouseEvent('click', {
           bubbles: true,
           cancelable: true,
        })
    )


Render from react-testing-library
------------------------------------

The render method from react-testing-library basically renders a component and returns back that component along with dom-testing-library queries. 

This allows us to cut down on the number of imports and make a much more readable test:

  import React, { ReactElement } from 'react'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { render } from '@testing-library/react'

  test('renders a number input with a label "Favorite Number"', () => {
      const { getByLabelText } = render(<FavNumber />)
      const input = getByLabelText(/Favorite Number/i)
      expect(input).toHaveAttribute('type', 'number')
  })



Conceptually, the render method looks like this:

  function render(ui) {
    const container = document.createElement('div')
    ReactDOM.render(<FavoriteNumber />, container)
    const queries = getQueriesForElement(container)
    return {
      container,
      ...queries,
    }
  }



Avoid Memoory Leaks with Cleanup
----------------------------------------------------
The render method actually renders your component to the document body (document.body). This is so that react events can be handled correctly. This means that if you have multiple tests that render components, you could fill up the document.body with old components that are never unmounted and cause trouble for your tests (because they’re not isolated).

You can check this out by including this line within a test:

  console.log(document.body.outerHTML)

An unmount method can be returned back from render [from dom-testing-library?].

  const {getByLabelText, unmount} = render(<FavoriteNumber />)
  //... test code ... then call:
  unmount();

However, this would get tedius for every test. Instead you can directly import cleanup and place in a afterEach():

  import {render, cleanup} from 'react-testing-library'

  afterEach(cleanup)
  
  
Debug the DOM state during tests with debug()
-----------------------------------------------------

Render also returns a debug method. You can call it without arguments at any point inside a test to see the full do in the console. If you want to see a smaller subset then pass in a component.

  test('renders a number input with a label "Favorite Number"', () => {
      const { getByLabelText, debug } = render(<FavNumber />)
      const input = getByLabelText(/Favorite Number/i)
      expect(input).toHaveAttribute('type', 'number')
      debug(input)
  })

logs out:
    <input
      id="favorite-number"
      type="number"
      value="0"
    />



Test React Component Event Handlers with fireEvent
--------------------------------------------------

Let's say we have an event handler listen for 'change' events in an input:

    @action
    handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.numberEntered = true;
        this.number = Number( (event.target as HTMLInputElement).value );
    }

import { render, cleanup, fireEvent } from '@testing-library/react'

test('entering an invalid value shows an error message', () => {
    const { getByLabelText, getByTestId } = render(<FavNumber />)
    const input = getByLabelText(/favorite number/i)
    fireEvent.change(input, { target: { value: 10 } })
    expect(getByTestId('error-message')).toHaveTextContent(
        /the number is invalid/i,
    )
})

A huge number of event types exist on fireEvent. Examples include click, copy, and paste.  
  
  
  


