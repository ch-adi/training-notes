_______________________________________________

React Testing Library
-----------------------------------------------



A Basic Example
---------------------------------------

The most basic React component test invloves importing React, ReactDOM, and the component that we're going to render. We create a <div> in which to render our component. We then query around the document so that we can make assertions.

A simple component:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    expect(div.querySelector('input').type).toBe('number')
    expect(div.querySelector('label').textContent).toBe('Favorite Number')
  })


jest-dom for Improved Assertions
--------------------------------------

The assertions in the above simple example are not that helpful. For example miss-spelling a selector actually throws an obscure typerror.

  expect(div.querySelector('nput').type).toBe('number') // i is missing in 'input. TypeError: Cannot read property 'type' of null

We can extend Jest's built in assertions, and get some better messages, with the jest-dom library. Here we use `toHaveAttribute`.

  import "@testing-library/jest-dom/extend-expect";
  
  expect(div.querySelector('nput')).toHaveAttribute('type', 'number') // 'received value must be an HTMLElement or an SVGElement.'
  
Our working assertions now look like:

  expect(div.querySelector('input')).toHaveAttribute('type', 'number')
  expect(div.querySelector('label')).toHaveTextContent('Favorite Number')
  
  
  
  
dom-testing-library for Maintainable Tests
------------------------------------------

Our tests are currently tightly coupled to the implementation of our componentâ€™s element structure. A refactor to that structure wont break our application, but will definitely break our tests because weâ€™re testing implementation details. 

dom-testing-library has a custom render function that will give us some helpful utilities for searching for elements in the DOM in the same way a user would. The more your tests resemble the way your software is used, the more confidence they can give you.

For example if we had a typo in the htmlFor property of the label we are testing, then accessibility might be broken and we wouldn't know. Clicking on the label might not give it focus. The test would still pass. 

  <label htmlFor="favorte-number">Favorite Number</label>  // typo here: no link between the label and the input.
  <input
      id="favorite-number"
      type="number"
      value={this.number}
      onChange={this.handleChange}
  />

On the other hand if we were to change the dom then the selectors may not work, and create a false positive.

Imagine also, if we could somehow find the input by it's label. Then we would be ensuring the correct labels are associated with the correct inputs. 

With dom testing library we can now test for this bug and do it with less assertions:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { queries } from '@testing-library/dom'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    const input = queries.getByLabelText(div, 'Favorite Number')
    expect(input).toHaveAttribute('type', 'number')
  })

// Found a label with the text of: Favorite Number, however no form control was found associated to that label.

Some extra tips:

1. Users don't care about casing. If someone were to change 'Favorite Number' with 'Favorite number' then our tests should not break. So use a regex instead of a string:

  const input = queries.getByLabelText(div, /Favorite Number/i)
  
2. We can scope queries to a particular element

  const { getByLabelText } = getQueriesForElement(div);
  const input = getByLabelText(/Favorite Number/i)

3. While we want our tests to resemble the way our software is used, such as finding by text, data-testid is the escape hatch.  

4. dom-testing-library also works well with user-event, which is a browser event simulation library (click, double-click, enter text, select options). Use that library when fireEvent is not enough.

Queries:

 - getBy* queries return the first matching node for a query, and throw an error if no elements match or if more than one match is found (use getAllBy instead).

 - getAllBy* queries return an array of all matching nodes for a query, and throw an error if no elements match.
 - queryBy* queries return the first matching node for a query, and return null if no elements match. This is useful for asserting an element that is not present. This throws if more than one match is found (use queryAllBy instead).
 - findBy* queries return a promise which resolves when an element is found which matches the given query. default timeout of 4500ms.
 eg findByText(container, 'text', queryOptions, waitForElementOptions)

Tack on:
 
  ByPlaceholderText
  ByText
  ByAltText
  ByTitle
  ByDisplayValue
  ByTestId
 
 Firing events

    fireEvent(node: HTMLElement, event: Event)

    // <button>Submit</button>
    fireEvent(
        getByText(container, 'Submit'),
        new MouseEvent('click', {
           bubbles: true,
           cancelable: true,
        })
    )


Render from react-testing-library
------------------------------------

The render method from react-testing-library basically renders a component and returns back that component along with dom-testing-library queries. 

This allows us to cut down on the number of imports and make a much more readable test:

  import React, { ReactElement } from 'react'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { render } from '@testing-library/react'

  test('renders a number input with a label "Favorite Number"', () => {
      const { getByLabelText } = render(<FavNumber />)
      const input = getByLabelText(/Favorite Number/i)
      expect(input).toHaveAttribute('type', 'number')
  })



Conceptually, the render method looks like this:

  function render(ui) {
    const container = document.createElement('div')
    ReactDOM.render(<FavoriteNumber />, container)
    const queries = getQueriesForElement(container)
    return {
      container,
      ...queries,
    }
  }



Avoid Memoory Leaks with Cleanup
----------------------------------------------------
The render method actually renders your component to the document body (document.body). This is so that react events can be handled correctly. This means that if you have multiple tests that render components, you could fill up the document.body with old components that are never unmounted and cause trouble for your tests (because theyâ€™re not isolated).

You can check this out by including this line within a test:

  console.log(document.body.outerHTML)

An unmount method can be returned back from render [from dom-testing-library?].

  const {getByLabelText, unmount} = render(<FavoriteNumber />)
  //... test code ... then call:
  unmount();

However, this would get tedius for every test. Instead you can directly import cleanup and place in a afterEach():

  import {render, cleanup} from 'react-testing-library'

  afterEach(cleanup)
  
  
Debug the DOM state during tests with debug()
-----------------------------------------------------

Render also returns a debug method. You can call it without arguments at any point inside a test to see the full DOM in the console. If you want to see a smaller subset then pass in a component.

  test('renders a number input with a label "Favorite Number"', () => {
      const { getByLabelText, debug } = render(<FavNumber />)
      const input = getByLabelText(/Favorite Number/i)
      expect(input).toHaveAttribute('type', 'number')
      debug(input)
  })

logs out:
    <input
      id="favorite-number"
      type="number"
      value="0"
    />



Test React Component Event Handlers with fireEvent
--------------------------------------------------

Let's say we have an event handler listen for 'change' events in an input:

    @action
    handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.numberEntered = true;
        this.number = Number( (event.target as HTMLInputElement).value );
    }

In the render method within the associated component we have a conditional rendering of a div that containers an error message:

    {isValid ? null : (
        <div data-testid="error-message">The number is invalid</div>
    )}


In this test there are three examples of how we might find and test the text in that div:


  import { render, cleanup, fireEvent } from '@testing-library/react'

  test('entering an invalid value shows an error message', () => {
      const { getByLabelText, getByTestId, container, getByText } = render(<FavNumber />)

      const input = getByLabelText(/favorite number/i)
      fireEvent.change(input, { target: { value: 10 } })

      // not very explicit
      expect(container).toHaveTextContent(
          /the number is invalid/i,
      )

      //essentially an assertion because will throw an error is it can't find such a node
      getByText(/the number is invalid/i) 

      // more explicit
      expect(getByTestId('error-message')).toHaveTextContent(
          /the number is invalid/i,
      )
  })

A huge number of event types exist on fireEvent. Examples include click, copy, and paste.  
  
  


Testing Props update with `rerender`
---------------------------------------------------------

We can pass in props to the component under test with the rerender method. Here we extend the above test by checking the default props and then changing one of the props.

  test('entering an invalid value shows an error message', () => {
      const { getByLabelText, getByTestId, rerender, queryByText, debug } = render(<FavNumber />)

      const input = getByLabelText(/favorite number/i)
      fireEvent.change(input, { target: { value: 10 } })

      expect(getByTestId('error-message')).toHaveTextContent(
          /the number is invalid/i,
      )

      // rerender with a new prop that will make the user's error message disappear
      rerender(<FavNumber max={10}/>)

      // example of how to test something does not exist
      expect(queryByText(/the number is invalid/i)).toBe(null)
  })




Test accessibility of rendered React Components with jest-axe
--------------------------------------------------------------

In this example we have a form without an associated label. We can use jest-axe to search out accessibility violations and pick this up (it logs to the console).

  import React from 'react'
  import {render} from 'react-testing-library'
  import {axe, toHaveNoViolations} from 'jest-axe'
  import 'jest-axe/extend-expect'   // allow us to use toHaveNoViolations

  // expect.extend(toHaveNoViolations)  // can manually extend here instead of 'import 'jest-axe/extend-expect'

  function Form() {
    return (
      // should have a label here
      <form>
        <input placeholder="username" name="username" />
      </form>
    )
  }

  // what the form should look like (id in the input matches the htmlFor in the label):
  function AccessibleForm() {
    return (
      <form>
        <label htmlFor="username">Username</label>
        <input id="username" placeholder="username" name="username" />
      </form>
    )
  }

  // note that axe is async
  test('the form is accessible', async () => {
    const {container} = render(<Form />)
    const results = await axe(container.innerHTML)
    expect(results).toHaveNoViolations()      // fails: "Form elements must have labels (label)"
  })



Mock HTTP Requests with jest.mock and async expectations
--------------------------------------------

This component uses an async HTTP API call in a method named loadGreeting:

  @observer
  export class GreetingLoader extends Component {
      private inputRef: React.RefObject<HTMLInputElement> = React.createRef()

      @observable
      greeting = '';

      @action
      loadGreetingForInput = async (e: React.FormEvent<HTMLFormElement>) => {
          e.preventDefault()
          const { data } = await loadGreeting(this.inputRef.current.value)  // async API call
          this.greeting = data;
      }

      render() {
          return (
              <form onSubmit={(e) => this.loadGreetingForInput(e)}>
                  <label htmlFor="name">Name</label>
                  <input id="name" ref={this.inputRef} />
                  <button type="submit">Load Greeting</button>
                  <div data-testid="greeting">{this.greeting}</div>
              </form>
          )
      }
  }

  import React, { ReactElement } from 'react'
  import '@testing-library/jest-dom/extend-expect'
  import { render, cleanup, fireEvent, wait } from '@testing-library/react'
  import { GreetingLoader } from './greeting'
  
  // ***
  //after mocking a module below we used this import to help with the last two assertions
  // ***
  import { loadGreeting as mockLoadGreeting } from '../api/loadGreeting'

  // making an async mock
  jest.mock('../api/loadGreeting', () => {
      return {
          loadGreeting: jest.fn(value =>
              Promise.resolve({ data: value })
      ,)}
  })

  afterEach(cleanup)

  test('Submitted greeting is displayed', async () => {
      const { getByLabelText, getByTestId, getByText, debug } = render(<GreetingLoader />)

      const testInputValue = 'Bob';

      const input = getByLabelText(/Name/i)
      fireEvent.change(input, { target: { value: testInputValue } })

      const sumbutButton = getByText(/Load Greeting/i)
      fireEvent.click(sumbutButton);

      // how to test async code with `wait`, which is imported directly from RTL
      await wait(() => expect(getByTestId('greeting')).toHaveTextContent(
          testInputValue,
      ))

      expect(mockLoadGreeting).toHaveBeenCalledTimes(1);
      expect(mockLoadGreeting).toHaveBeenCalledWith(testInputValue);
  })




Mock HTTP Requests with Dependency Injection in React Component Tests
----------------------------------------------------------------------
Generally the jest.mock approach in the previous section is preferable because it doesn't require that you change your implementation. However if you an environment that doesn't support the Jest mocking capabilities we can inject a dependancy with the React defaultProp feature.

In the test file we remove the explicit mock of the API method/request and move it into the test block. It is then passed in as a prop.

    // REMOVED import {loadGreeting as mockLoadGreeting} from '../api'
    // REMOVED jest.mock(...)

    test('loads greetings on click', () => {
      const mockLoadGreeting = jest.fn(subject =>
        Promise.resolve({data: {greeting: `Hi ${subject}`}})
      )
      // now the mock is passed in as a prop to the component under test
      const {getByLabelText, getByText, getByTestId} = render(<GreetingLoader loadGreeting={mockLoadGreeting} />)
      // ... as before
    
 In our component we now use the api method as a default prop. If we are not in test mode that the real API method will be called:
 
   class GreetingLoader extends Component {
    static defaultProps = {loadGreeting}
    // ...
    loadGreetingForInput = async e => {
      //...
      const {data} = await this.props.loadGreeting(this.inputRef.current.value)  // this method is now on props
      //...
    }




Mocking an async 3rd party library function
-----------------------------------------------

To properly mock a third party component, you need to simulate the same API.

In this example we have 3rd party library called CSSTransition that will allow for a fade in timeout. When a user toggles a button then a hidden message will appear 1 second later.


hidden-message.js:

  import {CSSTransition} from 'react-transition-group'

  function Fade({children, ...props}) {
    return (
      <CSSTransition {...props} timeout={1000} className="fade">
        {children}
      </CSSTransition>
    )
  }

  class HiddenMessage extends React.Component {
    state = {show: false}
    toggle = () => {
      this.setState(({show}) => ({show: !show}))
    }
    render() {
      return (
        <div>
          <button onClick={this.toggle}>Toggle</button>
          <Fade in={this.state.show}>
            <div>{this.props.children}</div>
          </Fade>
        </div>
      )
    }
  }

In our test, we don't want to wait 1,000 milliseconds before we can verify that the children have been added or removed from the document. We're going to mock out the CSSTransition component from react-transition-group. We see that CSSTransition takes an `in` prop to know whether or not the children should be rendered. So our mock component will also take this prop.

Our test:

  // these should normally be in your jest setupTestFrameworkScriptFile
  import 'jest-dom/extend-expect'
  import 'react-testing-library/cleanup-after-each'
  
  import React from 'react'
  import {render} from 'react-testing-library'
  import {HiddenMessage} from '../hidden-message'
  
  jest.mock('react-transition-group', () => {
    return {
      CSSTransition: props => (props.in ? props.children : null),
    }
  })

  test('shows hidden message when toggle is clicked', () => {
    const myMessage = 'hello world'
    const {getByText, queryByText} = render(<HiddenMessage>{myMessage}</HiddenMessage>)
    const toggleButton = getByText(/toggle/i)
    expect(queryByText(myMessage)).not.toBeInTheDocument()
    fireEvent.click(toggleButton)
    expect(getByText(myMessage)).toBeInTheDocument()
    fireEvent.click(toggleButton)
    expect(queryByText(myMessage)).not.toBeInTheDocument()
  })



Error Boundaries
---------------------------------------------------

Imagine that we have an error boundary component. It wraps around the code at a high level, catching errors and sending them off to a server.

  import React from 'react'
  import {reportError} from './api'

  class ErrorBoundary extends React.Component {
    state = {hasError: false}
    componentDidCatch(error, info) {
      this.setState({hasError: true})
      reportError(error, info)
    }
    tryAgain = () => this.setState({hasError: false})
    render() {
      return this.state.hasError ? (
        <div>
          <div>There was a problem.</div>{' '}
          <button onClick={this.tryAgain}>Try again?</button>
        </div>
      ) : (
        this.props.children
      )
    }
  }

  export {ErrorBoundary}

our test:

// these should normally be in your jest setupTestFrameworkScriptFile
import 'react-testing-library/cleanup-after-each'
import 'jest-dom/extend-expect'

import React from 'react'
import {render, fireEvent} from 'react-testing-library'
import {reportError as mockReportError} from '../api'
import {ErrorBoundary} from '../error-boundary'

// mock out the server request
jest.mock('../api', () => {
  return {
    reportError: jest.fn(() => Promise.resolve({success: true})),
  }
})

beforeEach(() => {
  // Eventhough the tests are passing (ie we are correctly handling errors) 
  // jest-dom will continuew to log out the errors in the console via console.error. 
  // Since this makes the test output noisy very noisy we'll mock out console.error
  jest.spyOn(console, 'error').mockImplementation(() => {})
})

afterEach(() => {
  console.error.mockRestore()
})

// a function set up tho throw errors, as required
function Bomb({shouldThrow}) {
  if (shouldThrow) {
    throw new Error('ðŸ’£')
  } else {
    return null
  }
}

test('calls reportError and renders that there was a problem', () => {
  
  // render without an error
  const {container, rerender, getByText} = render(
    <ErrorBoundary>
      <Bomb />
    </ErrorBoundary>,
  )

  // now re-render with an error.
  rerender(
    <ErrorBoundary>
      <Bomb shouldThrow={true} />
    </ErrorBoundary>,
  )

  expect(mockReportError).toHaveBeenCalledTimes(1)
  
  // error and info are the arguments passed in the server request: reportError(error, info)
  
  const error = expect.any(Error)
  const info = {componentStack: expect.stringContaining('Bomb')}  // info is react specific info
  expect(mockReportError).toHaveBeenCalledWith(error, info)

  expect(container).toHaveTextContent('There was a problem')

  // by mocking out console.error we may inadvertantly be missing out on logs
  // in the future that could be important, so let's reduce that liklihood by
  // adding an assertion for how frequently console.error is called.
  expect(console.error).toHaveBeenCalledTimes(2)

  // ensure the user can recover from errors (which is a user option: see the try again button)
  
  // first clear out the calls object. You can see what's in these by logging out mockReportError.mock.calls
  console.error.mockClear()
  mockReportError.mockClear()

  rerender(
    <ErrorBoundary>
      <Bomb />
    </ErrorBoundary>,
  )
  fireEvent.click(getByText(/try again/i))

  expect(mockReportError).not.toHaveBeenCalled()
  expect(console.error).not.toHaveBeenCalled()
  expect(container).not.toHaveTextContent('There was a problem')
})


Testing a button is disabled after a click:
-----------------------------------------------

test code:

  fireEvent.click(submitButton)
  expect(submitButton).toBeDisabled()
  
The component:

  class Editor extends React.Component {
    state = {isSaving: false}
    handleSubmit = e => {
      e.preventDefault()
      this.setState({isSaving: true})
    }
    // ...
    <button type='submit' disabled={this.state.isSaving}>
        Submit
    </button>


Testing the data posted in a form submission
----------------------------------------------

We have a form with name attributes inlcuded:

    <form onSubmit={this.handleSubmit}>
        <label htmlFor="title-input">Title</label>
        <input id="title-input" name="title"/>

        <label htmlFor="content-input">Content</label>
        <textarea id="content-input" name="content"/>

        <label htmlFor="tags-input">Tags</label>
        <input id="tags-input" name="tags"/>

        <button type='submit' disabled={this.state.isSaving}>
          Submit
        </button>
     </form>
     
The event handler will call savePost, which is an API call that we will mock:

  handleSubmit = e => {
    e.preventDefault()
    
    // we have access to this data because of the name attribute in the form elements
    const {title, content, tags} = e.target.elements
    
    this.setState({isSaving: true}) // see previous section on button disabling
    
    savePost({
      title: title.value,
      content: content.value,
      tags: tags.value.split(',').map(t => t.trim()),
      authorId: this.props.user.id
    })
  }

The test code:

  // alias for the mocked method so it's clear that we are mocking
  import {savePost as mockSavePost} from '../api'

    jest.mock('../api', () => {
      return {
        savePost: jest.fn(() => Promise.resolve)
      }
    })

    afterEach(() => {
      mockSavePost.mockClear()
    })

    test('renders a form with title, content, tags, and a submit button', () => {
      const fakeUser = {id: 'user-1'}
      const {getByLabelText, getByText} = render(<Editor user={fakeUser} />)
      
      // keep reused variables in one place. This is the data that we expect will be posted to the server
      const fakePost = {
        title: 'Test Title',
        content: 'Test content',
        tags: ['tag1', 'tag2']
      }
      
      // simulate user entries in the form
      getByLabelText(/title/i).value = fakePost.title
      getByLabelText(/content/i).value = fakePost.content
      getByLabelText(/tags/i).value = fakePost.tags.join(', ')
      const submitButton = getByText(/submit/i)

      fireEvent.click(submitButton)

      expect(submitButton).toBeDisabled()
      expect(mockSavePost).toHaveBeenCalledTimes(1)
      expect(mockSavePost).toHaveBeenCalledWith({
        ...fakePost,
        authorId: fakeUser.id
      })
    })



Test Redirection
----------------------------------

After submitting a form we mght like to redirect the user to the home page. We can do that with the Redirect method from react-router.

To enable this behaviour we add a then() to the API call in the event handler. We want to redirect after the post.  


  import {Redirect} from 'react-router'

  class Editor extends React.Component {
    state = {isSaving: false, redirect: false}
    handleSubmit = e => {
      ...
      savePost(newPost).then(() => this.setState({redirect: true}))
    }
    render() {
      if (this.state.redirect) {
        return <Redirect to="/" />
      }
    ...

In our test we could initially try:

    import {Redirect as MockRedirect} from 'react-router'
  //...
    jest.mock('react-router', () => {
      return {
        Redirect: jest.fn(() => null)
      }
    })
    
    afterEach(() => {
      MockRedirect.mockClear()
      mockSavePost.mockClear()
    })
   //...
    expect(MockRedirect).toHaveBeenCalledTimes(1)
    
However, because savePost is async, the callback in it's following then() will be async. So this test will always fail. Instead we can import the wait method from RTL. It has 4.5s timeout and within that time it will call it's assocated callback every 50ms. If errors are no longer returned in that 4.5s window then the test will pass:

  await wait(() => expect(MockRedirect).toHaveBeenCalledTimes(1))  // also make the call back in 'test' async.
  
We can now follow up with another assertion that will test the props being passed in '{to: '/'}', and the context ({}).

   expect(MockRedirect).toHaveBeenCalledWith({to: '/'}, {})

Because wait takes 4.5s to timeout it's better to limit the amount of assertions you pass into it. So if you want fast feedback on test failures don't do this:

  await wait(() => {
    expect(MockRedirect).toHaveBeenCalledTimes(1))
    expect(MockRedirect).toHaveBeenCalledWith({to: '/'}, {})
  }
  
  
Testing Date of Form Submission (and understanding the mock object)
--------------------------------------

We previously mocked a form submission ight we might also like to check the date/time it was submitted. Because the data is so precise we can't just explicitly pass it in and then check it the same in the test. Instead we can check the date lies between two points.

First, in the component we pass in a date:

    const newPost = {
      title: title.value,
      content: content.value,
      tags: tags.value.split(',').map(t => t.trim()),
      date: new Date().toISOString(),                 // date string as isostring so that it can be saved on the server
      authorId: this.props.user.id,
    }


test( //...

 const preDate = Date.now()
 
 // set up and action the test
 fireEvent.click(submitButton)
 // ...
 
 const postDate = Date.now()
 
 // update our other test: we arn't testing date there so we just need to make sure we have a string
   expect(mockSavePost).toHaveBeenCalledWith({
    ...fakePost,
    date: expect.any(String),   // any string will do
    authorId: fakeUser.id,
  })
 
  // test the date is within expected bounds
  const date = new Date(mockSavePost.mock.calls[0][0].date).getTime()  // generate a new date
  expect(date).toBeGreaterThanOrEqual(preDate)
  expect(date).toBeLessThanOrEqual(postDate)

The tricky bit is `mockSavePost.mock.calls[0][0].date`. This says that the mock function, mockSavePost, has a mock property. `calls` is the are each call made to the mocks. [0][0] means that we want the first call, and the first argument on that call. We then take the date argument from that object. Once we have that isoString date we can pass it into new Date() and make a new date for comparison.
  
  
  
 Use generated data to improve test maintainability
 --------------------------------------------------

A critical piece to making your tests easier to maintain is using code structure and values to communicate what is important and what is not. In the example above we have a fake postPost variable. The content of that variable is irrelevant. We only care that the correct data, whatever it is, is being sent ot the server. We can randonly generate these values so that maintainers of our tests know that the content does not matter.

Out old fakePost:

      const fakePost = {
        title: 'Test Title',
        content: 'Test content',
        tags: ['tag1', 'tag2']
      }

New random data:

  import {build, fake, sequence} from 'test-data-bot'
  
  const postBuilder = build('Post').fields({
    title: fake(f => f.lorem.words()),          // f is from faker, another npm library that generates random things
    content: fake(f => f.lorem.paragraphs().replace(/\r/g, '')),      // tidy up line returns
    tags: fake(f => [f.lorem.word(), f.lorem.word(), f.lorem.word()]),  // making an array
  })

  const userBuilder = build('User').fields({
    id: sequence(s => `user-${s}`),
  })
  
  
Used in our test:

  test('renders a form with title, content, tags, and a submit button', async () => {
    const fakeUser = userBuilder()
    const fakePost = postBuilder() // ...



Test drive error state with react-testing-library
------------------------------------------------------

What happens when the save post request fails? We have tested the happy case but what if thereâ€™s an error in saving the userâ€™s information? We should probably show them an error message and give them the chance to try again. 

Since this is an entirely new flow, we need to add a new test. 

  import {savePost as mockSavePost} from '../api'
  
  jest.mock('../api', () => {
    return {
      savePost: jest.fn(() => Promise.resolve()),  // we cant rewrite this to `reject` since it would break other tests. See below.
    }
  })


  test('renders an error message from the server', async () => {
    const testError = 'test error'  // use a variable to explicitly show that the value should not be changing
    mockSavePost.mockRejectedValueOnce({data: {error: testError}})   // we dont need to change the above mock in a promise rejection
    const fakeUser = userBuilder()
    const {getByLabelText, getByText, getByTestId} = render(
      <Editor user={fakeUser} />,
    )
    const fakePost = postBuilder()

    getByLabelText(/title/i).value = fakePost.title
    getByLabelText(/content/i).value = fakePost.content
    getByLabelText(/tags/i).value = fakePost.tags.join(', ')
    const submitButton = getByText(/submit/i)

    fireEvent.click(submitButton)

    const postError = await waitForElement(() => getByTestId('post-error'))  //waitForElement imported from RTL
    expect(postError).toHaveTextContent(testError)  // once the above element has rendered we expect the correct content
    expect(submitButton).not.toBeDisabled()     // make sure this is not disabled so that the user can try again
  })






    
   
    
