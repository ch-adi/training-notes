_______________________________________________

React Testing Library
-----------------------------------------------



A Basic Example
---------------------------------------

The most basic React component test invloves importing React, ReactDOM, and the component that we're going to render. We create a <div> in which to render our component. We then query around the document so that we can make assertions.

A simple component:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    expect(div.querySelector('input').type).toBe('number')
    expect(div.querySelector('label').textContent).toBe('Favorite Number')
  })


jest-dom for Improved Assertions
--------------------------------------

The assertions in the above simple example are not that helpful. For example miss-spelling a selector actually throws an obscure typerror.

  expect(div.querySelector('nput').type).toBe('number') // i is missing in 'input. TypeError: Cannot read property 'type' of null

We can extend Jest's built in assertions, and get some better messages, with the jest-dom library. Here we use `toHaveAttribute`.

  import "@testing-library/jest-dom/extend-expect";
  
  expect(div.querySelector('nput')).toHaveAttribute('type', 'number') // 'received value must be an HTMLElement or an SVGElement.'
  
Our working assertions now look like:

  expect(div.querySelector('input')).toHaveAttribute('type', 'number')
  expect(div.querySelector('label')).toHaveTextContent('Favorite Number')
  
  
  
  
dom-testing-library for Maintainable Tests
------------------------------------------

Our tests are currently tightly coupled to the implementation of our component’s element structure. A refactor to that structure wont break our application, but will definitely break our tests because we’re testing implementation details. 

dom-testing-library has a custom render function that will give us some helpful utilities for searching for elements in the DOM in the same way a user would. The more your tests resemble the way your software is used, the more confidence they can give you.

For example if we had a typo in the htmlFor property of the label we are testing, then accessibility might be broken and we wouldn't know. Clicking on the label might not give it focus. The test would still pass. 

  <label htmlFor="favorte-number">Favorite Number</label>  // typo here: no link between the label and the input.
  <input
      id="favorite-number"
      type="number"
      value={this.number}
      onChange={this.handleChange}
  />

On the other hand if we were to change the dom then the selectors may not work, and create a false positive.

Imagine also, if we could somehow find the input by it's label. Then we would be ensuring the correct labels are associated with the correct inputs. 

With dom testing library we can now test for this bug and do it with less assertions:

  import React from 'react'
  import ReactDOM from 'react-dom'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { queries } from '@testing-library/dom'

  test('renders a number input with a label "Favorite Number"', () => {
    const div = document.createElement('div');
    ReactDOM.render(<FavNumber />, div)

    const input = queries.getByLabelText(div, 'Favorite Number')
    expect(input).toHaveAttribute('type', 'number')
  })

// Found a label with the text of: Favorite Number, however no form control was found associated to that label.

Some extra tips:

1. Users don't care about casing. If someone were to change 'Favorite Number' with 'Favorite number' then our tests should not break. So use a regex instead of a string:

  const input = queries.getByLabelText(div, /Favorite Number/i)
  
2. We can scope queries to a particular element

  const { getByLabelText } = getQueriesForElement(div);
  const input = getByLabelText(/Favorite Number/i)

3. While we want our tests to resemble the way our software is used, such as finding by text, data-testid is the escape hatch.  

4. dom-testing-library also works well with user-event, which is a browser event simulation library (click, double-click, enter text, select options). Use that library when fireEvent is not enough.

Queries:

 - getBy* queries return the first matching node for a query, and throw an error if no elements match or if more than one match is found (use getAllBy instead).

 - getAllBy* queries return an array of all matching nodes for a query, and throw an error if no elements match.
 - queryBy* queries return the first matching node for a query, and return null if no elements match. This is useful for asserting an element that is not present. This throws if more than one match is found (use queryAllBy instead).
 - findBy* queries return a promise which resolves when an element is found which matches the given query. default timeout of 4500ms.
 eg findByText(container, 'text', queryOptions, waitForElementOptions)

Tack on:
 
  ByPlaceholderText
  ByText
  ByAltText
  ByTitle
  ByDisplayValue
  ByTestId
 
 Firing events

    fireEvent(node: HTMLElement, event: Event)

    // <button>Submit</button>
    fireEvent(
        getByText(container, 'Submit'),
        new MouseEvent('click', {
           bubbles: true,
           cancelable: true,
        })
    )


Render from react-testing-library
------------------------------------

The render method from react-testing-library basically renders a component and returns back that component along with dom-testing-library queries. 

This allows us to cut down on the number of imports and make a much more readable test:

  import React, { ReactElement } from 'react'
  import { FavNumber } from './fav-num'
  import '@testing-library/jest-dom/extend-expect'
  import { render } from '@testing-library/react'

  test('renders a number input with a label "Favorite Number"', () => {
      const { getByLabelText } = render(<FavNumber />)
      const input = getByLabelText(/Favorite Number/i)
      expect(input).toHaveAttribute('type', 'number')
  })



Conceptually, the render method looks like this:

  function render(ui) {
    const container = document.createElement('div')
    ReactDOM.render(<FavoriteNumber />, container)
    const queries = getQueriesForElement(container)
    return {
      container,
      ...queries,
    }
  }



Avoid Memoory Leaks with Cleanup
----------------------------------------------------
The render method actually renders your component to the document body (document.body). This is so that react events can be handled correctly. This means that if you have multiple tests that render components, you could fill up the document.body with old components that are never unmounted and cause trouble for your tests (because they’re not isolated).

You can check this out by including this line within a test:

  console.log(document.body.outerHTML)

An unmount method can be returned back from render [from dom-testing-library?].

  const {getByLabelText, unmount} = render(<FavoriteNumber />)
  //... test code ... then call:
  unmount();

However, this would get tedius for every test. Instead you can directly import cleanup and place in a afterEach():

  import {render, cleanup} from 'react-testing-library'

  afterEach(cleanup)
  
  
Debug the DOM state during tests with debug()
-----------------------------------------------------

Render also returns a debug method. You can call it without arguments at any point inside a test to see the full DOM in the console. If you want to see a smaller subset then pass in a component.

  test('renders a number input with a label "Favorite Number"', () => {
      const { getByLabelText, debug } = render(<FavNumber />)
      const input = getByLabelText(/Favorite Number/i)
      expect(input).toHaveAttribute('type', 'number')
      debug(input)
  })

logs out:
    <input
      id="favorite-number"
      type="number"
      value="0"
    />



Test React Component Event Handlers with fireEvent
--------------------------------------------------

Let's say we have an event handler listen for 'change' events in an input:

    @action
    handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.numberEntered = true;
        this.number = Number( (event.target as HTMLInputElement).value );
    }

In the render method within the associated component we have a conditional rendering of a div that containers an error message:

    {isValid ? null : (
        <div data-testid="error-message">The number is invalid</div>
    )}


In this test there are three examples of how we might find and test the text in that div:


  import { render, cleanup, fireEvent } from '@testing-library/react'

  test('entering an invalid value shows an error message', () => {
      const { getByLabelText, getByTestId, container, getByText } = render(<FavNumber />)

      const input = getByLabelText(/favorite number/i)
      fireEvent.change(input, { target: { value: 10 } })

      // not very explicit
      expect(container).toHaveTextContent(
          /the number is invalid/i,
      )

      //essentially an assertion because will throw an error is it can't find such a node
      getByText(/the number is invalid/i) 

      // more explicit
      expect(getByTestId('error-message')).toHaveTextContent(
          /the number is invalid/i,
      )
  })

A huge number of event types exist on fireEvent. Examples include click, copy, and paste.  
  
  


Testing Props update with `rerender`
---------------------------------------------------------

We can pass in props to the component under test with the rerender method. Here we extend the above test by checking the default props and then changing one of the props.

  test('entering an invalid value shows an error message', () => {
      const { getByLabelText, getByTestId, rerender, queryByText, debug } = render(<FavNumber />)

      const input = getByLabelText(/favorite number/i)
      fireEvent.change(input, { target: { value: 10 } })

      expect(getByTestId('error-message')).toHaveTextContent(
          /the number is invalid/i,
      )

      // rerender with a new prop that will make the user's error message disappear
      rerender(<FavNumber max={10}/>)

      // example of how to test something does not exist
      expect(queryByText(/the number is invalid/i)).toBe(null)
  })




Test accessibility of rendered React Components with jest-axe
--------------------------------------------------------------

In this example we have a form without an associated label. We can use jest-axe to search out accessibility violations and pick this up (it logs to the console).

  import React from 'react'
  import {render} from 'react-testing-library'
  import {axe, toHaveNoViolations} from 'jest-axe'
  import 'jest-axe/extend-expect'   // allow us to use toHaveNoViolations

  // expect.extend(toHaveNoViolations)  // can manually extend here instead of 'import 'jest-axe/extend-expect'

  function Form() {
    return (
      // should have a label here
      <form>
        <input placeholder="username" name="username" />
      </form>
    )
  }

  // what the form should look like (id in the input matches the htmlFor in the label):
  function AccessibleForm() {
    return (
      <form>
        <label htmlFor="username">Username</label>
        <input id="username" placeholder="username" name="username" />
      </form>
    )
  }

  // note that axe is async
  test('the form is accessible', async () => {
    const {container} = render(<Form />)
    const results = await axe(container.innerHTML)
    expect(results).toHaveNoViolations()      // fails: "Form elements must have labels (label)"
  })



Mock HTTP Requests with jest.mock and async expectations
--------------------------------------------

This component uses an async HTTP APIc all called loadGreeting:

  @observer
  export class GreetingLoader extends Component {
      private inputRef: React.RefObject<HTMLInputElement> = React.createRef()

      @observable
      greeting = '';

      loadGreetingForInput = async (e: React.FormEvent<HTMLFormElement>) => {
          e.preventDefault()
          const { data } = await loadGreeting(this.inputRef.current.value)
          //const data = this.inputRef.current.value;
          this.greeting = data;
      }

      render() {
          return (
              <form onSubmit={(e) => this.loadGreetingForInput(e)}>
                  <label htmlFor="name">Name</label>
                  <input id="name" ref={this.inputRef} />
                  <button type="submit">Load Greeting</button>
                  <div data-testid="greeting">{this.greeting}</div>
              </form>
          )
      }
  }

  import React, { ReactElement } from 'react'
  import '@testing-library/jest-dom/extend-expect'
  import { render, cleanup, fireEvent, wait } from '@testing-library/react'
  import { GreetingLoader } from './greeting'
  
  // ***
  //after mocking a module below we used this import to help with the last two assertions
  // ***
  import { loadGreeting as mockLoadGreeting } from '../api/loadGreeting'

  // making an async mock
  jest.mock('../api/loadGreeting', () => {
      return {
          loadGreeting: jest.fn(value =>
              Promise.resolve({ data: value })
      ,)}
  })

  afterEach(cleanup)

  test('Submitted greeting is displayed', async () => {
      const { getByLabelText, getByTestId, getByText, debug } = render(<GreetingLoader />)

      const testInputValue = 'Bob';

      const input = getByLabelText(/Name/i)
      fireEvent.change(input, { target: { value: testInputValue } })

      const sumbutButton = getByText(/Load Greeting/i)
      fireEvent.click(sumbutButton);

      // how to test async code with `wait`, which is imported directly from RTL
      await wait(() => expect(getByTestId('greeting')).toHaveTextContent(
          testInputValue,
      ))

      expect(mockLoadGreeting).toHaveBeenCalledTimes(1);
      expect(mockLoadGreeting).toHaveBeenCalledWith(testInputValue);
  })




